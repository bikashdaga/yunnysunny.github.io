<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="icon" type="image/png" href="/images/cabin.png" >
    <link href="/styles/main.css" rel="stylesheet">
    
    <title>白一梓的博客</title>
    
    
	<style type="text/css">

	.social-media a.qq {
		background-position: 0 0;
	}
	
	.social-media a.sina {
		background-position: -39px 0;
		width: 22px;
	}
	.social-media a.qq:hover {
		background-position: 0 -28px;
	}
	.social-media a.sina:hover {
		background-position: -39px -28px;
		width: 22px;
	}
	.social-media a {
		background: rgba(0, 0, 0, 0) url("/images/sns.png") no-repeat scroll 0 0;
		display: inline-block;
		float: left;
		height: 20px;
		margin: 10px 5px;
		width: 20px;
	}	
	</style>
	<link title="白一梓的博文" href="/feed.xml" rel="alternate" type="application/rss+xml" />
  </head>
  <body>
    <nav>
      <h1 class="name">
        <a href="/">白一梓</a>
      </h1>
      <div class="menu icon-menu"></div>
      <ul class="nav-links">
        <li class="text-link">
          <a href="/about.html">关于</a>
        </li>
        <li class="text-link">
          <a href="/projects.html">项目</a>
        </li>
        <li class="text-link">
          <a href="/archives.html">文章</a>
        </li>
      </ul>
      <div class="social-media">
		<a title="我的腾讯微博" class="qq" href="http://t.qq.com/baiyizi" target="_blank"></a>
		<a title="我的新浪微博" class="sina" href="http://weibo.com/1261004702" target="_blank"></a>        
      </div>
    </nav>
    <div class="content">


  <div class="post-head group">
  <a href="/posts/nan/">
    <h1 class="post-title">nan入门教程</h1>
  </a>
  <span class="post-date">2015 &#183; 5 &#183; 24</span>
</div>

<div class="post-body markdown"><p>Node.js在升级到0.12后，c++ API部分发生了翻天覆地的变化，如果你之前的代码是按照0.10的API编写的，将其改成0.12的形式是需要耗费一番精力的，但是问题又来了，你如果改为0.12形式，0.10又不能够被兼容了。幸好有<a href="https://github.com/nodejs/nan">nan</a>，其实它的核心是一个头文件，通过宏定义来做不同版本的node的c++ API的兼容。</p>
<h2><a name="1" class="anchor" href="#1"><span class="header-link"></span></a>1.配置</h2>
<p>首先你得在<code>package.json</code>中引入<code>nan</code>,然后在binding.gyp中配置：</p>
<pre><code><div class="highlight"><pre><span class="s2">&quot;include_dirs&quot;</span> <span class="o">:</span> <span class="p">[</span>
    <span class="s2">&quot;&lt;!(node -e \&quot;require(&#39;nan&#39;)\&quot;)&quot;</span>
<span class="p">]</span>
</pre></div>
</code></pre>
<p> 最后在使用<code>nan</code>的c++文件中引入头文件<code>#include&lt;nan.h&gt;</code>。</p>
<h2><a name="2-demo" class="anchor" href="#2-demo"><span class="header-link"></span></a>2.demo</h2>
<p> 下面的demo摘自nan的readme文档</p>
<pre><code><div class="highlight"><pre> <span class="c1">// addon.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="c1">// ..引入async.h或者sync.h</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">FunctionTemplate</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Handle</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Object</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">String</span><span class="p">;</span>

<span class="k">void</span> <span class="nx">InitAll</span><span class="p">(</span><span class="nx">Handle</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">exports</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;calculateSync&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>

  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;calculateAsync&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">CalculateAsync</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">NODE_MODULE</span><span class="p">(</span><span class="nx">addon</span><span class="p">,</span> <span class="nx">InitAll</span><span class="p">)</span>   
</pre></div>
</code></pre>
<p><strong>代码2.1 addon.cc</strong></p>
<p>首先就是导出函数部分，<code>nan</code>中写法为<code>exports-&gt;Set(NanNew&lt;String&gt;(&quot;calculateSync&quot;),
        NanNew&lt;FunctionTemplate&gt;(CalculateSync)-&gt;GetFunction());</code>，对于c++ api来说，在nan中全部都要用<code>NanNew</code>来声明，在0.10中这句话被写作<code>exports-&gt;Set(String::NewSymbol(&quot;calculateSync&quot;),FunctionTemplate::New(CalculateAsync)-&gt;GetFunction());</code>在0.12中是<code>NODE_SET_METHOD(exports, &quot;calculateSync&quot;, CalculateAsync);</code>。
 正常情况下需要引入函数<code>CalculateAsync</code>所在的头文件的，但是官方文档给出了两个<code>CalculateAsync</code>函数的实现，一个同步版，一个异步版。同步版仅仅是直接调用：</p>
<pre><code><div class="highlight"><pre><span class="c1">// sync.h</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>

<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><strong>代码2.2 sync.h</strong></p>
<p>通过头文件就可以看出，函数声明的方式需要使用<code>NAN_METHOD(CalculateSync)</code>，这等同于0.10中的<code>Handle&lt;Value&gt; CalculateSync(const Arguments&amp; args)</code>,在0.12中要这么写<code>void CalculateSync(const FunctionCallbackInfo&lt;Value&gt;&amp; args)</code>。</p>
<pre><code><div class="highlight"><pre><span class="c1">// sync.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="s2">&quot;./sync.h&quot;</span>
<span class="c1">// ...引入第三方类库头文件</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Number</span><span class="p">;</span>

<span class="c1">// Simple synchronous access to the `Estimate()` function</span>
<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">NanScope</span><span class="p">();</span>

  <span class="c1">// expect a number as the first argument</span>
  <span class="kr">int</span> <span class="nx">points</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">Uint32Value</span><span class="p">();</span>
  <span class="kr">double</span> <span class="nx">est</span> <span class="o">=</span> <span class="nx">Estimate</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span><span class="c1">//Estimate是一个第三方类库的函数，这里可以不用理会</span>

  <span class="nx">NanReturnValue</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">Number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">est</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码2.3 sync.cc</strong>
首先是函数<code>NanScope();</code>,他来完成node0.10中的<code>HandleScope scope;</code>的功能，在node0.12中是：</p>
<pre><code><div class="highlight"><pre><span class="nx">Isolate</span><span class="o">*</span> <span class="nx">isolate</span> <span class="o">=</span> <span class="nx">Isolate</span><span class="o">::</span><span class="nx">GetCurrent</span><span class="p">();</span>
<span class="nx">HandleScope</span> <span class="nx">scope</span><span class="p">(</span><span class="nx">isolate</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>函数结束返回值操作也变成由函数（确切的说应该是宏定义）NanReturnValue来代替。</p>
<p>更令人振奋的是，nan中还对libuv中的函数<code>uv_queue_work</code>进行了抽象，可以通过继承类<code>NanAsyncWorker</code>来实现异步话操作，省去了为了使用<code>uv_queue_work</code>而自定义数据结构的步骤。下面就是async.cc的代码：</p>
<pre><code><div class="highlight"><pre><span class="c1">// async.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="s2">&quot;./async.h&quot;</span>

<span class="c1">// ...引入第三方类库</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Function</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Local</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Null</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Number</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Value</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">PiWorker</span> <span class="o">:</span> <span class="kr">public</span> <span class="nx">NanAsyncWorker</span> <span class="p">{</span>
 <span class="kr">public</span><span class="o">:</span>
  <span class="nx">PiWorker</span><span class="p">(</span><span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">points</span><span class="p">)</span>
    <span class="o">:</span> <span class="nx">NanAsyncWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">),</span> <span class="nx">points</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="nx">PiWorker</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">//这个函数运行在工作线程，而不是v8线程，所以不能访问v8的数据</span>
  <span class="k">void</span> <span class="nx">Execute</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">estimate</span> <span class="o">=</span> <span class="nx">Estimate</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//这个是libuv的回调函数，在这里可以使用v8的数据</span>
  <span class="k">void</span> <span class="nx">HandleOKCallback</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">NanScope</span><span class="p">();</span>

    <span class="nx">Local</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="nx">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">NanNull</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">Number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">estimate</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="nx">callback</span><span class="o">-&gt;</span><span class="nx">Call</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">argv</span><span class="p">);</span>
  <span class="p">};</span>

 <span class="kr">private</span><span class="o">:</span>
  <span class="kr">int</span> <span class="nx">points</span><span class="p">;</span>
  <span class="kr">double</span> <span class="nx">estimate</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Asynchronous access to the `Estimate()` function</span>
<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateAsync</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">NanScope</span><span class="p">();</span>

  <span class="kr">int</span> <span class="nx">points</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">Uint32Value</span><span class="p">();</span>
  <span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NanCallback</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">As</span><span class="o">&lt;</span><span class="nb">Function</span><span class="o">&gt;</span><span class="p">());</span>

  <span class="nx">NanAsyncQueueWorker</span><span class="p">(</span><span class="k">new</span> <span class="nx">PiWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">points</span><span class="p">));</span>
  <span class="nx">NanReturnUndefined</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码2.4 async.cc</strong><br><a href="http://git.oschina.net/yunnysunny/async-tutorial-code/tree/master/addon">这里</a>有一个利用<a href="https://github.com/nodejs/nan">nan</a>和node0.10/0.12来完成异步操作的对比。</p>
<p>这篇教程仅仅是一个入门操作，就讲到这里了，详细的使用请参考nan的readme文档。</p>
</div>

  <div class="comments">
    <a href="/posts/nan/#comments">
      <span class="icon-bubbles"></span>
      Comments
    </a>
  </div>

  <div class="post-head group">
  <a href="/posts/node0-12capi/">
    <h1 class="post-title">即将面临的Node0.12中的C++API的改变</h1>
  </a>
  <span class="post-date">2015 &#183; 5 &#183; 19</span>
</div>

<div class="post-body markdown"><p>原文地址：<a href="https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/">https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/</a></p>
<blockquote>
<p>编者注：欢迎阅读旨在帮你快速了解，在即将发布的node0.12中（ <em>作者写这篇文章的时候Node0.12还没有发布，译者注</em> ）的API变化三系列教程的第三部分。在<a href="http://strongloop.com/strongblog/node-js-v0-12-new-apis/">第一部分</a>，<a href="https://github.com/alexgorbatchev">Alex Gorbatchev</a>列出来没有变化的API，在<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">第二部分</a>中他指出了变化的部分。在第三部分，<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">Ben Noordhuis</a>将会详细描述C++API部分的差别。  </p>
</blockquote>
<p>在Node v0.10和v0.12之间有大量的差异。我不会试图把每一个细节都点出来，我将把这些差异分类，按照从“更重要”到“次重要”的次序进行排序，然后解释怎样合理的更新你的代码。<br>本文大部分讲述V8 API，因为这正是大量差异出现的地方。欢迎通过<a href="mailto:ben@strongloop.com">ben at strongloop.com</a>来给我提供建议和反馈。  </p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>原生函数的参数已经被更改</h2>
<p>在node v0.10中你这么写： </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Handle</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="n">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">Arguments</span><span class="o">&amp;</span><span class="n">args</span><span class="p">){</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">returnhandle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span><span class="n">info</span><span class="p">){</span>
      <span class="c1">// Don&#39;t need a HandleScope in this particular example.</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>一些重要的变化如下:  </p>
<ol>
<li>返回类型是<code>void</code>。</li>
<li>返回值通过<code>v8::ReturnValue::Set()</code>,<code>v8::ReturnValue::SetEmptyString()</code>,<code>v8::ReturnValue::SetNull()</code>,<code>v8::ReturnValue::SetUndefined()</code>来设置。</li>
<li>如果没有显式的设置返回值，将会返回<code>undefined</code>。</li>
</ol>
<p><code>v8::ReturnValue::Set()</code>拥有一个数字类型的重载函数可以是使用不同的数据类型。如果你的编译器处理时出现问题或者报歧义错误，那么就是使用<code>static_cast&lt;&gt;</code>来将参数转为支持的类型：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="c1">// error: call of overloaded &#39;Set(const int64_t&amp;)&#39; is ambiguous</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="c1">// but this works</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="c1">// as does this</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>当然你需要挑选合适的类型来转换。当转化为窄数据类型，以至于无法承载原始数据据时，将会产生不可预期的结果。<br>注意，<code>v8::FunctionCallbackInfo&lt;v8::Value&gt;</code>是对于<code>v8::Arguments</code>的重命名和参数化（parameterized ）。除了名字和额外的<code>GetReturnValue()</code>函数，他们没有表面上的差别。</p>
<h2><a name="v8-apiv8isolate" class="anchor" href="#v8-apiv8isolate"><span class="header-link"></span></a>大部分V8 API现在需要使用v8::Isolate*</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>你可以通过若干的方法获取当前的<code>v8::Isolate</code>的指针：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">;</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or even:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">::</span><span class="n">GetCurrent</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>注意，V8团队已经指出，<code>v8::Isolate::GetCurrent()</code>将会被逐步淘汰。如果你想编写向后兼容的代码，你最好显式的传递isolate参数。</p>
<h2><a name="v8-string" class="anchor" href="#v8-string"><span class="header-link"></span></a>V8 string函数现在需要显式声明编码</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromTwoByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">chars</span><span class="p">);</span>
    <span class="c1">// create a ISO-8859-1 a.k.a. Latin1 string</span>
    <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">octets</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">latin1</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromOneByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">octets</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><code>v8::String::NewFromTwoByte()</code>稍微有点命名的不合适，因为他并不是一个严格的双字节编码。他能够识别surrogate pairs【 链接：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx</a> 】， 所以它应该被称作<a href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>，而不是<a href="https://zh.wikipedia.org/wiki/Universal_Character_Set">UCS-2</a>。</p>
<h2><a name="v8stringnewsymbolv8stringnewundetectable" class="anchor" href="#v8stringnewsymbolv8stringnewundetectable"><span class="header-link"></span></a>去除了v8::String::NewSymbol()和v8::String::NewUndetectable()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewSymbol</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewUndetectable</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kInternalizedString</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kUndetectableString</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="v8stringasciivalue" class="anchor" href="#v8stringasciivalue"><span class="header-link"></span></a>去除了v8::String::AsciiValue</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">AsciiValue</span> <span class="n">s</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：
Nothing! <code>v8::String::AsciiValue</code>本来就有问题：它的名字告诉大家要返回7比特的ASCII数据，但是实际上返回8比特的二进制数据。同时它搞混了多字节字符的字节序。<br>使用<code>v8::String::Utf8Value</code>或者<code>v8::String::Value</code>(适用于UTF-16)来进行替代。如果你想获取一个字符串的原始二进制数据，你可以这么做：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">string</span><span class="o">-&gt;</span><span class="n">Utf8Length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Add one for trailing zero byte.</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">string</span><span class="o">-&gt;</span><span class="n">WriteOneByte</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="cm">/* start */</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>注意：<code>v8::String::Utf8Length()</code>会迭代字符串中的每一个字符，这就是为啥对于大字符串来说会(很)慢的原因。</p>
<h2><a name="v8handlescopeclose" class="anchor" href="#v8handlescopeclose"><span class="header-link"></span></a>去除了v8::HandleScope::Close()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">EscapableHandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Escape</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8persistenttv8handlet" class="anchor" href="#v8persistenttv8handlet"><span class="header-link"></span></a>v8::Persistent<T>不再继承自v8::Handle<T></h2>
<p><code>v8::Persistent&lt;T&gt;</code>不再是<code>v8::Handle&lt;T&gt;</code>类型的对象。这就意味着，你不能在直接访问指向的句柄了。做出如此大变革的动机是由于在v0.10中这么操作太容易导致资源泄露或者导致在释放之后再访问其存储的内容。<br>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span> <span class="o">*</span><span class="n">persistent</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">persistent</span><span class="p">);</span>  <span class="c1">// rematerialize handle</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>另外一个变化是，persistent 句柄现在不能被拷贝。在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a and b now point to |value|</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>由于<code>v8::Persistent&lt;T&gt;</code>没有在语法上提供拷贝功能，所以现在使用STL容器类的时候会更困难。鉴于此，V8在<code>v8-util.h</code>中提供了若干工具类。</p>
<p>举个例子：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="err">#</span><span class="n">include</span> <span class="s">&quot;v8-util.h&quot;</span>

    <span class="kt">void</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">:</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">StdPersistentValueMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;fortytwo&quot;</span><span class="p">);</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">StrictEquals</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">21</span><span class="p">).</span><span class="n">IsEmpty</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>  <span class="c1">// or we could just call .Clear()</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>如果你使用<code>[C++](https://zh.wikipedia.org/wiki/CBB11 &quot;%3&quot;)</code>,你可以在标准容器类的<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">移动语义</a>中使用<code>v8::UniquePersistent&lt;T&gt;</code>。<br>或者，你可以通过具有拷贝特性的<code>v8::Persistent&lt;T&gt;</code>,但是要保证这么做不会导致资源泄露或者在释放后再使用的问题：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">CopyablePersistentTraits</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">CopyablePersistent</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="persistent" class="anchor" href="#persistent"><span class="header-link"></span></a>弱引用persistent句柄的回调函数参数更改</h2>
<p>一个正常的persistent句柄会被垃圾回收器忽略掉，一直到程序手动释放才会被回收。<br>相反，弱引用persistent句柄会被垃圾回收器跟踪，当需要回收时，回收器会通过回调函数通知程序。接着程序释放掉关联的资源或者复用这个句柄如果对象还要在后续使用的话。<br>在Node v0.10中这么写：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
      <span class="n">object</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>  <span class="c1">// or .ClearWeak() if you want to keep it around</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">();</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span>
          <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">MakeWeak</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">),</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">WeakCallbackData</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">());</span>
      <span class="c1">//persistent的存储单元将会自动清除。</span>
      <span class="c1">//如果你想保持对原始v8::Persistent&lt;T&gt;的引用，你可以使用.ClearWeak()来复用它。</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">SetWeak</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">,</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8throwexception-v8isolatethrowexception" class="anchor" href="#v8throwexception-v8isolatethrowexception"><span class="header-link"></span></a>v8::ThrowException()现在变成了 v8::Isolate::ThrowException()</h2>
<p>在Node v0.10中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">isolate</span><span class="o">-&gt;</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
</div>

  <div class="comments">
    <a href="/posts/node0-12capi/#comments">
      <span class="icon-bubbles"></span>
      Comments
    </a>
  </div>


<div class="pagination group">
  
    
    
  
    
    
      <a href="/page/1/" class="older"> &#8592; Older</a>
    
  
    
    
  
    
    
  
</div>
    </div>
    <script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="/scripts/main.js" type="text/javascript"></script>
    <script  type="text/javascript">
      var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F628c040f31bc950845419d51d5cbebeb' type='text/javascript'%3E%3C/script%3E"));
    </script>
  </body>
</html>

