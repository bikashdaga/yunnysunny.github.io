<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="icon" type="image/png" href="/images/cabin.png" >
    <link href="/styles/main.css" rel="stylesheet">
    
    <title>白一梓的博客</title>
    
    
	<style type="text/css">

	.social-media a.qq {
		background-position: 0 0;
	}
	
	.social-media a.sina {
		background-position: -39px 0;
		width: 22px;
	}
	.social-media a.qq:hover {
		background-position: 0 -28px;
	}
	.social-media a.sina:hover {
		background-position: -39px -28px;
		width: 22px;
	}
	.social-media a {
		background: rgba(0, 0, 0, 0) url("/images/sns.png") no-repeat scroll 0 0;
		display: inline-block;
		float: left;
		height: 20px;
		margin: 10px 5px;
		width: 20px;
	}	
	</style>
	<link title="白一梓的博文" href="/feed.xml" rel="alternate" type="application/rss+xml" />
  </head>
  <body>
    <nav>
      <h1 class="name">
        <a href="/">白一梓</a>
      </h1>
      <div class="menu icon-menu"></div>
      <ul class="nav-links">
        <li class="text-link">
          <a href="/about.html">关于</a>
        </li>
        <li class="text-link">
          <a href="/projects.html">项目</a>
        </li>
        <li class="text-link">
          <a href="/archives.html">文章</a>
        </li>
      </ul>
      <div class="social-media">
		<a title="我的腾讯微博" class="qq" href="http://t.qq.com/baiyizi" target="_blank"></a>
		<a title="我的新浪微博" class="sina" href="http://weibo.com/1261004702" target="_blank"></a>        
      </div>
    </nav>
    <div class="content">


  <div class="post-head group">
  <a href="/posts/node0-12capi/">
    <h1 class="post-title">即将面临的Node0.12中的C++API的改变</h1>
  </a>
  <span class="post-date">2015 &#183; 5 &#183; 19</span>
</div>

<div class="post-body markdown"><p>原文地址：<a href="https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/">https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/</a></p>
<blockquote>
<p>编者注：欢迎阅读旨在帮你快速了解，在即将发布的node0.12中（ <em>作者写这篇文章的时候Node0.12还没有发布，译者注</em> ）的API变化三系列教程的第三部分。在<a href="http://strongloop.com/strongblog/node-js-v0-12-new-apis/">第一部分</a>，<a href="https://github.com/alexgorbatchev">Alex Gorbatchev</a>列出来没有变化的API，在<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">第二部分</a>中他指出了变化的部分。在第三部分，<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">Ben Noordhuis</a>将会详细描述C++API部分的差别。  </p>
</blockquote>
<p>在Node v0.10和v0.12之间有大量的差异。我不会试图把每一个细节都点出来，我将把这些差异分类，按照从“更重要”到“次重要”的次序进行排序，然后解释怎样合理的更新你的代码。<br>本文大部分讲述V8 API，因为这正是大量差异出现的地方。欢迎通过<a href="mailto:ben@strongloop.com">ben at strongloop.com</a>来给我提供建议和反馈。  </p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>原生函数的参数已经被更改</h2>
<p>在node v0.10中你这么写： </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Handle</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="n">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">Arguments</span><span class="o">&amp;</span><span class="n">args</span><span class="p">){</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">returnhandle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span><span class="n">info</span><span class="p">){</span>
      <span class="c1">// Don&#39;t need a HandleScope in this particular example.</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>一些重要的变化如下:  </p>
<ol>
<li>返回类型是<code>void</code>。</li>
<li>返回值通过<code>v8::ReturnValue::Set()</code>,<code>v8::ReturnValue::SetEmptyString()</code>,<code>v8::ReturnValue::SetNull()</code>,<code>v8::ReturnValue::SetUndefined()</code>来设置。</li>
<li>如果没有显式的设置返回值，将会返回<code>undefined</code>。</li>
</ol>
<p><code>v8::ReturnValue::Set()</code>拥有一个数字类型的重载函数可以是使用不同的数据类型。如果你的编译器处理时出现问题或者报歧义错误，那么就是使用<code>static_cast&lt;&gt;</code>来将参数转为支持的类型：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="c1">// error: call of overloaded &#39;Set(const int64_t&amp;)&#39; is ambiguous</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="c1">// but this works</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="c1">// as does this</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>当然你需要挑选合适的类型来转换。当转化为窄数据类型，以至于无法承载原始数据据时，将会产生不可预期的结果。<br>注意，<code>v8::FunctionCallbackInfo&lt;v8::Value&gt;</code>是对于<code>v8::Arguments</code>的重命名和参数化（parameterized ）。除了名字和额外的<code>GetReturnValue()</code>函数，他们没有表面上的差别。</p>
<h2><a name="v8-apiv8isolate" class="anchor" href="#v8-apiv8isolate"><span class="header-link"></span></a>大部分V8 API现在需要使用v8::Isolate*</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>你可以通过若干的方法获取当前的<code>v8::Isolate</code>的指针：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">;</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or even:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">::</span><span class="n">GetCurrent</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>注意，V8团队已经指出，<code>v8::Isolate::GetCurrent()</code>将会被逐步淘汰。如果你想编写向后兼容的代码，你最好显式的传递isolate参数。</p>
<h2><a name="v8-string" class="anchor" href="#v8-string"><span class="header-link"></span></a>V8 string函数现在需要显式声明编码</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromTwoByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">chars</span><span class="p">);</span>
    <span class="c1">// create a ISO-8859-1 a.k.a. Latin1 string</span>
    <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">octets</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">latin1</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromOneByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">octets</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><code>v8::String::NewFromTwoByte()</code>稍微有点命名的不合适，因为他并不是一个严格的双字节编码。他能够识别surrogate pairs【 链接：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx</a> 】， 所以它应该被称作<a href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>，而不是<a href="https://zh.wikipedia.org/wiki/Universal_Character_Set">UCS-2</a>。</p>
<h2><a name="v8stringnewsymbolv8stringnewundetectable" class="anchor" href="#v8stringnewsymbolv8stringnewundetectable"><span class="header-link"></span></a>去除了v8::String::NewSymbol()和v8::String::NewUndetectable()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewSymbol</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewUndetectable</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kInternalizedString</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kUndetectableString</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="v8stringasciivalue" class="anchor" href="#v8stringasciivalue"><span class="header-link"></span></a>去除了v8::String::AsciiValue</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">AsciiValue</span> <span class="n">s</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：
Nothing! <code>v8::String::AsciiValue</code>本来就有问题：它的名字告诉大家要返回7比特的ASCII数据，但是实际上返回8比特的二进制数据。同时它搞混了多字节字符的字节序。<br>使用<code>v8::String::Utf8Value</code>或者<code>v8::String::Value</code>(适用于UTF-16)来进行替代。如果你想获取一个字符串的原始二进制数据，你可以这么做：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">string</span><span class="o">-&gt;</span><span class="n">Utf8Length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Add one for trailing zero byte.</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">string</span><span class="o">-&gt;</span><span class="n">WriteOneByte</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="cm">/* start */</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>注意：<code>v8::String::Utf8Length()</code>会迭代字符串中的每一个字符，这就是为啥对于大字符串来说会(很)慢的原因。</p>
<h2><a name="v8handlescopeclose" class="anchor" href="#v8handlescopeclose"><span class="header-link"></span></a>去除了v8::HandleScope::Close()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">EscapableHandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Escape</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8persistenttv8handlet" class="anchor" href="#v8persistenttv8handlet"><span class="header-link"></span></a>v8::Persistent<T>不再继承自v8::Handle<T></h2>
<p><code>v8::Persistent&lt;T&gt;</code>不再是<code>v8::Handle&lt;T&gt;</code>类型的对象。这就意味着，你不能在直接访问指向的句柄了。做出如此大变革的动机是由于在v0.10中这么操作太容易导致资源泄露或者导致在释放之后再访问其存储的内容。<br>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span> <span class="o">*</span><span class="n">persistent</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">persistent</span><span class="p">);</span>  <span class="c1">// rematerialize handle</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>另外一个变化是，persistent 句柄现在不能被拷贝。在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a and b now point to |value|</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>由于<code>v8::Persistent&lt;T&gt;</code>没有在语法上提供拷贝功能，所以现在使用STL容器类的时候会更困难。鉴于此，V8在<code>v8-util.h</code>中提供了若干工具类。</p>
<p>举个例子：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="err">#</span><span class="n">include</span> <span class="s">&quot;v8-util.h&quot;</span>

    <span class="kt">void</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">:</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">StdPersistentValueMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;fortytwo&quot;</span><span class="p">);</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">StrictEquals</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">21</span><span class="p">).</span><span class="n">IsEmpty</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>  <span class="c1">// or we could just call .Clear()</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>如果你使用<code>[C++](https://zh.wikipedia.org/wiki/CBB11 &quot;%3&quot;)</code>,你可以在标准容器类的<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">移动语义</a>中使用<code>v8::UniquePersistent&lt;T&gt;</code>。<br>或者，你可以通过具有拷贝特性的<code>v8::Persistent&lt;T&gt;</code>,但是要保证这么做不会导致资源泄露或者在释放后再使用的问题：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">CopyablePersistentTraits</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">CopyablePersistent</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="persistent" class="anchor" href="#persistent"><span class="header-link"></span></a>弱引用persistent句柄的回调函数参数更改</h2>
<p>一个正常的persistent句柄会被垃圾回收器忽略掉，一直到程序手动释放才会被回收。<br>相反，弱引用persistent句柄会被垃圾回收器跟踪，当需要回收时，回收器会通过回调函数通知程序。接着程序释放掉关联的资源或者复用这个句柄如果对象还要在后续使用的话。<br>在Node v0.10中这么写：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
      <span class="n">object</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>  <span class="c1">// or .ClearWeak() if you want to keep it around</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">();</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span>
          <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">MakeWeak</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">),</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">WeakCallbackData</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">());</span>
      <span class="c1">//persistent的存储单元将会自动清除。</span>
      <span class="c1">//如果你想保持对原始v8::Persistent&lt;T&gt;的引用，你可以使用.ClearWeak()来复用它。</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">SetWeak</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">,</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8throwexception-v8isolatethrowexception" class="anchor" href="#v8throwexception-v8isolatethrowexception"><span class="header-link"></span></a>v8::ThrowException()现在变成了 v8::Isolate::ThrowException()</h2>
<p>在Node v0.10中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">isolate</span><span class="o">-&gt;</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
</div>

  <div class="comments">
    <a href="/posts/node0-12capi/#comments">
      <span class="icon-bubbles"></span>
      Comments
    </a>
  </div>

  <div class="post-head group">
  <a href="/posts/js/">
    <h1 class="post-title">js异步之惑</h1>
  </a>
  <span class="post-date">2015 &#183; 3 &#183; 20</span>
</div>

<div class="post-body markdown"><h2><a name="1" class="anchor" href="#1"><span class="header-link"></span></a>1.异步是啥</h2>
<p>与异步对应的就是同步，对于同步我们很好理解，就是代码顺序执行。但是一到异步代码，很多人多少有些理不清。异步，从功能上讲，就是在背后偷偷的执行，不堵塞当前运行的代码；从实现上讲，能够这么做的，就只能靠在当前运行代码中另一起线程或者进程了。举一个使用线程来实现异步的例子：</p>
<pre><code><div class="highlight"><pre><span class="kr">public</span> <span class="kr">class</span> <span class="nx">MyAsync</span> <span class="kr">extends</span> <span class="nx">Thread</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="kr">volatile</span> <span class="kr">boolean</span> <span class="nx">done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

    <span class="kr">public</span> <span class="k">void</span> <span class="nx">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span><span class="c1">//子线程中的循环</span>
            <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;thread out x&quot;</span><span class="p">);</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nx">Thread</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">InterruptedException</span> <span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">e</span><span class="p">.</span><span class="nx">printStackTrace</span><span class="p">();</span>
<span class="c1">//                Thread.currentThread().interrupt();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="kr">synchronized</span> <span class="k">void</span> <span class="nx">setDone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="kr">static</span> <span class="k">void</span> <span class="nx">main</span><span class="p">(</span><span class="nb">String</span> <span class="nx">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="nx">MyAsync</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyAsync</span><span class="p">();</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="c1">//起子线程</span>
        <span class="kr">long</span> <span class="nx">last</span> <span class="o">=</span> <span class="nx">System</span><span class="p">.</span><span class="nx">currentTimeMillis</span><span class="p">();</span>
        <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span><span class="c1">//主线程中循环</span>
            <span class="kr">long</span> <span class="nx">now</span> <span class="o">=</span> <span class="nx">System</span><span class="p">.</span><span class="nx">currentTimeMillis</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">last</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
                <span class="nx">count</span> <span class="o">++</span><span class="p">;</span>
                <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;the &quot;</span> <span class="o">+</span> <span class="nx">count</span> <span class="o">+</span> <span class="s2">&quot;th count.&quot;</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="p">}</span>

        <span class="nx">t</span><span class="p">.</span><span class="nx">setDone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码1.1 线程示例</strong><br>对于代码1.1的运行结果，有可能是这个样子的：  </p>
<pre><code><div class="highlight"><pre><span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
</pre></div>
</code></pre>
<p>代码27-38行起是主线程循环，7-15行是子线程循环，你多运行几次，就可以看出两个循环的输出是很随机的，但是不管运行多少次两个循环的输出都是交叉在一起的。这样我们就可以推断出，运行主线程的代码的时候，子线程的代码也在背后偷偷的运行，说白了两者是并行运行的。</p>
<h2><a name="2-js" class="anchor" href="#2-js"><span class="header-link"></span></a>2.js中的异步</h2>
<p>就是因为异步这个特性，js如今被大家推崇，下面用一个小例子来演示一下js中异步的使用：  </p>
<pre><code><div class="highlight"><pre><span class="kd">function</span> <span class="nx">synchronizedCode</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">last</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
            <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;the %dth count.&#39;</span><span class="p">,</span><span class="nx">count</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;exist while.&#39;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>
</pre></div>
</code></pre>
<p><strong>代码2.1 setTimeout的例子</strong><br>我们运行代码2.1，然后不管运行多少次，输出都是这个样子的：</p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
</pre></div>
</code></pre>
<p><strong>输出2.1</strong><br>跟java中的异步和同步代码会交叉输出相比，js中的异步其实是排好队输出的。由于js是单线程执行代码的，所以没有那种交叉输出的效果。那么还有一个问题，while循环明明运行了5秒钟，为何在这期间那两个setTimeout一直没有运行呢？这就和js代码的异步机制有关了。js代码中有帧的概念，对于同步代码是在当前帧运行的，异步代码是在下一帧运行的。对于代码2.1我们给代码运行画一幅图的话，应该是这样的：<br><img src="http://blog.whyun.com/images/js_frame.png" alt="js帧结构"><br><strong>图2.1 js帧结构</strong><br>那么为什么是第一个setTimeout先触发，第二个后触发呢，难道仅仅由于先后顺序？我们把第一个setTimeout改为<code>setTimeout(function() {console.log(&#39;setTimeout 0 occured first.&#39;);},100);</code>,那么输出的时候就会是先输出<code>setTimeout 0 occured second.</code>,在输出<code>setTimeout 0 occured first.</code>。也就是说在第二帧setTimeout的回调的执行顺序不仅与代码顺序有关还和延迟时间有关。<br>在node.js中还有一个特殊的API，就是<code>process.nextTick</code>,虽然已经不推荐使用了，但是已经可以在很多代码中看到它的身影。例如如下代码：</p>
<pre><code><div class="highlight"><pre><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>
</pre></div>
</code></pre>
<p><strong>代码2.2</strong><br>运行后输出：</p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>  
</pre></div>
</code></pre>
<p><strong>输出2.2</strong><br>之所以nextTick排在所有异步的最前面，是由于nextTick是在第一帧运行的，而其他的都是在第二帧运行的。也就是说代码运行情况是这个样子的：<br><img src="http://blog.whyun.com/images/js_frame2.png" alt=""><br><strong>图2.2 js帧结构</strong><br>接下来再举几个异步API的例子，这次我们添加<code>setImmediate</code>和<code>mkdir</code>两个函数：</p>
<pre><code><div class="highlight"><pre><span class="kd">var</span> <span class="nx">synchronizedCode</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./sync&#39;</span><span class="p">);</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>
    <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setImmediate occured.&#39;</span><span class="p">)});</span>

    <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">rand</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">pseudoRandomBytes</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">mkdir</span><span class="p">(</span><span class="s1">&#39;d:\\temp\\xx&#39;</span><span class="o">+</span><span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="nx">rand</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="s1">&#39;错误&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">.</span><span class="nx">code</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create directory success.&#39;</span><span class="p">);</span>
        <span class="p">}</span>        
    <span class="p">});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>  
</pre></div>
</code></pre>
<p><strong>代码2.3</strong><br>那么他的输出就应该是这样的：  </p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
<span class="nx">setImmediate</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">create</span> <span class="nx">directory</span> <span class="nx">success</span><span class="p">.</span>  
</pre></div>
</code></pre>
<p><strong>输出2.3</strong></p>
<p>等等，问题来了，这里最后一句才打印<code>create directory success</code>,那么是不是程序是在最后一步才创建的文件夹呢，如果真是这样，就有点低效了，起码这个创建文件的工作被那个while循环给延迟了得有5秒钟。不过幸好，这个想法是错误的！node.js中使用libuv来IO或者CPU计算量大的操作，而在libuv中处理这些耗时的操作都是用线程来解决，以避免堵塞住js线程（这一点和android的程序设计思路类似，android开发中使用子线程来处理耗时逻辑，避免对主线程造成卡顿）。这里我们来演示一个libuv的异步处理，在异步处理中模拟一个耗时操作：</p>
<pre><code><div class="highlight"><pre><span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">v8</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>

<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">windows</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="nx">typedef</span> <span class="nx">DWORD</span> <span class="nx">ThreadId</span><span class="p">;</span>
<span class="err">#</span><span class="k">else</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">unistd</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">pthread</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="nx">typedef</span> <span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">ThreadId</span><span class="p">;</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="nx">using</span> <span class="nx">namespace</span> <span class="nx">v8</span><span class="p">;</span>

<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">);</span>


<span class="kr">static</span> <span class="nx">ThreadId</span> <span class="nx">__getThreadId</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ThreadId</span> <span class="nx">nThreadID</span><span class="p">;</span>
<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>

    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="nx">GetCurrentProcessId</span><span class="p">();</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nThreadID</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="nx">GetCurrentThreadId</span><span class="p">();</span>
<span class="err">#</span><span class="k">else</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="nx">getpid</span><span class="p">();</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nThreadID</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pthread_self</span><span class="p">();</span>
<span class="err">#</span><span class="nx">endif</span>
    <span class="k">return</span> <span class="nx">nThreadID</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">static</span> <span class="k">void</span> <span class="nx">__tsleep</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">millisecond</span><span class="p">)</span> <span class="p">{</span>
<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>
    <span class="o">::</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">millisecond</span><span class="p">);</span>
<span class="err">#</span><span class="k">else</span>
    <span class="nx">usleep</span><span class="p">(</span><span class="nx">millisecond</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="p">}</span>


<span class="kr">class</span> <span class="nx">ThreadWoker</span> <span class="o">:</span> <span class="kr">public</span> <span class="nx">NanAsyncWorker</span> <span class="p">{</span>
    <span class="kr">private</span><span class="o">:</span>
        <span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span><span class="p">;</span>
    <span class="kr">public</span><span class="o">:</span>
        <span class="nx">ThreadWoker</span><span class="p">(</span><span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span><span class="p">,</span><span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span><span class="p">)</span>
            <span class="o">:</span> <span class="nx">NanAsyncWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">),</span> <span class="nx">str</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{}</span>
        <span class="o">~</span><span class="nx">ThreadWoker</span><span class="p">()</span> <span class="p">{}</span>
        <span class="c1">//在该函数内模拟处理过程 ，如i/o阻塞或者cpu高消耗情形的处理。</span>
        <span class="c1">// 注意不能使用v8 api,这个线程不是在js主线程内</span>
        <span class="k">void</span> <span class="nx">Execute</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;\n%s Thread id : gettid() == %d\n&quot;</span><span class="p">,</span><span class="nx">__FUNCTION__</span><span class="p">,</span><span class="nx">__getThreadId</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">__tsleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
                <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;sleep 1 seconds in uv_work\n&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">void</span> <span class="nx">HandleOKCallback</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">NanScope</span><span class="p">();</span>

            <span class="nx">Local</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="nx">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nx">NanNull</span><span class="p">(),</span>
                <span class="nx">NanNew</span><span class="p">(</span><span class="s2">&quot;the result:&quot;</span><span class="o">+</span><span class="nx">str</span><span class="p">)</span>
            <span class="p">};</span>

            <span class="nx">callback</span><span class="o">-&gt;</span><span class="nx">Call</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">argv</span><span class="p">);</span>
        <span class="p">};</span>
<span class="p">};</span>


<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;\n%s Thread id : gettid() == %d\n&quot;</span><span class="p">,</span><span class="nx">__FUNCTION__</span><span class="p">,</span><span class="nx">__getThreadId</span><span class="p">());</span>
    <span class="nx">NanScope</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> 
        <span class="nx">NanThrowError</span><span class="p">(</span><span class="s2">&quot;Wrong number of arguments&quot;</span><span class="p">);</span> 
        <span class="nx">NanReturnUndefined</span><span class="p">();</span> 
    <span class="p">}</span>


    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">IsString</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">IsFunction</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">NanThrowError</span><span class="p">(</span><span class="s2">&quot;Wrong number of arguments&quot;</span><span class="p">);</span>
        <span class="nx">NanReturnUndefined</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 强制转换成函数变量</span>
    <span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NanCallback</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">As</span><span class="o">&lt;</span><span class="nb">Function</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nx">NanUtf8String</span> <span class="nx">param1</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">std</span><span class="o">::</span><span class="nx">string</span><span class="p">(</span><span class="o">*</span><span class="nx">param1</span><span class="p">);</span> 
    <span class="nx">NanAsyncQueueWorker</span><span class="p">(</span><span class="k">new</span> <span class="nx">ThreadWoker</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">str</span><span class="p">));</span>
    <span class="nx">NanReturnUndefined</span><span class="p">();</span> 
<span class="p">}</span>

<span class="k">void</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">Handle</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">exports</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;async_hello&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">NODE_MODULE</span><span class="p">(</span><span class="nx">binding</span><span class="p">,</span> <span class="nx">Init</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><strong>代码2.4</strong>  </p>
<blockquote>
<p>上述代码的编译参照<a href="http://git.oschina.net/yunnysunny/async-tutorial-code/blob/master/addon/readme.md">编译说明</a>，项目源码地址参加第3节。关于nan的使用，可以参照我的另一篇教程<a href="http://blog.whyun.com/posts/nan/">《nan基础教程》</a>。</p>
</blockquote>
<p>编写的测试代码，将其运行，就可以看出函数<code>Execute</code>根本就不在js线程中执行，也就是说它是可以和js线程并行的；函数<code>HandleOKCallback</code>中能够触发js中的回调函数，将处理完的结果交给js。下面就编译上面代码（需要node-gyp支持，执行<code>node-gpy rebuild</code>进行编译），来验证上述结论：  </p>
<pre><code><div class="highlight"><pre><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">synchronizedCode</span><span class="p">(</span><span class="s1">&#39;timer1&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>

    <span class="kd">var</span> <span class="nx">addon</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./addon/build/Release/binding&#39;</span><span class="p">);</span>
    <span class="nx">addon</span><span class="p">.</span><span class="nx">async_hello</span><span class="p">(</span><span class="s2">&quot;good&quot;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;node addon result&#39;</span><span class="p">,</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setImmediate occured.&#39;</span><span class="p">)});</span>

    <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">rand</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">pseudoRandomBytes</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">mkdir</span><span class="p">(</span><span class="s1">&#39;d:\\temp\\xx&#39;</span><span class="o">+</span><span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="nx">rand</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="s1">&#39;错误&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">.</span><span class="nx">code</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create directory success.&#39;</span><span class="p">);</span>
        <span class="p">}</span>        
    <span class="p">});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>  
</pre></div>
</code></pre>
<p><strong>代码2.5</strong><br>我们在代码2.5中引入了代码2.4中的c++扩展，其输出内容如下</p>
<pre><code><div class="highlight"><pre><span class="nx">async_hello</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284953360</span>

<span class="nx">call_work</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284958096</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">exist</span> <span class="k">while</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
<span class="nx">setImmediate</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">create</span> <span class="nx">directory</span> <span class="nx">success</span><span class="p">.</span>

<span class="nx">call_work_after</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284953360</span>
<span class="nx">node</span> <span class="nx">addon</span> <span class="nx">result</span> <span class="nx">good</span><span class="o">---&gt;</span><span class="nx">hello</span> <span class="nx">world</span> <span class="nx">from</span> <span class="nx">c</span><span class="o">++</span>
</pre></div>
</code></pre>
<p><strong>输出2.5</strong><br>我们终于看到开篇提到的类似java代码的交叉输出的效果了。libuv在处理任务时根本就和js不在一个线程中，所以才出现了libuv线程和js线程交叉输出的效果。我们在梳理一下代码2.5的异步流程，那么可以用下面这个图来展示出来：<br><img src="http://blog.whyun.com/images/js_frame3.png" alt=""><br><strong>图2.3</strong><br>在node中维护了一个回调的队列，那为什么调用插件的回调排在队列的最后面呢，是有于我们在代码2.4中故意将其代码设置成15秒之后才执行完成，这要远远长于其他的那些回调，所以它只能被追加到回调队列的最后一位。在第二帧中，node中的事件轮询依次将这些回调队列中的任务取出来，进行触发调用。可以看出回调队列是个先进先出的结构。注意回调是按照队列中排队顺序执行的，同时它们执行的环境是js线程，要知道js线程可是个单线程，也就是说一旦某个回调中的同步代码耗时比较长，那么它后面的回调任务就得一直等着它运行完成，所以说一定不要在回调中写特别耗时的同步代码。</p>
<h2><a name="3" class="anchor" href="#3"><span class="header-link"></span></a>3. 代码</h2>
<p>本文用到代码发布在<a href="http://git.oschina.net/yunnysunny/async-tutorial-code"><a href="http://git.oschina.net/yunnysunny/async-tutorial-code">http://git.oschina.net/yunnysunny/async-tutorial-code</a></a></p>
</div>

  <div class="comments">
    <a href="/posts/js/#comments">
      <span class="icon-bubbles"></span>
      Comments
    </a>
  </div>


<div class="pagination group">
  
    
    
      <a href="/" class="newer"> Newer &#8594;</a>
    
  
    
    
  
    
    
      <a href="/page/2/" class="older"> &#8592; Older</a>
    
  
    
    
  
    
    
  
</div>
    </div>
    <script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="/scripts/main.js" type="text/javascript"></script>
    <script  type="text/javascript">
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?628c040f31bc950845419d51d5cbebeb";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
    </script>
  </body>
</html>

