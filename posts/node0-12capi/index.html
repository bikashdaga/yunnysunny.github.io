
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="icon" type="image/png" href="/images/cabin.png" >
    <link href="/styles/main.css" rel="stylesheet">
    
    <title>即将面临的Node0.12中的C++API的改变</title>
    
    
    <meta name="description" content="Node0.12和Node0.10的C++API方面发生了重大变化，nodejs官方文档中给出仅仅是几个简单例子，在具体使用过程中依靠这几个例子是不够的，当初在将Node0.10的扩展迁移到Node0.12时遇到了各种问题，直到遇到了这篇文章，我想我不得不将它翻译出来共享给大家了">
    
	<style type="text/css">

	.social-media a.qq {
		background-position: 0 0;
	}
	
	.social-media a.sina {
		background-position: -39px 0;
		width: 22px;
	}
	.social-media a.qq:hover {
		background-position: 0 -28px;
	}
	.social-media a.sina:hover {
		background-position: -39px -28px;
		width: 22px;
	}
	.social-media a {
		background: rgba(0, 0, 0, 0) url("/images/sns.png") no-repeat scroll 0 0;
		display: inline-block;
		float: left;
		height: 20px;
		margin: 10px 5px;
		width: 20px;
	}	
	</style>
	<link title="白一梓的博文" href="/feed.xml" rel="alternate" type="application/rss+xml" />
  </head>
  <body>
    <nav>
      <h1 class="name">
        <a href="/">白一梓</a>
      </h1>
      <div class="menu icon-menu"></div>
      <ul class="nav-links">
        <li class="text-link">
          <a href="/about.html">关于</a>
        </li>
        <li class="text-link">
          <a href="/projects.html">项目</a>
        </li>
        <li class="text-link">
          <a href="/archives.html">文章</a>
        </li>
      </ul>
      <div class="social-media">
		<a title="我的腾讯微博" class="qq" href="http://t.qq.com/baiyizi" target="_blank"></a>
		<a title="我的新浪微博" class="sina" href="http://weibo.com/1261004702" target="_blank"></a>        
      </div>
    </nav>
    <div class="content">

<div class="post-head group">
  <a href="/posts/node0-12capi/">
    <h1 class="post-title">即将面临的Node0.12中的C++API的改变</h1>
  </a>
  <span class="post-date">2015 &#183; 5 &#183; 19</span>
</div>

<div class="post-body markdown"><p>原文地址：<a href="https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/">https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/</a></p>
<blockquote>
<p>编者注：欢迎阅读旨在帮你快速了解，在即将发布的node0.12中（ <em>作者写这篇文章的时候Node0.12还没有发布，译者注</em> ）的API变化三系列教程的第三部分。在<a href="http://strongloop.com/strongblog/node-js-v0-12-new-apis/">第一部分</a>，<a href="https://github.com/alexgorbatchev">Alex Gorbatchev</a>列出来没有变化的API，在<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">第二部分</a>中他指出了变化的部分。在第三部分，<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">Ben Noordhuis</a>将会详细描述C++API部分的差别。  </p>
</blockquote>
<p>在Node v0.10和v0.12之间有大量的差异。我不会试图把每一个细节都点出来，我将把这些差异分类，按照从“更重要”到“次重要”的次序进行排序，然后解释怎样合理的更新你的代码。<br>本文大部分讲述V8 API，因为这正是大量差异出现的地方。欢迎通过<a href="mailto:ben@strongloop.com">ben at strongloop.com</a>来给我提供建议和反馈。  </p>
<h2><a name="" class="anchor" href="#"><span class="header-link"></span></a>原生函数的参数已经被更改</h2>
<p>在node v0.10中你这么写： </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Handle</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="n">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">Arguments</span><span class="o">&amp;</span><span class="n">args</span><span class="p">){</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">returnhandle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span><span class="n">info</span><span class="p">){</span>
      <span class="c1">// Don&#39;t need a HandleScope in this particular example.</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>一些重要的变化如下:  </p>
<ol>
<li>返回类型是<code>void</code>。</li>
<li>返回值通过<code>v8::ReturnValue::Set()</code>,<code>v8::ReturnValue::SetEmptyString()</code>,<code>v8::ReturnValue::SetNull()</code>,<code>v8::ReturnValue::SetUndefined()</code>来设置。</li>
<li>如果没有显式的设置返回值，将会返回<code>undefined</code>。</li>
</ol>
<p><code>v8::ReturnValue::Set()</code>拥有一个数字类型的重载函数可以是使用不同的数据类型。如果你的编译器处理时出现问题或者报歧义错误，那么就是使用<code>static_cast&lt;&gt;</code>来将参数转为支持的类型：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
      <span class="c1">// error: call of overloaded &#39;Set(const int64_t&amp;)&#39; is ambiguous</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="c1">// but this works</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="c1">// as does this</span>
      <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>当然你需要挑选合适的类型来转换。当转化为窄数据类型，以至于无法承载原始数据据时，将会产生不可预期的结果。<br>注意，<code>v8::FunctionCallbackInfo&lt;v8::Value&gt;</code>是对于<code>v8::Arguments</code>的重命名和参数化（parameterized ）。除了名字和额外的<code>GetReturnValue()</code>函数，他们没有表面上的差别。</p>
<h2><a name="v8-apiv8isolate" class="anchor" href="#v8-apiv8isolate"><span class="header-link"></span></a>大部分V8 API现在需要使用v8::Isolate*</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Number</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mf">13.37</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionTemplate</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">Foo</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>你可以通过若干的方法获取当前的<code>v8::Isolate</code>的指针：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">FortyTwo</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">FunctionCallbackInfo</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">;</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">GetReturnValue</span><span class="p">().</span><span class="n">GetIsolate</span><span class="p">();</span>
      <span class="c1">// or even:</span>
      <span class="n">isolate</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">::</span><span class="n">GetCurrent</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>注意，V8团队已经指出，<code>v8::Isolate::GetCurrent()</code>将会被逐步淘汰。如果你想编写向后兼容的代码，你最好显式的传递isolate参数。</p>
<h2><a name="v8-string" class="anchor" href="#v8-string"><span class="header-link"></span></a>V8 string函数现在需要显式声明编码</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">chars</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="c1">// create a UTF-8 string</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf8</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="c1">// create a UTF-16 string from input in system endianness</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">utf16</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromTwoByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">chars</span><span class="p">);</span>
    <span class="c1">// create a ISO-8859-1 a.k.a. Latin1 string</span>
    <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">octets</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">latin1</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromOneByte</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">octets</span><span class="p">);</span>
</pre></div>
</code></pre>
<p><code>v8::String::NewFromTwoByte()</code>稍微有点命名的不合适，因为他并不是一个严格的双字节编码。他能够识别surrogate pairs【 链接：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx</a> 】， 所以它应该被称作<a href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>，而不是<a href="https://zh.wikipedia.org/wiki/Universal_Character_Set">UCS-2</a>。</p>
<h2><a name="v8stringnewsymbolv8stringnewundetectable" class="anchor" href="#v8stringnewsymbolv8stringnewundetectable"><span class="header-link"></span></a>去除了v8::String::NewSymbol()和v8::String::NewUndetectable()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewSymbol</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewUndetectable</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">symbol</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kInternalizedString</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">hidden</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;42&quot;</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">kUndetectableString</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="v8stringasciivalue" class="anchor" href="#v8stringasciivalue"><span class="header-link"></span></a>去除了v8::String::AsciiValue</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">AsciiValue</span> <span class="n">s</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：
Nothing! <code>v8::String::AsciiValue</code>本来就有问题：它的名字告诉大家要返回7比特的ASCII数据，但是实际上返回8比特的二进制数据。同时它搞混了多字节字符的字节序。<br>使用<code>v8::String::Utf8Value</code>或者<code>v8::String::Value</code>(适用于UTF-16)来进行替代。如果你想获取一个字符串的原始二进制数据，你可以这么做：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">string</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">string</span><span class="o">-&gt;</span><span class="n">Utf8Length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Add one for trailing zero byte.</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint8_t</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="n">string</span><span class="o">-&gt;</span><span class="n">WriteOneByte</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="cm">/* start */</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>注意：<code>v8::String::Utf8Length()</code>会迭代字符串中的每一个字符，这就是为啥对于大字符串来说会(很)慢的原因。</p>
<h2><a name="v8handlescopeclose" class="anchor" href="#v8handlescopeclose"><span class="header-link"></span></a>去除了v8::HandleScope::Close()</h2>
<p>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Close</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">EscapableHandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">handle_scope</span><span class="p">.</span><span class="n">Escape</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Integer</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="mi">42</span><span class="p">));</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8persistenttv8handlet" class="anchor" href="#v8persistenttv8handlet"><span class="header-link"></span></a>v8::Persistent<T>不再继承自v8::Handle<T></h2>
<p><code>v8::Persistent&lt;T&gt;</code>不再是<code>v8::Handle&lt;T&gt;</code>类型的对象。这就意味着，你不能在直接访问指向的句柄了。做出如此大变革的动机是由于在v0.10中这么操作太容易导致资源泄露或者导致在释放之后再访问其存储的内容。<br>在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span> <span class="o">*</span><span class="n">persistent</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value_again</span> <span class="o">=</span>
        <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">persistent</span><span class="p">);</span>  <span class="c1">// rematerialize handle</span>
    <span class="c1">// ...</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>另外一个变化是，persistent 句柄现在不能被拷贝。在Node v0.10中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// a and b now point to |value|</span>
</pre></div>
</code></pre>
<p>在Node v0.12中你这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="c1">// or:</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>由于<code>v8::Persistent&lt;T&gt;</code>没有在语法上提供拷贝功能，所以现在使用STL容器类的时候会更困难。鉴于此，V8在<code>v8-util.h</code>中提供了若干工具类。</p>
<p>举个例子：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="err">#</span><span class="n">include</span> <span class="s">&quot;v8-util.h&quot;</span>

    <span class="kt">void</span> <span class="n">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">:</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">StdPersistentValueMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">String</span><span class="o">::</span><span class="n">NewFromUtf8</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="s">&quot;fortytwo&quot;</span><span class="p">);</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">StrictEquals</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="mi">21</span><span class="p">).</span><span class="n">IsEmpty</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">Size</span><span class="p">());</span>
      <span class="n">map</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>  <span class="c1">// or we could just call .Clear()</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>如果你使用<code>[C++](https://zh.wikipedia.org/wiki/CBB11 &quot;%3&quot;)</code>,你可以在标准容器类的<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">移动语义</a>中使用<code>v8::UniquePersistent&lt;T&gt;</code>。<br>或者，你可以通过具有拷贝特性的<code>v8::Persistent&lt;T&gt;</code>,但是要保证这么做不会导致资源泄露或者在释放后再使用的问题：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">CopyablePersistentTraits</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;::</span><span class="n">CopyablePersistent</span> <span class="n">persistent</span><span class="p">;</span>
    <span class="n">persistent</span><span class="p">.</span><span class="n">Reset</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="cm">/* ... */</span><span class="p">);</span>
</pre></div>
</code></pre>
<h2><a name="persistent" class="anchor" href="#persistent"><span class="header-link"></span></a>弱引用persistent句柄的回调函数参数更改</h2>
<p>一个正常的persistent句柄会被垃圾回收器忽略掉，一直到程序手动释放才会被回收。<br>相反，弱引用persistent句柄会被垃圾回收器跟踪，当需要回收时，回收器会通过回调函数通知程序。接着程序释放掉关联的资源或者复用这个句柄如果对象还要在后续使用的话。<br>在Node v0.10中这么写：  </p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
      <span class="n">object</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>  <span class="c1">// or .ClearWeak() if you want to keep it around</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">;</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">();</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span> <span class="o">=</span>
          <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;::</span><span class="n">New</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">MakeWeak</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">),</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="kt">void</span> <span class="nf">WeakCallback</span><span class="p">(</span><span class="k">const</span> <span class="n">v8</span><span class="o">::</span><span class="n">WeakCallbackData</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">());</span>
      <span class="c1">//persistent的存储单元将会自动清除。</span>
      <span class="c1">//如果你想保持对原始v8::Persistent&lt;T&gt;的引用，你可以使用.ClearWeak()来复用它。</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Example</span><span class="p">(</span><span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">HandleScope</span> <span class="n">handle_scope</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span> <span class="o">=</span> <span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">New</span><span class="p">(</span><span class="n">isolate</span><span class="p">);</span>
      <span class="n">v8</span><span class="o">::</span><span class="n">Persistent</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">persistent</span><span class="p">(</span><span class="n">isolate</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
      <span class="n">persistent</span><span class="p">.</span><span class="n">SetWeak</span><span class="p">(</span><span class="s">&quot;fortytwo&quot;</span><span class="p">,</span> <span class="n">WeakCallback</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</code></pre>
<h2><a name="v8throwexception-v8isolatethrowexception" class="anchor" href="#v8throwexception-v8isolatethrowexception"><span class="header-link"></span></a>v8::ThrowException()现在变成了 v8::Isolate::ThrowException()</h2>
<p>在Node v0.10中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>在Node v0.12中这么写：</p>
<pre><code class="lang-c++"><div class="highlight"><pre>    <span class="n">v8</span><span class="o">::</span><span class="n">Isolate</span><span class="o">*</span> <span class="n">isolate</span> <span class="o">=</span> <span class="cm">/* ... */</span>
    <span class="n">v8</span><span class="o">::</span><span class="n">Local</span><span class="o">&lt;</span><span class="n">v8</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">exception</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">isolate</span><span class="o">-&gt;</span><span class="n">ThrowException</span><span class="p">(</span><span class="n">exception</span><span class="p">);</span>
</pre></div>
</code></pre>
</div>

<a name="comments"></a>
<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key="posts/node0-12capi/" data-title="即将面临的Node0.12中的C++API的改变" data-url="http://blog.whyun.com/posts/node0-12capi/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"whyun"};
(function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
	 || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>
<!-- 多说公共JS代码 end -->



    </div>
    <script src="//upcdn.b0.upaiyun.com/libs/jquery/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="/scripts/main.js" type="text/javascript"></script>
    <script  type="text/javascript">
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?628c040f31bc950845419d51d5cbebeb";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
    </script>
  </body>
</html>

